---
title: "Create a Testable HTTP Client Service"
id: "create-a-testable-http-client-service"
skillLevel: "intermediate"
useCase:
  - "Making HTTP Requests"
  - "Testing"
summary: "Define an HttpClient service with separate 'Live' and 'Test' layers to enable robust, testable interactions with external APIs."
tags:
  - "http-client"
  - "service"
  - "testing"
  - "dependency-injection"
  - "layer"
  - "fetch"
rule:
  description: "Define an HttpClient service with distinct Live and Test layers to enable testable API interactions."
related:
  - "model-dependencies-as-services"
  - "define-service-with-effect-service"
  - "mocking-dependencies-in-tests"
author: "effect_website"
---

## Guideline

To interact with external APIs, define an `HttpClient` service. Create two separate `Layer` implementations for this service:
1.  **`HttpClientLive`**: The production implementation that uses a real HTTP client (like `fetch`) to make network requests.
2.  **`HttpClientTest`**: A test implementation that returns mock data, allowing you to test your business logic without making actual network calls.

---

## Rationale

Directly using `fetch` in your business logic makes it nearly impossible to test. Your tests would become slow, flaky (dependent on network conditions), and could have unintended side effects.

By abstracting the HTTP client into a service, you decouple your application's logic from the specific implementation of how HTTP requests are made. Your business logic depends only on the abstract `HttpClient` interface. In production, you provide the `Live` layer. In tests, you provide the `Test` layer. This makes your tests fast, deterministic, and reliable.

---

## Good Example

### 1. Define the Service

```typescript
// src/services/HttpClient.ts
import { Effect, Data } from "effect";

// Define potential errors
export class HttpError extends Data.TaggedError("HttpError")<{
  readonly error: unknown;
}> {}

// Define the service interface
export class HttpClient extends Effect.Tag("HttpClient")<
  HttpClient,
  {
    readonly get: (
      url: string,
    ) => Effect.Effect<unknown, HttpError>;
  }
>() {}
```

### 2. Create the Live Implementation

```typescript
// src/services/HttpClientLive.ts
import { Effect, Layer } from "effect";
import { HttpClient, HttpError } from "./HttpClient";

export const HttpClientLive = Layer.succeed(
  HttpClient,
  HttpClient.of({
    get: (url) =>
      Effect.tryPromise({
        try: () => fetch(url).then((res) => res.json()),
        catch: (error) => new HttpError({ error }),
      }),
  }),
);
```

### 3. Create the Test Implementation

```typescript
// src/services/HttpClientTest.ts
import { Effect, Layer } from "effect";
import { HttpClient } from "./HttpClient";

export const HttpClientTest = Layer.succeed(
  HttpClient,
  HttpClient.of({
    get: (url) => Effect.succeed({ mock: "data", url }),
  }),
);
```

### 4. Usage in Business Logic

Your business logic is now clean and only depends on the abstract `HttpClient`.

```typescript
// src/features/User/UserService.ts
import { Effect } from "effect";
import { HttpClient } from "../../services/HttpClient";

export const getUserFromApi = (id: number) =>
  Effect.gen(function* () {
    const client = yield* HttpClient;
    const data = yield* client.get(`https://api.example.com/users/${id}`);
    // ... logic to parse and return user
    return data;
  });
```

---

## Anti-Pattern

Calling `fetch` directly from within your business logic functions. This creates a hard dependency on the global `fetch` API, making the function difficult to test and reuse.

```typescript
import { Effect } from "effect";

// âŒ WRONG: This function is not easily testable.
export const getUserDirectly = (id: number) =>
  Effect.tryPromise({
    try: () => fetch(`https://api.example.com/users/${id}`).then((res) => res.json()),
    catch: () => "ApiError" as const,
  });
```