---
title: "Define Type-Safe Errors with Data.TaggedError"
id: "define-tagged-errors"
skillLevel: "intermediate"
useCase: ["Error Management", "Domain Modeling"]
summary: "Create custom, type-safe error classes by extending Data.TaggedError to make error handling robust, predictable, and self-documenting."
tags: ["error-handling", "tagged-error", "type-safety", "Data.TaggedError", "errors"]
rule:
  description: "Define type-safe errors with Data.TaggedError."
related: ["handle-errors-with-catch", "wrap-asynchronous-computations"]
author: "Sandro Maglione"
---

# Define Type-Safe Errors with Data.TaggedError

## Guideline

For any distinct failure mode in your application, define a custom error class
that extends `Data.TaggedError`.

## Rationale

This gives each error a unique, literal `_tag` that Effect can use for type
discrimination with `Effect.catchTag`, making your error handling fully
type-safe.

## Good Example

```typescript
import { Data, Effect } from "effect";

class DatabaseError extends Data.TaggedError("DatabaseError")<{
  readonly cause: unknown;
}> {}

const findUser = (id: number): Effect.Effect<any, DatabaseError> =>
  Effect.fail(new DatabaseError({ cause: "Connection timed out" }));
```

**Explanation:**  
Tagged errors allow you to handle errors in a type-safe, self-documenting way.

## Anti-Pattern

Using generic `Error` objects or strings in the error channel. This loses all
type information, forcing consumers to use `catchAll` and perform unsafe
checks.
