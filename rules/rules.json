[
  {
    "id": "access-config-in-context",
    "title": "Access Configuration from the Context",
    "description": "Access configuration from the Effect context.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Config, Effect, Layer } from \"effect\";\n\n// Define config service\nclass AppConfig extends Effect.Service<AppConfig>()(\n  \"AppConfig\",\n  {\n    sync: () => ({\n      host: \"localhost\",\n      port: 3000\n    })\n  }\n) {}\n\n// Create program that uses config\nconst program = Effect.gen(function* () {\n  const config = yield* AppConfig;\n  yield* Effect.log(`Starting server on http://${config.host}:${config.port}`);\n});\n\n// Run the program with default config\nEffect.runPromise(\n  Effect.provide(program, AppConfig.Default)\n);\n```\n\n**Explanation:**  \nBy yielding the config object, you make your dependency explicit and leverage Effect's context system for testability and modularity.",
    "antiPattern": "Passing configuration values down through multiple function arguments (\"prop-drilling\"). This is cumbersome and obscures which components truly need which values.",
    "explanation": "This allows your business logic to declaratively state its dependency on a piece of configuration. The logic is clean, type-safe, and completely decoupled from *how* the configuration is provided.",
    "content": "# Access Configuration from the Context\n\n## Guideline\n\nInside an `Effect.gen` block, use `yield*` on your `Config` object to access the resolved, type-safe configuration values from the context.\n\n## Rationale\n\nThis allows your business logic to declaratively state its dependency on a piece of configuration. The logic is clean, type-safe, and completely decoupled from *how* the configuration is provided.\n\n## Good Example\n\n```typescript\nimport { Config, Effect, Layer } from \"effect\";\n\n// Define config service\nclass AppConfig extends Effect.Service<AppConfig>()(\n  \"AppConfig\",\n  {\n    sync: () => ({\n      host: \"localhost\",\n      port: 3000\n    })\n  }\n) {}\n\n// Create program that uses config\nconst program = Effect.gen(function* () {\n  const config = yield* AppConfig;\n  yield* Effect.log(`Starting server on http://${config.host}:${config.port}`);\n});\n\n// Run the program with default config\nEffect.runPromise(\n  Effect.provide(program, AppConfig.Default)\n);\n```\n\n**Explanation:**  \nBy yielding the config object, you make your dependency explicit and leverage Effect's context system for testability and modularity.\n\n## Anti-Pattern\n\nPassing configuration values down through multiple function arguments (\"prop-drilling\"). This is cumbersome and obscures which components truly need which values."
  },
  {
    "id": "accessing-current-time-with-clock",
    "title": "Accessing the Current Time with Clock",
    "description": "Use the Clock service to get the current time, enabling deterministic testing with TestClock.",
    "skillLevel": "intermediate",
    "useCases": [
      "testing"
    ],
    "example": "This example shows a function that checks if a token is expired. Its logic depends on `Clock`, making it fully testable.\n\n```typescript\nimport { Effect, Clock, Duration } from \"effect\";\n\ninterface Token {\n  readonly value: string;\n  readonly expiresAt: number; // UTC milliseconds\n}\n\n// This function is pure and testable because it depends on Clock\nconst isTokenExpired = (token: Token): Effect.Effect<boolean, never, Clock.Clock> =>\n  Clock.currentTimeMillis.pipe(\n    Effect.map((now) => now > token.expiresAt),\n    Effect.tap((expired) => \n      Clock.currentTimeMillis.pipe(\n        Effect.flatMap((currentTime) => \n          Effect.log(`Token expired? ${expired} (current time: ${new Date(currentTime).toISOString()})`)\n        )\n      )\n    )\n  );\n\n// Create a test clock service that advances time\nconst makeTestClock = (timeMs: number): Clock.Clock => ({\n  currentTimeMillis: Effect.succeed(timeMs),\n  currentTimeNanos: Effect.succeed(BigInt(timeMs * 1_000_000)),\n  sleep: (duration: Duration.Duration) => Effect.succeed(void 0),\n  unsafeCurrentTimeMillis: () => timeMs,\n  unsafeCurrentTimeNanos: () => BigInt(timeMs * 1_000_000),\n  [Clock.ClockTypeId]: Clock.ClockTypeId,\n});\n\n// Create a token that expires in 1 second\nconst token = { value: \"abc\", expiresAt: Date.now() + 1000 };\n\n// Check token expiry with different clocks\nconst program = Effect.gen(function* () {\n  // Check with current time\n  yield* Effect.log(\"Checking with current time...\");\n  yield* isTokenExpired(token);\n\n  // Check with past time\n  yield* Effect.log(\"\\nChecking with past time (1 minute ago)...\");\n  const pastClock = makeTestClock(Date.now() - 60_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, pastClock)\n  );\n\n  // Check with future time\n  yield* Effect.log(\"\\nChecking with future time (1 hour ahead)...\");\n  const futureClock = makeTestClock(Date.now() + 3600_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, futureClock)\n  );\n});\n\n// Run the program with default clock\nEffect.runPromise(\n  program.pipe(\n    Effect.provideService(Clock.Clock, makeTestClock(Date.now()))\n  )\n);\n```\n\n---",
    "antiPattern": "Directly calling `Date.now()` inside your business logic. This creates an impure function that cannot be tested reliably without manipulating the system clock, which is a bad practice.\n\n```typescript\nimport { Effect } from \"effect\";\n\ninterface Token { readonly expiresAt: number; }\n\n// ‚ùå WRONG: This function's behavior changes every millisecond.\nconst isTokenExpiredUnsafely = (token: Token): Effect.Effect<boolean> =>\n  Effect.sync(() => Date.now() > token.expiresAt);\n\n// Testing this function would require complex mocking of global APIs\n// or would be non-deterministic.\n```",
    "explanation": "Directly calling `Date.now()` makes your code impure and tightly coupled to the system clock. This makes testing difficult and unreliable, as the output of your function will change every time it's run.\n\nThe `Clock` service is Effect's solution to this problem. It's an abstraction for \"the current time.\"\n-   In **production**, the default `Live` `Clock` implementation uses the real system time.\n-   In **tests**, you can provide the `TestClock` layer. This gives you a virtual clock that you can manually control, allowing you to set the time to a specific value or advance it by a specific duration.\n\nThis makes any time-dependent logic pure, deterministic, and easy to test with perfect precision.\n\n---",
    "content": "## Guideline\n\nWhenever you need to get the current time within an `Effect`, do not call `Date.now()` directly. Instead, depend on the `Clock` service and use one of its methods, such as `Clock.currentTimeMillis`.\n\n---\n\n## Rationale\n\nDirectly calling `Date.now()` makes your code impure and tightly coupled to the system clock. This makes testing difficult and unreliable, as the output of your function will change every time it's run.\n\nThe `Clock` service is Effect's solution to this problem. It's an abstraction for \"the current time.\"\n-   In **production**, the default `Live` `Clock` implementation uses the real system time.\n-   In **tests**, you can provide the `TestClock` layer. This gives you a virtual clock that you can manually control, allowing you to set the time to a specific value or advance it by a specific duration.\n\nThis makes any time-dependent logic pure, deterministic, and easy to test with perfect precision.\n\n---\n\n## Good Example\n\nThis example shows a function that checks if a token is expired. Its logic depends on `Clock`, making it fully testable.\n\n```typescript\nimport { Effect, Clock, Duration } from \"effect\";\n\ninterface Token {\n  readonly value: string;\n  readonly expiresAt: number; // UTC milliseconds\n}\n\n// This function is pure and testable because it depends on Clock\nconst isTokenExpired = (token: Token): Effect.Effect<boolean, never, Clock.Clock> =>\n  Clock.currentTimeMillis.pipe(\n    Effect.map((now) => now > token.expiresAt),\n    Effect.tap((expired) => \n      Clock.currentTimeMillis.pipe(\n        Effect.flatMap((currentTime) => \n          Effect.log(`Token expired? ${expired} (current time: ${new Date(currentTime).toISOString()})`)\n        )\n      )\n    )\n  );\n\n// Create a test clock service that advances time\nconst makeTestClock = (timeMs: number): Clock.Clock => ({\n  currentTimeMillis: Effect.succeed(timeMs),\n  currentTimeNanos: Effect.succeed(BigInt(timeMs * 1_000_000)),\n  sleep: (duration: Duration.Duration) => Effect.succeed(void 0),\n  unsafeCurrentTimeMillis: () => timeMs,\n  unsafeCurrentTimeNanos: () => BigInt(timeMs * 1_000_000),\n  [Clock.ClockTypeId]: Clock.ClockTypeId,\n});\n\n// Create a token that expires in 1 second\nconst token = { value: \"abc\", expiresAt: Date.now() + 1000 };\n\n// Check token expiry with different clocks\nconst program = Effect.gen(function* () {\n  // Check with current time\n  yield* Effect.log(\"Checking with current time...\");\n  yield* isTokenExpired(token);\n\n  // Check with past time\n  yield* Effect.log(\"\\nChecking with past time (1 minute ago)...\");\n  const pastClock = makeTestClock(Date.now() - 60_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, pastClock)\n  );\n\n  // Check with future time\n  yield* Effect.log(\"\\nChecking with future time (1 hour ahead)...\");\n  const futureClock = makeTestClock(Date.now() + 3600_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, futureClock)\n  );\n});\n\n// Run the program with default clock\nEffect.runPromise(\n  program.pipe(\n    Effect.provideService(Clock.Clock, makeTestClock(Date.now()))\n  )\n);\n```\n\n---\n\n## Anti-Pattern\n\nDirectly calling `Date.now()` inside your business logic. This creates an impure function that cannot be tested reliably without manipulating the system clock, which is a bad practice.\n\n```typescript\nimport { Effect } from \"effect\";\n\ninterface Token { readonly expiresAt: number; }\n\n// ‚ùå WRONG: This function's behavior changes every millisecond.\nconst isTokenExpiredUnsafely = (token: Token): Effect.Effect<boolean> =>\n  Effect.sync(() => Date.now() > token.expiresAt);\n\n// Testing this function would require complex mocking of global APIs\n// or would be non-deterministic.\n```"
  },
  {
    "id": "accumulate-multiple-errors-with-either",
    "title": "Accumulate Multiple Errors with Either",
    "description": "Use Either to accumulate multiple validation errors instead of failing on the first one.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "Using `Schema.decode` with the `allErrors: true` option demonstrates this pattern perfectly. The underlying mechanism uses `Either` to collect all parsing errors into an array instead of stopping at the first one.\n\n````typescript\nimport { Effect, Schema, Data, Either } from \"effect\";\n\n// Define validation error type\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define user type\ntype User = {\n  name: string;\n  email: string;\n};\n\n// Define schema with custom validation\nconst UserSchema = Schema.Struct({\n  name: Schema.String.pipe(\n    Schema.minLength(3),\n    Schema.filter((name) => /^[A-Za-z\\s]+$/.test(name), {\n      message: () => \"name must contain only letters and spaces\"\n    })\n  ),\n  email: Schema.String.pipe(\n    Schema.pattern(/@/),\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/, {\n      message: () => \"email must be a valid email address\"\n    })\n  ),\n});\n\n// Example inputs\nconst invalidInputs: User[] = [\n  {\n    name: \"Al\", // Too short\n    email: \"bob-no-at-sign.com\", // Invalid pattern\n  },\n  {\n    name: \"John123\", // Contains numbers\n    email: \"john@incomplete\", // Invalid email\n  },\n  {\n    name: \"Alice Smith\", // Valid\n    email: \"alice@example.com\", // Valid\n  }\n];\n\n// Validate a single user\nconst validateUser = (input: User) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decode(UserSchema)(input, { errors: \"all\" });\n    return result;\n  });\n\n// Process multiple users and accumulate all errors\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Validating users...\\n\");\n  \n  for (const input of invalidInputs) {\n    const result = yield* Effect.either(validateUser(input));\n    \n    yield* Effect.log(`Validating user: ${input.name} <${input.email}>`);\n    \n    // Handle success and failure cases separately for clarity\n    // Using Either.match which is the idiomatic way to handle Either values\n    yield* Either.match(result, {\n      onLeft: (error) => Effect.gen(function* () {\n        yield* Effect.log(\"‚ùå Validation failed:\");\n        yield* Effect.log(error.message);\n        yield* Effect.log(\"\"); // Empty line for readability\n      }),\n      onRight: (user) => Effect.gen(function* () {\n        yield* Effect.log(`‚úÖ User is valid: ${JSON.stringify(user)}`);\n        yield* Effect.log(\"\"); // Empty line for readability\n      })\n    })\n  }\n});\n\n// Run the program\nEffect.runSync(program);\n````\n\n---",
    "antiPattern": "Using `Effect`'s error channel for validation that requires multiple error messages. The code below will only ever report the first error it finds, because `Effect.fail` short-circuits the entire `Effect.gen` block.\n\n````typescript\nimport { Effect } from \"effect\";\n\nconst validateWithEffect = (input: { name: string; email: string }) =>\n  Effect.gen(function* () {\n    if (input.name.length < 3) {\n      // The program will fail here and never check the email.\n      return yield* Effect.fail(\"Name is too short.\");\n    }\n    if (!input.email.includes(\"@\")) {\n      return yield* Effect.fail(\"Email is invalid.\");\n    }\n    return yield* Effect.succeed(input);\n  });\n````",
    "explanation": "The `Effect` error channel is designed to short-circuit. The moment an `Effect` fails, the entire computation stops and the error is propagated. This is perfect for handling unrecoverable errors like a lost database connection.\n\nHowever, for tasks like validating a user's input, this is poor user experience. You want to show the user all of their mistakes at once.\n\n`Either` is the solution. Since it's a pure data structure, you can run multiple checks that each return an `Either`, and then combine the results to accumulate all the `Left` (error) values. The `Effect/Schema` module uses this pattern internally to provide powerful error accumulation.\n\n---",
    "content": "## Guideline\n\nWhen you need to perform multiple validation checks and collect all failures, use the ``Either<E, A>`` data type. ``Either`` represents a value that can be one of two possibilities: a ``Left<E>`` (typically for failure) or a ``Right<A>`` (typically for success).\n\n---\n\n## Rationale\n\nThe `Effect` error channel is designed to short-circuit. The moment an `Effect` fails, the entire computation stops and the error is propagated. This is perfect for handling unrecoverable errors like a lost database connection.\n\nHowever, for tasks like validating a user's input, this is poor user experience. You want to show the user all of their mistakes at once.\n\n`Either` is the solution. Since it's a pure data structure, you can run multiple checks that each return an `Either`, and then combine the results to accumulate all the `Left` (error) values. The `Effect/Schema` module uses this pattern internally to provide powerful error accumulation.\n\n---\n\n## Good Example\n\nUsing `Schema.decode` with the `allErrors: true` option demonstrates this pattern perfectly. The underlying mechanism uses `Either` to collect all parsing errors into an array instead of stopping at the first one.\n\n````typescript\nimport { Effect, Schema, Data, Either } from \"effect\";\n\n// Define validation error type\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define user type\ntype User = {\n  name: string;\n  email: string;\n};\n\n// Define schema with custom validation\nconst UserSchema = Schema.Struct({\n  name: Schema.String.pipe(\n    Schema.minLength(3),\n    Schema.filter((name) => /^[A-Za-z\\s]+$/.test(name), {\n      message: () => \"name must contain only letters and spaces\"\n    })\n  ),\n  email: Schema.String.pipe(\n    Schema.pattern(/@/),\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/, {\n      message: () => \"email must be a valid email address\"\n    })\n  ),\n});\n\n// Example inputs\nconst invalidInputs: User[] = [\n  {\n    name: \"Al\", // Too short\n    email: \"bob-no-at-sign.com\", // Invalid pattern\n  },\n  {\n    name: \"John123\", // Contains numbers\n    email: \"john@incomplete\", // Invalid email\n  },\n  {\n    name: \"Alice Smith\", // Valid\n    email: \"alice@example.com\", // Valid\n  }\n];\n\n// Validate a single user\nconst validateUser = (input: User) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decode(UserSchema)(input, { errors: \"all\" });\n    return result;\n  });\n\n// Process multiple users and accumulate all errors\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Validating users...\\n\");\n  \n  for (const input of invalidInputs) {\n    const result = yield* Effect.either(validateUser(input));\n    \n    yield* Effect.log(`Validating user: ${input.name} <${input.email}>`);\n    \n    // Handle success and failure cases separately for clarity\n    // Using Either.match which is the idiomatic way to handle Either values\n    yield* Either.match(result, {\n      onLeft: (error) => Effect.gen(function* () {\n        yield* Effect.log(\"‚ùå Validation failed:\");\n        yield* Effect.log(error.message);\n        yield* Effect.log(\"\"); // Empty line for readability\n      }),\n      onRight: (user) => Effect.gen(function* () {\n        yield* Effect.log(`‚úÖ User is valid: ${JSON.stringify(user)}`);\n        yield* Effect.log(\"\"); // Empty line for readability\n      })\n    })\n  }\n});\n\n// Run the program\nEffect.runSync(program);\n````\n\n---\n\n## Anti-Pattern\n\nUsing `Effect`'s error channel for validation that requires multiple error messages. The code below will only ever report the first error it finds, because `Effect.fail` short-circuits the entire `Effect.gen` block.\n\n````typescript\nimport { Effect } from \"effect\";\n\nconst validateWithEffect = (input: { name: string; email: string }) =>\n  Effect.gen(function* () {\n    if (input.name.length < 3) {\n      // The program will fail here and never check the email.\n      return yield* Effect.fail(\"Name is too short.\");\n    }\n    if (!input.email.includes(\"@\")) {\n      return yield* Effect.fail(\"Email is invalid.\");\n    }\n    return yield* Effect.succeed(input);\n  });\n````"
  },
  {
    "id": "data-either",
    "title": "Accumulate Multiple Errors with Either",
    "description": "Use Either to model computations that may fail, making errors explicit and type-safe.",
    "skillLevel": "beginner",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Either } from \"effect\";\n\n// Create a Right (success) or Left (failure)\nconst success = Either.right(42); // Either<never, number>\nconst failure = Either.left(\"Something went wrong\"); // Either<string, never>\n\n// Pattern match on Either\nconst result = success.pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string\n\n// Combine multiple Eithers and accumulate errors\nconst e1 = Either.right(1);\nconst e2 = Either.left(\"fail1\");\nconst e3 = Either.left(\"fail2\");\n\nconst all = Either.all([e1, e2, e3]); // Either<string, [number, never, never]>\nconst rights = [e1, e2, e3].filter(Either.isRight); // Right values only\nconst lefts = [e1, e2, e3].filter(Either.isLeft); // Left values only\n\n```\n\n**Explanation:**  \n- `Either.right(value)` represents success.\n- `Either.left(error)` represents failure.\n- Pattern matching ensures all cases are handled.\n- You can accumulate errors or results from multiple Eithers.",
    "antiPattern": "Throwing exceptions or using ad-hoc error codes, which are not type-safe, not composable, and make error handling less predictable.",
    "explanation": "`Either` is a foundational data type for error handling in functional programming.  \nIt allows you to accumulate errors, model domain-specific failures, and avoid exceptions and unchecked errors.",
    "content": "# Accumulate Multiple Errors with `Either`\n\n## Guideline\n\nUse the `Either<E, A>` data type to represent computations that can fail (`Left<E>`) or succeed (`Right<A>`).  \nThis makes error handling explicit, type-safe, and composable.\n\n## Rationale\n\n`Either` is a foundational data type for error handling in functional programming.  \nIt allows you to accumulate errors, model domain-specific failures, and avoid exceptions and unchecked errors.\n\n## Good Example\n\n```typescript\nimport { Either } from \"effect\";\n\n// Create a Right (success) or Left (failure)\nconst success = Either.right(42); // Either<never, number>\nconst failure = Either.left(\"Something went wrong\"); // Either<string, never>\n\n// Pattern match on Either\nconst result = success.pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string\n\n// Combine multiple Eithers and accumulate errors\nconst e1 = Either.right(1);\nconst e2 = Either.left(\"fail1\");\nconst e3 = Either.left(\"fail2\");\n\nconst all = Either.all([e1, e2, e3]); // Either<string, [number, never, never]>\nconst rights = [e1, e2, e3].filter(Either.isRight); // Right values only\nconst lefts = [e1, e2, e3].filter(Either.isLeft); // Left values only\n\n```\n\n**Explanation:**  \n- `Either.right(value)` represents success.\n- `Either.left(error)` represents failure.\n- Pattern matching ensures all cases are handled.\n- You can accumulate errors or results from multiple Eithers.\n\n## Anti-Pattern\n\nThrowing exceptions or using ad-hoc error codes, which are not type-safe, not composable, and make error handling less predictable."
  },
  {
    "id": "add-caching-by-wrapping-a-layer",
    "title": "Add Caching by Wrapping a Layer",
    "description": "Use a wrapping Layer to add cross-cutting concerns like caching to a service without altering its original implementation.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "We have a `WeatherService` that makes slow API calls. We create a `WeatherService.cached` wrapper layer that adds an in-memory cache using a `Ref` and a `Map`.\n\n```typescript\nimport { Effect, Layer, Ref } from \"effect\";\n\n// 1. Define the service interface\nclass WeatherService extends Effect.Service<WeatherService>()(\n  \"WeatherService\",\n  {\n    sync: () => ({\n      getForecast: (city: string) => Effect.succeed(`Sunny in ${city}`),\n    }),\n  }\n) {}\n\n// 2. The \"Live\" implementation that is slow\nconst WeatherServiceLive = Layer.succeed(\n  WeatherService,\n  WeatherService.of({\n    _tag: \"WeatherService\",\n    getForecast: (city) =>\n      Effect.succeed(`Sunny in ${city}`).pipe(\n        Effect.delay(\"2 seconds\"),\n        Effect.tap(() => Effect.log(`Fetched live forecast for ${city}`))\n      ),\n  })\n);\n\n// 3. The Caching Wrapper Layer\nconst WeatherServiceCached = Layer.effect(\n  WeatherService,\n  Effect.gen(function* () {\n    // It REQUIRES the original WeatherService\n    const underlyingService = yield* WeatherService;\n    const cache = yield* Ref.make(new Map<string, string>());\n\n    return WeatherService.of({\n      _tag: \"WeatherService\",\n      getForecast: (city) =>\n        Ref.get(cache).pipe(\n          Effect.flatMap((map) =>\n            map.has(city)\n              ? Effect.log(`Cache HIT for ${city}`).pipe(\n                  Effect.as(map.get(city)!)\n                )\n              : Effect.log(`Cache MISS for ${city}`).pipe(\n                  Effect.flatMap(() => underlyingService.getForecast(city)),\n                  Effect.tap((forecast) =>\n                    Ref.update(cache, (map) => map.set(city, forecast))\n                  )\n                )\n          )\n        ),\n    });\n  })\n);\n\n// 4. Compose the final layer. The wrapper is provided with the live implementation.\nconst AppLayer = Layer.provide(WeatherServiceCached, WeatherServiceLive);\n\n// 5. The application logic\nconst program = Effect.gen(function* () {\n  const weather = yield* WeatherService;\n  yield* weather.getForecast(\"London\"); // First call is slow (MISS)\n  yield* weather.getForecast(\"London\"); // Second call is instant (HIT)\n});\n\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n```\n\n---",
    "antiPattern": "Modifying the original service implementation to include caching logic directly. This violates the Single Responsibility Principle by mixing the core logic of fetching weather with the cross-cutting concern of caching.\n\n```typescript\n// ‚ùå WRONG: The service is now responsible for both its logic and its caching strategy.\nconst WeatherServiceWithInlineCache = Layer.effect(\n  WeatherService,\n  Effect.gen(function* () {\n    const cache = yield* Ref.make(new Map<string, string>());\n    return WeatherService.of({\n      getForecast: (city) => {\n        // ...caching logic mixed directly with fetching logic...\n        return Effect.succeed(\"...\");\n      },\n    });\n  }),\n);\n```",
    "explanation": "You often want to add functionality like caching, logging, or metrics to a service without polluting its core business logic. The wrapper layer pattern is a clean way to achieve this.\n\nBy creating a layer that *requires* the original service, you can get an instance of it from the context, and then provide a *new* implementation of that same service that calls the original.\n\nThis approach is powerful because:\n-   **It's Non-Invasive:** The original service (`DatabaseLive`) remains completely unchanged.\n-   **It's Composable:** You can apply multiple wrappers. You could wrap a database layer with a caching layer, then wrap that with a metrics layer.\n-   **It's Explicit:** The composition is clearly defined at the application's top level where you build your final `AppLayer`.\n\n---",
    "content": "## Guideline\n\nTo add cross-cutting concerns like caching to a service, create a \"wrapper\" `Layer`. This is a layer that takes the original service's `Layer` as input (as a dependency) and returns a new `Layer`. The new layer provides the same service interface but wraps the original methods with additional logic (e.g., checking a cache before calling the original method).\n\n---\n\n## Rationale\n\nYou often want to add functionality like caching, logging, or metrics to a service without polluting its core business logic. The wrapper layer pattern is a clean way to achieve this.\n\nBy creating a layer that *requires* the original service, you can get an instance of it from the context, and then provide a *new* implementation of that same service that calls the original.\n\nThis approach is powerful because:\n-   **It's Non-Invasive:** The original service (`DatabaseLive`) remains completely unchanged.\n-   **It's Composable:** You can apply multiple wrappers. You could wrap a database layer with a caching layer, then wrap that with a metrics layer.\n-   **It's Explicit:** The composition is clearly defined at the application's top level where you build your final `AppLayer`.\n\n---\n\n## Good Example\n\nWe have a `WeatherService` that makes slow API calls. We create a `WeatherService.cached` wrapper layer that adds an in-memory cache using a `Ref` and a `Map`.\n\n```typescript\nimport { Effect, Layer, Ref } from \"effect\";\n\n// 1. Define the service interface\nclass WeatherService extends Effect.Service<WeatherService>()(\n  \"WeatherService\",\n  {\n    sync: () => ({\n      getForecast: (city: string) => Effect.succeed(`Sunny in ${city}`),\n    }),\n  }\n) {}\n\n// 2. The \"Live\" implementation that is slow\nconst WeatherServiceLive = Layer.succeed(\n  WeatherService,\n  WeatherService.of({\n    _tag: \"WeatherService\",\n    getForecast: (city) =>\n      Effect.succeed(`Sunny in ${city}`).pipe(\n        Effect.delay(\"2 seconds\"),\n        Effect.tap(() => Effect.log(`Fetched live forecast for ${city}`))\n      ),\n  })\n);\n\n// 3. The Caching Wrapper Layer\nconst WeatherServiceCached = Layer.effect(\n  WeatherService,\n  Effect.gen(function* () {\n    // It REQUIRES the original WeatherService\n    const underlyingService = yield* WeatherService;\n    const cache = yield* Ref.make(new Map<string, string>());\n\n    return WeatherService.of({\n      _tag: \"WeatherService\",\n      getForecast: (city) =>\n        Ref.get(cache).pipe(\n          Effect.flatMap((map) =>\n            map.has(city)\n              ? Effect.log(`Cache HIT for ${city}`).pipe(\n                  Effect.as(map.get(city)!)\n                )\n              : Effect.log(`Cache MISS for ${city}`).pipe(\n                  Effect.flatMap(() => underlyingService.getForecast(city)),\n                  Effect.tap((forecast) =>\n                    Ref.update(cache, (map) => map.set(city, forecast))\n                  )\n                )\n          )\n        ),\n    });\n  })\n);\n\n// 4. Compose the final layer. The wrapper is provided with the live implementation.\nconst AppLayer = Layer.provide(WeatherServiceCached, WeatherServiceLive);\n\n// 5. The application logic\nconst program = Effect.gen(function* () {\n  const weather = yield* WeatherService;\n  yield* weather.getForecast(\"London\"); // First call is slow (MISS)\n  yield* weather.getForecast(\"London\"); // Second call is instant (HIT)\n});\n\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n```\n\n---\n\n## Anti-Pattern\n\nModifying the original service implementation to include caching logic directly. This violates the Single Responsibility Principle by mixing the core logic of fetching weather with the cross-cutting concern of caching.\n\n```typescript\n// ‚ùå WRONG: The service is now responsible for both its logic and its caching strategy.\nconst WeatherServiceWithInlineCache = Layer.effect(\n  WeatherService,\n  Effect.gen(function* () {\n    const cache = yield* Ref.make(new Map<string, string>());\n    return WeatherService.of({\n      getForecast: (city) => {\n        // ...caching logic mixed directly with fetching logic...\n        return Effect.succeed(\"...\");\n      },\n    });\n  }),\n);\n```"
  },
  {
    "id": "observability-custom-metrics",
    "title": "Add Custom Metrics to Your Application",
    "description": "Use Effect's Metric module to define and update custom metrics for business and performance monitoring.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Effect, Metric, MetricBoundaries } from \"effect\";\n\n// Define a counter metric for processed jobs\nconst jobsProcessed = Metric.counter(\"jobs_processed\");\n\n// Increment the counter when a job is processed\nconst processJob = Effect.gen(function* () {\n  // ... process the job\n  yield* Effect.log(\"Job processed\");\n  yield* Metric.increment(jobsProcessed);\n});\n\n// Define a gauge for current active users\nconst activeUsers = Metric.gauge(\"active_users\");\n\n// Update the gauge when users sign in or out\nconst userSignedIn = Metric.set(activeUsers, 1);\nconst userSignedOut = Metric.set(activeUsers, -1);\n\n// Define a histogram for request durations\nconst requestDuration = Metric.histogram(\n  \"request_duration\",\n  MetricBoundaries.linear({ start: 0, width: 1, count: 6 })\n);\n\n// Record a request duration\nconst recordDuration = (duration: number) =>\n  Metric.update(requestDuration, duration);\n\n```\n\n**Explanation:**  \n- `Metric.counter` tracks counts of events.\n- `Metric.gauge` tracks a value that can go up or down (e.g., active users).\n- `Metric.histogram` tracks distributions (e.g., request durations).\n- `Effect.updateMetric` updates the metric in your workflow.",
    "antiPattern": "Relying solely on logs for monitoring, or using ad-hoc counters and variables that are not integrated with your observability stack.",
    "explanation": "Metrics provide quantitative insight into your application's behavior and performance.  \nBy instrumenting your code with metrics, you can monitor key events, detect anomalies, and drive business decisions.",
    "content": "# Add Custom Metrics to Your Application\n\n## Guideline\n\nUse Effect's `Metric` module to define and update custom metrics such as counters, gauges, and histograms.  \nThis allows you to track business events, performance indicators, and system health in a type-safe and composable way.\n\n## Rationale\n\nMetrics provide quantitative insight into your application's behavior and performance.  \nBy instrumenting your code with metrics, you can monitor key events, detect anomalies, and drive business decisions.\n\n## Good Example\n\n```typescript\nimport { Effect, Metric, MetricBoundaries } from \"effect\";\n\n// Define a counter metric for processed jobs\nconst jobsProcessed = Metric.counter(\"jobs_processed\");\n\n// Increment the counter when a job is processed\nconst processJob = Effect.gen(function* () {\n  // ... process the job\n  yield* Effect.log(\"Job processed\");\n  yield* Metric.increment(jobsProcessed);\n});\n\n// Define a gauge for current active users\nconst activeUsers = Metric.gauge(\"active_users\");\n\n// Update the gauge when users sign in or out\nconst userSignedIn = Metric.set(activeUsers, 1);\nconst userSignedOut = Metric.set(activeUsers, -1);\n\n// Define a histogram for request durations\nconst requestDuration = Metric.histogram(\n  \"request_duration\",\n  MetricBoundaries.linear({ start: 0, width: 1, count: 6 })\n);\n\n// Record a request duration\nconst recordDuration = (duration: number) =>\n  Metric.update(requestDuration, duration);\n\n```\n\n**Explanation:**  \n- `Metric.counter` tracks counts of events.\n- `Metric.gauge` tracks a value that can go up or down (e.g., active users).\n- `Metric.histogram` tracks distributions (e.g., request durations).\n- `Effect.updateMetric` updates the metric in your workflow.\n\n## Anti-Pattern\n\nRelying solely on logs for monitoring, or using ad-hoc counters and variables that are not integrated with your observability stack."
  },
  {
    "id": "add-custom-metrics",
    "title": "Add Custom Metrics to Your Application",
    "description": "Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "This example creates a counter to track how many times a user is created and a histogram to track the duration of the database operation.\n\n```typescript\nimport { Effect, Metric, Duration } from \"effect\";  // We don't need MetricBoundaries anymore\n\n// 1. Define your metrics\nconst userRegisteredCounter = Metric.counter(\"users_registered_total\", {\n  description: \"A counter for how many users have been registered.\",\n});\n\nconst dbDurationTimer = Metric.timer(\n  \"db_operation_duration\",\n  \"A timer for DB operation durations\"\n);\n\n// 2. Simulated database call\nconst saveUserToDb = Effect.succeed(\"user saved\").pipe(\n  Effect.delay(Duration.millis(Math.random() * 100)),\n);\n\n// 3. Instrument the business logic\nconst createUser = Effect.gen(function* () {\n  // Time the operation\n  yield* saveUserToDb.pipe(Metric.trackDuration(dbDurationTimer));\n\n  // Increment the counter\n  yield* Metric.increment(userRegisteredCounter);\n\n  return { status: \"success\" };\n});\n\n// Run the Effect\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* createUser;\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---",
    "antiPattern": "Not adding any metrics to your application. Without metrics, you are flying blind. You have no high-level overview of your application's health, performance, or business KPIs. You can't build dashboards, you can't set up alerts for abnormal behavior (e.g., \"error rate is too high\"), and you are forced to rely on digging through logs to \nunderstand the state of your system.",
    "explanation": "While logs are for events and traces are for requests, metrics are for aggregation. They provide a high-level, numerical view of your system's health over time, which is perfect for building dashboards and setting up alerts.\n\nEffect's `Metric` module provides a simple, declarative way to add this instrumentation. By defining your metrics upfront, you can then use operators like `Metric.increment` or `Effect.timed` to update them. This is fully integrated with Effect's context system, allowing you to provide different metric backends (like Prometheus or StatsD) via a `Layer`.\n\nThis allows you to answer questions like:\n-   \"What is our user sign-up rate over the last 24 hours?\"\n-   \"Are we approaching our maximum number of database connections?\"\n-   \"What is the 95th percentile latency for our API requests?\"\n\n---",
    "content": "## Guideline\n\nTo monitor the health and performance of your application, instrument your code with `Metric`s. The three main types are:\n-   **`Metric.counter(\"name\")`**: To count occurrences of an event (e.g., `users_registered_total`). It only goes up.\n-   **`Metric.gauge(\"name\")`**: To track a value that can go up or down (e.g., `active_connections`).\n-   **`Metric.histogram(\"name\")`**: To track the distribution of a value (e.g., `request_duration_seconds`).\n\n---\n\n## Rationale\n\nWhile logs are for events and traces are for requests, metrics are for aggregation. They provide a high-level, numerical view of your system's health over time, which is perfect for building dashboards and setting up alerts.\n\nEffect's `Metric` module provides a simple, declarative way to add this instrumentation. By defining your metrics upfront, you can then use operators like `Metric.increment` or `Effect.timed` to update them. This is fully integrated with Effect's context system, allowing you to provide different metric backends (like Prometheus or StatsD) via a `Layer`.\n\nThis allows you to answer questions like:\n-   \"What is our user sign-up rate over the last 24 hours?\"\n-   \"Are we approaching our maximum number of database connections?\"\n-   \"What is the 95th percentile latency for our API requests?\"\n\n---\n\n## Good Example\n\nThis example creates a counter to track how many times a user is created and a histogram to track the duration of the database operation.\n\n```typescript\nimport { Effect, Metric, Duration } from \"effect\";  // We don't need MetricBoundaries anymore\n\n// 1. Define your metrics\nconst userRegisteredCounter = Metric.counter(\"users_registered_total\", {\n  description: \"A counter for how many users have been registered.\",\n});\n\nconst dbDurationTimer = Metric.timer(\n  \"db_operation_duration\",\n  \"A timer for DB operation durations\"\n);\n\n// 2. Simulated database call\nconst saveUserToDb = Effect.succeed(\"user saved\").pipe(\n  Effect.delay(Duration.millis(Math.random() * 100)),\n);\n\n// 3. Instrument the business logic\nconst createUser = Effect.gen(function* () {\n  // Time the operation\n  yield* saveUserToDb.pipe(Metric.trackDuration(dbDurationTimer));\n\n  // Increment the counter\n  yield* Metric.increment(userRegisteredCounter);\n\n  return { status: \"success\" };\n});\n\n// Run the Effect\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* createUser;\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---\n\n## Anti-Pattern\n\nNot adding any metrics to your application. Without metrics, you are flying blind. You have no high-level overview of your application's health, performance, or business KPIs. You can't build dashboards, you can't set up alerts for abnormal behavior (e.g., \"error rate is too high\"), and you are forced to rely on digging through logs to \nunderstand the state of your system."
  },
  {
    "id": "stream-retry-on-failure",
    "title": "Automatically Retry Failed Operations",
    "description": "Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example simulates an API that fails the first two times it's called. The stream processes a list of IDs, and the `retry` operator ensures that the failing operation for `id: 2` is automatically retried until it succeeds.\n\n````typescript\nimport { Effect, Stream, Schedule } from \"effect\";\n\n// A mock function that simulates a flaky API call\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Attempting to process item ${id}...`);\n\n    // Item 2 fails on first attempt but succeeds on retry\n    if (id === 2) {\n      const random = Math.random();\n      if (random < 0.5) {\n        // 50% chance of failure for demonstration\n        yield* Effect.log(`Item ${id} failed, will retry...`);\n        return yield* Effect.fail(new Error(\"API is temporarily down\"));\n      }\n    }\n\n    yield* Effect.log(`‚úÖ Successfully processed item ${id}`);\n    return `Processed item ${id}`;\n  });\n\nconst ids = [1, 2, 3];\n\n// Define a retry policy: 3 attempts with a fixed 100ms delay\nconst retryPolicy = Schedule.recurs(3).pipe(\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Retry on Failure Demo ===\");\n  yield* Effect.log(\n    \"Processing items with retry policy (3 attempts, 100ms delay)\"\n  );\n\n  // Process each item individually with retry\n  const results = yield* Effect.forEach(\n    ids,\n    (id) =>\n      processItem(id).pipe(\n        Effect.retry(retryPolicy),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(\n              `‚ùå Item ${id} failed after all retries: ${error.message}`\n            );\n            return `Failed: item ${id}`;\n          })\n        )\n      ),\n    { concurrency: 1 }\n  );\n\n  yield* Effect.log(\"=== Results ===\");\n  for (let index = 0; index < results.length; index++) {\n  yield* Effect.log(`Item ${ids[index]}: ${results[index]}`);\n}\n\n  yield* Effect.log(\"‚úÖ Stream processing completed\");\n});\n\nEffect.runPromise(program).catch((error) => {\n  Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 2.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Attempting to process item 3...\"\n*/\n\n````",
    "antiPattern": "The anti-pattern is to either have no retry logic at all, or to write manual, imperative retry loops inside your processing function.\n\n````typescript\nimport { Effect, Stream } from 'effect';\n// ... same mock processItem function ...\n\nconst ids = [1, 2, 3];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // No retry logic. The entire stream will fail when item 2 fails.\n  Stream.mapEffect(processItem, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program).catch((error) => {\n  console.error('Pipeline failed:', error);\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\nPipeline failed: Error: API is temporarily down\n*/\n````\n\nThis \"fail-fast\" approach is brittle. A single, temporary network blip would cause the entire pipeline to terminate, even if subsequent items could have been processed successfully. While manual retry logic inside `processItem` is possible, it pollutes the core logic with concerns about timing and attempt counting, and is far less composable and reusable than a `Schedule`.",
    "explanation": "Real-world systems are unreliable. Network connections drop, APIs return temporary `503` errors, and databases can experience deadlocks. A naive pipeline will fail completely on the first sign of trouble. A resilient pipeline, however, can absorb these transient errors and heal itself.\n\nThe `retry` operator, combined with the `Schedule` module, provides a powerful and declarative way to build this resilience:\n\n1.  **Declarative Resilience**: Instead of writing complex `try/catch` loops with manual delay logic, you declaratively state *how* the pipeline should retry. For example, \"retry 3 times, with an exponential backoff starting at 100ms.\"\n2.  **Separation of Concerns**: Your core pipeline logic remains focused on the \"happy path.\" The retry strategy is a separate, composable concern that you apply to the entire stream.\n3.  **Rich Scheduling Policies**: `Schedule` is incredibly powerful. You can create schedules based on a fixed number of retries, exponential backoff, jitter (to avoid thundering herd problems), or even combinations of these.\n4.  **Prevents Cascading Failures**: By handling temporary issues at the source, you prevent a small, transient glitch from causing a complete failure of your entire application.\n\n---",
    "content": "## Guideline\n\nTo make a data pipeline resilient to transient failures, apply the `.retry(Schedule)` operator to the `Stream`.\n\n---\n\n## Rationale\n\nReal-world systems are unreliable. Network connections drop, APIs return temporary `503` errors, and databases can experience deadlocks. A naive pipeline will fail completely on the first sign of trouble. A resilient pipeline, however, can absorb these transient errors and heal itself.\n\nThe `retry` operator, combined with the `Schedule` module, provides a powerful and declarative way to build this resilience:\n\n1.  **Declarative Resilience**: Instead of writing complex `try/catch` loops with manual delay logic, you declaratively state *how* the pipeline should retry. For example, \"retry 3 times, with an exponential backoff starting at 100ms.\"\n2.  **Separation of Concerns**: Your core pipeline logic remains focused on the \"happy path.\" The retry strategy is a separate, composable concern that you apply to the entire stream.\n3.  **Rich Scheduling Policies**: `Schedule` is incredibly powerful. You can create schedules based on a fixed number of retries, exponential backoff, jitter (to avoid thundering herd problems), or even combinations of these.\n4.  **Prevents Cascading Failures**: By handling temporary issues at the source, you prevent a small, transient glitch from causing a complete failure of your entire application.\n\n---\n\n## Good Example\n\nThis example simulates an API that fails the first two times it's called. The stream processes a list of IDs, and the `retry` operator ensures that the failing operation for `id: 2` is automatically retried until it succeeds.\n\n````typescript\nimport { Effect, Stream, Schedule } from \"effect\";\n\n// A mock function that simulates a flaky API call\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Attempting to process item ${id}...`);\n\n    // Item 2 fails on first attempt but succeeds on retry\n    if (id === 2) {\n      const random = Math.random();\n      if (random < 0.5) {\n        // 50% chance of failure for demonstration\n        yield* Effect.log(`Item ${id} failed, will retry...`);\n        return yield* Effect.fail(new Error(\"API is temporarily down\"));\n      }\n    }\n\n    yield* Effect.log(`‚úÖ Successfully processed item ${id}`);\n    return `Processed item ${id}`;\n  });\n\nconst ids = [1, 2, 3];\n\n// Define a retry policy: 3 attempts with a fixed 100ms delay\nconst retryPolicy = Schedule.recurs(3).pipe(\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Retry on Failure Demo ===\");\n  yield* Effect.log(\n    \"Processing items with retry policy (3 attempts, 100ms delay)\"\n  );\n\n  // Process each item individually with retry\n  const results = yield* Effect.forEach(\n    ids,\n    (id) =>\n      processItem(id).pipe(\n        Effect.retry(retryPolicy),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(\n              `‚ùå Item ${id} failed after all retries: ${error.message}`\n            );\n            return `Failed: item ${id}`;\n          })\n        )\n      ),\n    { concurrency: 1 }\n  );\n\n  yield* Effect.log(\"=== Results ===\");\n  for (let index = 0; index < results.length; index++) {\n  yield* Effect.log(`Item ${ids[index]}: ${results[index]}`);\n}\n\n  yield* Effect.log(\"‚úÖ Stream processing completed\");\n});\n\nEffect.runPromise(program).catch((error) => {\n  Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 2.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Attempting to process item 3...\"\n*/\n\n````\n\n## Anti-Pattern\n\nThe anti-pattern is to either have no retry logic at all, or to write manual, imperative retry loops inside your processing function.\n\n````typescript\nimport { Effect, Stream } from 'effect';\n// ... same mock processItem function ...\n\nconst ids = [1, 2, 3];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // No retry logic. The entire stream will fail when item 2 fails.\n  Stream.mapEffect(processItem, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program).catch((error) => {\n  console.error('Pipeline failed:', error);\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\nPipeline failed: Error: API is temporarily down\n*/\n````\n\nThis \"fail-fast\" approach is brittle. A single, temporary network blip would cause the entire pipeline to terminate, even if subsequent items could have been processed successfully. While manual retry logic inside `processItem` is possible, it pollutes the core logic with concerns about timing and attempt counting, and is far less composable and reusable than a `Schedule`."
  },
  {
    "id": "avoid-long-andthen-chains",
    "title": "Avoid Long Chains of .andThen; Use Generators Instead",
    "description": "Prefer generators over long chains of .andThen.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Define our steps with logging\nconst step1 = (): Effect.Effect<number> =>\n  Effect.succeed(42).pipe(\n    Effect.tap(n => Effect.log(`Step 1: ${n}`))\n  );\n\nconst step2 = (a: number): Effect.Effect<string> =>\n  Effect.succeed(`Result: ${a * 2}`).pipe(\n    Effect.tap(s => Effect.log(`Step 2: ${s}`))\n  );\n\n// Using Effect.gen for better readability\nconst program = Effect.gen(function* () {\n  const a = yield* step1();\n  const b = yield* step2(a);\n  return b;\n});\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \nGenerators keep sequential logic readable and easy to maintain.",
    "antiPattern": "```typescript\nimport { Effect } from \"effect\";\ndeclare const step1: () => Effect.Effect<any>;\ndeclare const step2: (a: any) => Effect.Effect<any>;\n\nstep1().pipe(Effect.flatMap((a) => step2(a))); // Or .andThen\n```\n\nChaining many `.flatMap` or `.andThen` calls leads to deeply nested,\nhard-to-read code.",
    "explanation": "`Effect.gen` provides a flat, linear code structure that is easier to read and\ndebug than deeply nested functional chains.",
    "content": "# Avoid Long Chains of .andThen; Use Generators Instead\n\n## Guideline\n\nFor sequential logic involving more than two steps, prefer `Effect.gen` over\nchaining multiple `.andThen` or `.flatMap` calls.\n\n## Rationale\n\n`Effect.gen` provides a flat, linear code structure that is easier to read and\ndebug than deeply nested functional chains.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define our steps with logging\nconst step1 = (): Effect.Effect<number> =>\n  Effect.succeed(42).pipe(\n    Effect.tap(n => Effect.log(`Step 1: ${n}`))\n  );\n\nconst step2 = (a: number): Effect.Effect<string> =>\n  Effect.succeed(`Result: ${a * 2}`).pipe(\n    Effect.tap(s => Effect.log(`Step 2: ${s}`))\n  );\n\n// Using Effect.gen for better readability\nconst program = Effect.gen(function* () {\n  const a = yield* step1();\n  const b = yield* step2(a);\n  return b;\n});\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \nGenerators keep sequential logic readable and easy to maintain.\n\n## Anti-Pattern\n\n```typescript\nimport { Effect } from \"effect\";\ndeclare const step1: () => Effect.Effect<any>;\ndeclare const step2: (a: any) => Effect.Effect<any>;\n\nstep1().pipe(Effect.flatMap((a) => step2(a))); // Or .andThen\n```\n\nChaining many `.flatMap` or `.andThen` calls leads to deeply nested,\nhard-to-read code."
  },
  {
    "id": "beyond-the-date-type",
    "title": "Beyond the Date Type - Real World Dates, Times, and Timezones",
    "description": "Use the Clock service for testable time-based logic and immutable primitives for timestamps.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "This example shows a function that creates a timestamped event. It depends on the `Clock` service, making it fully testable.\n\n```typescript\nimport { Effect, Clock } from \"effect\";\nimport type * as Types from \"effect/Clock\";\n\ninterface Event {\n  readonly message: string;\n  readonly timestamp: number; // Store as a primitive number (UTC millis)\n}\n\n// This function is pure and testable because it depends on Clock\nconst createEvent = (message: string): Effect.Effect<Event, never, Types.Clock> =>\n  Effect.gen(function* () {\n    const timestamp = yield* Clock.currentTimeMillis;\n    return { message, timestamp };\n  });\n\n// Create and log some events\nconst program = Effect.gen(function* () {\n  const loginEvent = yield* createEvent(\"User logged in\");\n  yield* Effect.log(\"Login event:\", loginEvent);\n\n  const logoutEvent = yield* createEvent(\"User logged out\");\n  yield* Effect.log(\"Logout event:\", logoutEvent);\n});\n\n// Run the program\nconst programWithErrorHandling = program.pipe(\n  Effect.provideService(Clock.Clock, Clock.make()),\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n```\n\n---",
    "antiPattern": "Directly using `Date.now()` or `new Date()` inside your effects. This introduces impurity and makes your logic dependent on the actual system clock, rendering it non-deterministic and difficult to test.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This function is impure and not reliably testable.\nconst createEventUnsafely = (message: string): Effect.Effect<any> =>\n  Effect.sync(() => ({\n    message,\n    timestamp: Date.now(), // Direct call to a system API\n  }));\n\n// How would you test that this function assigns the correct timestamp\n// without manipulating the system clock or using complex mocks?\n```",
    "explanation": "JavaScript's native `Date` object is a common source of bugs. It is mutable, its behavior can be inconsistent across different JavaScript environments (especially with timezones), and its reliance on the system clock makes time-dependent logic difficult to test.\n\nEffect's approach solves these problems:\n-   The **`Clock` service** abstracts away the concept of \"now.\" In production, the `Live` clock uses the system time. In tests, you can provide a `TestClock` that gives you complete, deterministic control over the passage of time.\n-   Using **primitive `number` or `string`** for timestamps ensures immutability and makes your data easy to serialize, store, and transfer.\n\nThis makes your time-based logic pure, predictable, and easy to test.\n\n---",
    "content": "## Guideline\n\nTo handle specific points in time robustly in Effect, follow these principles:\n1.  **Access \"now\" via the `Clock` service** (`Clock.currentTimeMillis`) instead of `Date.now()`.\n2.  **Store and pass timestamps** as immutable primitives: `number` for UTC milliseconds or `string` for ISO 8601 format.\n3.  **Perform calculations locally:** When you need to perform date-specific calculations (e.g., \"get the day of the week\"), create a `new Date(timestamp)` instance inside a pure computation, use it, and then discard it. Never hold onto mutable `Date` objects in your application state.\n\n---\n\n## Rationale\n\nJavaScript's native `Date` object is a common source of bugs. It is mutable, its behavior can be inconsistent across different JavaScript environments (especially with timezones), and its reliance on the system clock makes time-dependent logic difficult to test.\n\nEffect's approach solves these problems:\n-   The **`Clock` service** abstracts away the concept of \"now.\" In production, the `Live` clock uses the system time. In tests, you can provide a `TestClock` that gives you complete, deterministic control over the passage of time.\n-   Using **primitive `number` or `string`** for timestamps ensures immutability and makes your data easy to serialize, store, and transfer.\n\nThis makes your time-based logic pure, predictable, and easy to test.\n\n---\n\n## Good Example\n\nThis example shows a function that creates a timestamped event. It depends on the `Clock` service, making it fully testable.\n\n```typescript\nimport { Effect, Clock } from \"effect\";\nimport type * as Types from \"effect/Clock\";\n\ninterface Event {\n  readonly message: string;\n  readonly timestamp: number; // Store as a primitive number (UTC millis)\n}\n\n// This function is pure and testable because it depends on Clock\nconst createEvent = (message: string): Effect.Effect<Event, never, Types.Clock> =>\n  Effect.gen(function* () {\n    const timestamp = yield* Clock.currentTimeMillis;\n    return { message, timestamp };\n  });\n\n// Create and log some events\nconst program = Effect.gen(function* () {\n  const loginEvent = yield* createEvent(\"User logged in\");\n  yield* Effect.log(\"Login event:\", loginEvent);\n\n  const logoutEvent = yield* createEvent(\"User logged out\");\n  yield* Effect.log(\"Logout event:\", logoutEvent);\n});\n\n// Run the program\nconst programWithErrorHandling = program.pipe(\n  Effect.provideService(Clock.Clock, Clock.make()),\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n```\n\n---\n\n## Anti-Pattern\n\nDirectly using `Date.now()` or `new Date()` inside your effects. This introduces impurity and makes your logic dependent on the actual system clock, rendering it non-deterministic and difficult to test.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This function is impure and not reliably testable.\nconst createEventUnsafely = (message: string): Effect.Effect<any> =>\n  Effect.sync(() => ({\n    message,\n    timestamp: Date.now(), // Direct call to a system API\n  }));\n\n// How would you test that this function assigns the correct timestamp\n// without manipulating the system clock or using complex mocks?\n```"
  },
  {
    "id": "build-a-basic-http-server",
    "title": "Build a Basic HTTP Server",
    "description": "Use a managed Runtime created from a Layer to handle requests in a Node.js HTTP server.",
    "skillLevel": "advanced",
    "useCases": [
      "making-http-requests"
    ],
    "example": "This example creates a simple server with a `Greeter` service. The server starts, creates a runtime containing the `Greeter`, and then uses that runtime to handle requests.\n\n```typescript\nimport { HttpServer, HttpServerResponse } from \"@effect/platform\"\nimport { NodeHttpServer } from \"@effect/platform-node\"\nimport { Duration, Effect, Fiber, Layer } from \"effect\"\nimport { createServer } from \"node:http\"\n\n// Create a server layer using Node's built-in HTTP server\nconst ServerLive = NodeHttpServer.layer(() => createServer(), { port: 3001 })\n\n// Define your HTTP app (here responding \"Hello World\" to every request)\nconst app = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Received HTTP request\")\n  return yield* HttpServerResponse.text(\"Hello World\")\n})\n\nconst serverLayer = HttpServer.serve(app).pipe(Layer.provide(ServerLive));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Server starting on http://localhost:3001\")\n  const fiber = yield* Layer.launch(serverLayer).pipe(Effect.fork)\n  yield* Effect.sleep(Duration.seconds(2))\n  yield* Fiber.interrupt(fiber)\n  yield* Effect.logInfo(\"Server shutdown complete\")\n})\n\nEffect.runPromise(program as unknown as Effect.Effect<void, unknown, never>);\n```\n\n---",
    "antiPattern": "Creating a new runtime or rebuilding layers for every single incoming request. This is extremely inefficient and defeats the purpose of Effect's `Layer` system.\n\n```typescript\nimport * as http from \"http\";\nimport { Effect, Layer } from \"effect\";\nimport { GreeterLive } from \"./somewhere\";\n\n// ‚ùå WRONG: This rebuilds the GreeterLive layer on every request.\nconst server = http.createServer((_req, res) => {\n  const requestEffect = Effect.succeed(\"Hello!\").pipe(\n    Effect.provide(GreeterLive), // Providing the layer here is inefficient\n  );\n  Effect.runPromise(requestEffect).then((msg) => res.end(msg));\n});\n```",
    "explanation": "This pattern demonstrates the complete lifecycle of a long-running Effect application.\n1.  **Setup Phase:** You define all your application's dependencies (database connections, clients, config) in `Layer`s and compose them into a single `AppLayer`.\n2.  **Runtime Creation:** You use `Layer.toRuntime(AppLayer)` to create a highly-optimized `Runtime` object. This is done *once* when the server starts.\n3.  **Request Handling:** For each incoming request, you create an `Effect` that describes the work to be done (e.g., parse request, call services, create response).\n4.  **Execution:** You use the `Runtime` you created in the setup phase to execute the request-handling `Effect` using `Runtime.runPromise`.\n\nThis architecture ensures that your request handling logic is fully testable, benefits from structured concurrency, and is completely decoupled from the server's setup and infrastructure.\n\n---",
    "content": "## Guideline\n\nTo build an HTTP server, create a main `AppLayer` that provides all your application's services. Compile this layer into a managed `Runtime` at startup. Use this runtime to execute an `Effect` for each incoming HTTP request, ensuring all logic is handled within the Effect system.\n\n---\n\n## Rationale\n\nThis pattern demonstrates the complete lifecycle of a long-running Effect application.\n1.  **Setup Phase:** You define all your application's dependencies (database connections, clients, config) in `Layer`s and compose them into a single `AppLayer`.\n2.  **Runtime Creation:** You use `Layer.toRuntime(AppLayer)` to create a highly-optimized `Runtime` object. This is done *once* when the server starts.\n3.  **Request Handling:** For each incoming request, you create an `Effect` that describes the work to be done (e.g., parse request, call services, create response).\n4.  **Execution:** You use the `Runtime` you created in the setup phase to execute the request-handling `Effect` using `Runtime.runPromise`.\n\nThis architecture ensures that your request handling logic is fully testable, benefits from structured concurrency, and is completely decoupled from the server's setup and infrastructure.\n\n---\n\n## Good Example\n\nThis example creates a simple server with a `Greeter` service. The server starts, creates a runtime containing the `Greeter`, and then uses that runtime to handle requests.\n\n```typescript\nimport { HttpServer, HttpServerResponse } from \"@effect/platform\"\nimport { NodeHttpServer } from \"@effect/platform-node\"\nimport { Duration, Effect, Fiber, Layer } from \"effect\"\nimport { createServer } from \"node:http\"\n\n// Create a server layer using Node's built-in HTTP server\nconst ServerLive = NodeHttpServer.layer(() => createServer(), { port: 3001 })\n\n// Define your HTTP app (here responding \"Hello World\" to every request)\nconst app = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Received HTTP request\")\n  return yield* HttpServerResponse.text(\"Hello World\")\n})\n\nconst serverLayer = HttpServer.serve(app).pipe(Layer.provide(ServerLive));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Server starting on http://localhost:3001\")\n  const fiber = yield* Layer.launch(serverLayer).pipe(Effect.fork)\n  yield* Effect.sleep(Duration.seconds(2))\n  yield* Fiber.interrupt(fiber)\n  yield* Effect.logInfo(\"Server shutdown complete\")\n})\n\nEffect.runPromise(program as unknown as Effect.Effect<void, unknown, never>);\n```\n\n---\n\n## Anti-Pattern\n\nCreating a new runtime or rebuilding layers for every single incoming request. This is extremely inefficient and defeats the purpose of Effect's `Layer` system.\n\n```typescript\nimport * as http from \"http\";\nimport { Effect, Layer } from \"effect\";\nimport { GreeterLive } from \"./somewhere\";\n\n// ‚ùå WRONG: This rebuilds the GreeterLive layer on every request.\nconst server = http.createServer((_req, res) => {\n  const requestEffect = Effect.succeed(\"Hello!\").pipe(\n    Effect.provide(GreeterLive), // Providing the layer here is inefficient\n  );\n  Effect.runPromise(requestEffect).then((msg) => res.end(msg));\n});\n```"
  },
  {
    "id": "combinator-flatmap",
    "title": "Chaining Computations with flatMap",
    "description": "Use flatMap to sequence computations, flattening nested structures and preserving error and context handling.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Chain two effectful computations\nconst effect = Effect.succeed(2).pipe(\n  Effect.flatMap((n) => Effect.succeed(n * 10))\n); // Effect<number>\n\n// Option: Chain two optional computations\nconst option = Option.some(2).pipe(\n  Option.flatMap((n) => Option.some(n * 10))\n); // Option<number>\n\n// Either: Chain two computations that may fail\nconst either = Either.right(2).pipe(\n  Either.flatMap((n) => Either.right(n * 10))\n); // Either<never, number>\n\n// Stream: Chain streams (flattening)\nconst stream = Stream.fromIterable([1, 2]).pipe(\n  Stream.flatMap((n) => Stream.fromIterable([n, n * 10]))\n); // Stream<number>\n```\n\n**Explanation:**  \n`flatMap` lets you build pipelines where each step can depend on the result of the previous one, and the structure is always flattened‚Äîno `Option<Option<A>>` or `Effect<Effect<A>>`.",
    "antiPattern": "Manually unwrapping the value (e.g., with `.getOrElse`, `.unsafeRunSync`, etc.), then creating a new effect/option/either/stream.  \nThis breaks composability, loses error/context handling, and leads to deeply nested or unsafe code.",
    "explanation": "`flatMap` is the key to sequencing dependent steps in functional programming.  \nIt allows you to express workflows where each step may fail, be optional, or produce multiple results, and ensures that errors and context are handled automatically.",
    "content": "# Chaining Computations with `flatMap`\n\n## Guideline\n\nUse the `flatMap` combinator to chain together computations where each step may itself return an `Effect`, `Stream`, `Option`, or `Either`.  \n`flatMap` ensures that the result is always \"flattened\"‚Äîyou never get nested types.\n\n## Rationale\n\n`flatMap` is the key to sequencing dependent steps in functional programming.  \nIt allows you to express workflows where each step may fail, be optional, or produce multiple results, and ensures that errors and context are handled automatically.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Chain two effectful computations\nconst effect = Effect.succeed(2).pipe(\n  Effect.flatMap((n) => Effect.succeed(n * 10))\n); // Effect<number>\n\n// Option: Chain two optional computations\nconst option = Option.some(2).pipe(\n  Option.flatMap((n) => Option.some(n * 10))\n); // Option<number>\n\n// Either: Chain two computations that may fail\nconst either = Either.right(2).pipe(\n  Either.flatMap((n) => Either.right(n * 10))\n); // Either<never, number>\n\n// Stream: Chain streams (flattening)\nconst stream = Stream.fromIterable([1, 2]).pipe(\n  Stream.flatMap((n) => Stream.fromIterable([n, n * 10]))\n); // Stream<number>\n```\n\n**Explanation:**  \n`flatMap` lets you build pipelines where each step can depend on the result of the previous one, and the structure is always flattened‚Äîno `Option<Option<A>>` or `Effect<Effect<A>>`.\n\n## Anti-Pattern\n\nManually unwrapping the value (e.g., with `.getOrElse`, `.unsafeRunSync`, etc.), then creating a new effect/option/either/stream.  \nThis breaks composability, loses error/context handling, and leads to deeply nested or unsafe code."
  },
  {
    "id": "pattern-option-either-checks",
    "title": "Checking Option and Either Cases",
    "description": "Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe conditional logic.",
    "skillLevel": "beginner",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Option, Either } from \"effect\";\n\n// Option: Check if value is Some or None\nconst option = Option.some(42);\n\nif (Option.isSome(option)) {\n  // option.value is available here\n  console.log(\"We have a value:\", option.value);\n} else if (Option.isNone(option)) {\n  console.log(\"No value present\");\n}\n\n// Either: Check if value is Right or Left\nconst either = Either.left(\"error\");\n\nif (Either.isRight(either)) {\n  // either.right is available here\n  console.log(\"Success:\", either.right);\n} else if (Either.isLeft(either)) {\n  // either.left is available here\n  console.log(\"Failure:\", either.left);\n}\n\n// Filtering a collection of Options\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst presentValues = options.filter(Option.isSome).map((o) => o.value); // [1, 3]\n```\n\n**Explanation:**  \n- `Option.isSome` and `Option.isNone` let you check for presence or absence.\n- `Either.isRight` and `Either.isLeft` let you check for success or failure.\n- These are especially useful for filtering or quick conditional logic.",
    "antiPattern": "Manually checking internal tags or properties (e.g., `option._tag === \"Some\"`), or using unsafe type assertions, which is less safe and less readable than using the provided predicates.",
    "explanation": "These predicates provide a concise, type-safe way to check which case you have, without resorting to manual property checks or unsafe type assertions.",
    "content": "# Checking Option and Either Cases\n\n## Guideline\n\nUse the `isSome`, `isNone`, `isLeft`, and `isRight` predicates to check the case of an `Option` or `Either` for simple, type-safe branching.  \nThese are useful when you need to perform quick checks or filter collections based on presence or success.\n\n## Rationale\n\nThese predicates provide a concise, type-safe way to check which case you have, without resorting to manual property checks or unsafe type assertions.\n\n## Good Example\n\n```typescript\nimport { Option, Either } from \"effect\";\n\n// Option: Check if value is Some or None\nconst option = Option.some(42);\n\nif (Option.isSome(option)) {\n  // option.value is available here\n  console.log(\"We have a value:\", option.value);\n} else if (Option.isNone(option)) {\n  console.log(\"No value present\");\n}\n\n// Either: Check if value is Right or Left\nconst either = Either.left(\"error\");\n\nif (Either.isRight(either)) {\n  // either.right is available here\n  console.log(\"Success:\", either.right);\n} else if (Either.isLeft(either)) {\n  // either.left is available here\n  console.log(\"Failure:\", either.left);\n}\n\n// Filtering a collection of Options\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst presentValues = options.filter(Option.isSome).map((o) => o.value); // [1, 3]\n```\n\n**Explanation:**  \n- `Option.isSome` and `Option.isNone` let you check for presence or absence.\n- `Either.isRight` and `Either.isLeft` let you check for success or failure.\n- These are especially useful for filtering or quick conditional logic.\n\n## Anti-Pattern\n\nManually checking internal tags or properties (e.g., `option._tag === \"Some\"`), or using unsafe type assertions, which is less safe and less readable than using the provided predicates."
  },
  {
    "id": "stream-collect-results",
    "title": "Collect All Results into a List",
    "description": "Use Stream.runCollect to execute a stream and collect all its emitted values into a Chunk.",
    "skillLevel": "beginner",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example creates a stream of numbers, filters for only the even ones, transforms them into strings, and then uses `runCollect` to gather the final results into a `Chunk`.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\nconst program = Stream.range(1, 10).pipe(\n  // Find all the even numbers\n  Stream.filter((n) => n % 2 === 0),\n  // Transform them into strings\n  Stream.map((n) => `Even number: ${n}`),\n  // Run the stream and collect the results\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(`Collected results: ${JSON.stringify(Chunk.toArray(results))}`);\n  return results;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\nCollected results: [\n  'Even number: 2',\n  'Even number: 4',\n  'Even number: 6',\n  'Even number: 8',\n  'Even number: 10'\n]\n*/\n```",
    "antiPattern": "The anti-pattern is using `Stream.runCollect` on a stream that produces an unbounded or extremely large number of items. This will inevitably lead to an out-of-memory error.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// An infinite stream of numbers\nconst infiniteStream = Stream.range(1, Infinity);\n\nconst program = infiniteStream.pipe(\n  // This will run forever, attempting to buffer an infinite number of items.\n  Stream.runCollect\n);\n\n// This program will never finish and will eventually crash the process\n// by consuming all available memory.\n// Effect.runPromise(program);\nconsole.log(\n  'This code is commented out because it would cause an out-of-memory crash.'\n);\n```\n\nThis is a critical mistake because `runCollect` must hold every single item emitted by the stream in memory simultaneously. For pipelines that process huge files, infinite data sources, or are designed to run forever, `runCollect` is the wrong tool. In those cases, you should use a sink like `Stream.runDrain`, which processes items without collecting them.",
    "explanation": "A \"sink\" is a terminal operator that consumes a stream and produces a final `Effect`. `Stream.runCollect` is the most fundamental sink. It provides the bridge from the lazy, pull-based world of `Stream` back to the familiar world of a single `Effect` that resolves with a standard data structure.\n\nUsing `Stream.runCollect` is essential when:\n\n1.  **You Need the Final Result**: The goal of your pipeline is to produce a complete list of transformed items that you need to use in a subsequent step (e.g., to return as a single JSON array from an API).\n2.  **Simplicity is Key**: It's the most straightforward way to \"run\" a stream and see its output. It declaratively states your intent: \"execute this entire pipeline and give me all the results.\"\n3.  **The Dataset is Bounded**: It's designed for streams where the total number of items is known to be finite and small enough to fit comfortably in memory.\n\nThe result of `Stream.runCollect` is an `Effect` that, when executed, yields a `Chunk` containing all the items emitted by the stream.\n\n---",
    "content": "## Guideline\n\nTo execute a stream and collect all of its emitted values into a single, in-memory list, use the `Stream.runCollect` sink.\n\n---\n\n## Rationale\n\nA \"sink\" is a terminal operator that consumes a stream and produces a final `Effect`. `Stream.runCollect` is the most fundamental sink. It provides the bridge from the lazy, pull-based world of `Stream` back to the familiar world of a single `Effect` that resolves with a standard data structure.\n\nUsing `Stream.runCollect` is essential when:\n\n1.  **You Need the Final Result**: The goal of your pipeline is to produce a complete list of transformed items that you need to use in a subsequent step (e.g., to return as a single JSON array from an API).\n2.  **Simplicity is Key**: It's the most straightforward way to \"run\" a stream and see its output. It declaratively states your intent: \"execute this entire pipeline and give me all the results.\"\n3.  **The Dataset is Bounded**: It's designed for streams where the total number of items is known to be finite and small enough to fit comfortably in memory.\n\nThe result of `Stream.runCollect` is an `Effect` that, when executed, yields a `Chunk` containing all the items emitted by the stream.\n\n---\n\n## Good Example\n\nThis example creates a stream of numbers, filters for only the even ones, transforms them into strings, and then uses `runCollect` to gather the final results into a `Chunk`.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\nconst program = Stream.range(1, 10).pipe(\n  // Find all the even numbers\n  Stream.filter((n) => n % 2 === 0),\n  // Transform them into strings\n  Stream.map((n) => `Even number: ${n}`),\n  // Run the stream and collect the results\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(`Collected results: ${JSON.stringify(Chunk.toArray(results))}`);\n  return results;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\nCollected results: [\n  'Even number: 2',\n  'Even number: 4',\n  'Even number: 6',\n  'Even number: 8',\n  'Even number: 10'\n]\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is using `Stream.runCollect` on a stream that produces an unbounded or extremely large number of items. This will inevitably lead to an out-of-memory error.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// An infinite stream of numbers\nconst infiniteStream = Stream.range(1, Infinity);\n\nconst program = infiniteStream.pipe(\n  // This will run forever, attempting to buffer an infinite number of items.\n  Stream.runCollect\n);\n\n// This program will never finish and will eventually crash the process\n// by consuming all available memory.\n// Effect.runPromise(program);\nconsole.log(\n  'This code is commented out because it would cause an out-of-memory crash.'\n);\n```\n\nThis is a critical mistake because `runCollect` must hold every single item emitted by the stream in memory simultaneously. For pipelines that process huge files, infinite data sources, or are designed to run forever, `runCollect` is the wrong tool. In those cases, you should use a sink like `Stream.runDrain`, which processes items without collecting them."
  },
  {
    "id": "combinator-zip",
    "title": "Combining Values with zip",
    "description": "Use zip to run two computations and combine their results into a tuple, preserving error and context handling.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Combine two effects and get both results\nconst effectA = Effect.succeed(1);\nconst effectB = Effect.succeed(\"hello\");\nconst zippedEffect = effectA.pipe(\n  Effect.zip(effectB)\n); // Effect<[number, string]>\n\n// Option: Combine two options, only Some if both are Some\nconst optionA = Option.some(1);\nconst optionB = Option.some(\"hello\");\nconst zippedOption = Option.all([optionA, optionB]); // Option<[number, string]>\n\n// Either: Combine two eithers, only Right if both are Right\nconst eitherA = Either.right(1);\nconst eitherB = Either.right(\"hello\");\nconst zippedEither = Either.all([eitherA, eitherB]); // Either<never, [number, string]>\n\n// Stream: Pair up values from two streams\nconst streamA = Stream.fromIterable([1, 2, 3]);\nconst streamB = Stream.fromIterable([\"a\", \"b\", \"c\"]);\nconst zippedStream = streamA.pipe(\n  Stream.zip(streamB)\n); // Stream<[number, string]>\n```\n\n**Explanation:**  \n`zip` runs both computations and pairs their results.  \nIf either computation fails (or is None/Left/empty), the result is a failure (or None/Left/empty).",
    "antiPattern": "Manually running two computations, extracting their results, and pairing them outside the combinator world.  \nThis breaks composability, loses error/context handling, and can lead to subtle bugs.",
    "explanation": "`zip` lets you compose computations that are independent but whose results you want to use together.  \nIt preserves error handling and context, and keeps your code declarative and type-safe.",
    "content": "# Combining Values with `zip`\n\n## Guideline\n\nUse the `zip` combinator to combine two computations, pairing their results together.  \nThis works for `Effect`, `Stream`, `Option`, and `Either`, and is useful when you want to run two computations and work with both results.\n\n## Rationale\n\n`zip` lets you compose computations that are independent but whose results you want to use together.  \nIt preserves error handling and context, and keeps your code declarative and type-safe.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Combine two effects and get both results\nconst effectA = Effect.succeed(1);\nconst effectB = Effect.succeed(\"hello\");\nconst zippedEffect = effectA.pipe(\n  Effect.zip(effectB)\n); // Effect<[number, string]>\n\n// Option: Combine two options, only Some if both are Some\nconst optionA = Option.some(1);\nconst optionB = Option.some(\"hello\");\nconst zippedOption = Option.all([optionA, optionB]); // Option<[number, string]>\n\n// Either: Combine two eithers, only Right if both are Right\nconst eitherA = Either.right(1);\nconst eitherB = Either.right(\"hello\");\nconst zippedEither = Either.all([eitherA, eitherB]); // Either<never, [number, string]>\n\n// Stream: Pair up values from two streams\nconst streamA = Stream.fromIterable([1, 2, 3]);\nconst streamB = Stream.fromIterable([\"a\", \"b\", \"c\"]);\nconst zippedStream = streamA.pipe(\n  Stream.zip(streamB)\n); // Stream<[number, string]>\n```\n\n**Explanation:**  \n`zip` runs both computations and pairs their results.  \nIf either computation fails (or is None/Left/empty), the result is a failure (or None/Left/empty).\n\n## Anti-Pattern\n\nManually running two computations, extracting their results, and pairing them outside the combinator world.  \nThis breaks composability, loses error/context handling, and can lead to subtle bugs."
  },
  {
    "id": "data-struct",
    "title": "Comparing Data by Value with Data.struct",
    "description": "Use Data.struct to define objects whose equality is based on their contents, enabling safe and predictable comparisons.",
    "skillLevel": "beginner",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal objects\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(user1, user2); // true\n\n// Use in a HashSet or as keys in a Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true\n```\n\n**Explanation:**  \n- `Data.struct` creates immutable objects with value-based equality.\n- Use for domain entities, value objects, and when storing objects in sets or as map keys.\n- Avoids bugs from reference-based comparison.",
    "antiPattern": "Using plain JavaScript objects for value-based logic, which compares by reference and can lead to incorrect equality checks and collection behavior.",
    "explanation": "JavaScript objects are compared by reference, which can lead to subtle bugs when modeling value objects.  \n`Data.struct` ensures that two objects with the same contents are considered equal, supporting value-based logic and collections.",
    "content": "# Comparing Data by Value with `Data.struct`\n\n## Guideline\n\nUse `Data.struct` to create immutable, structurally-typed objects whose equality is based on their contents, not their reference.  \nThis enables safe, predictable comparisons and is ideal for domain modeling.\n\n## Rationale\n\nJavaScript objects are compared by reference, which can lead to subtle bugs when modeling value objects.  \n`Data.struct` ensures that two objects with the same contents are considered equal, supporting value-based logic and collections.\n\n## Good Example\n\n```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal objects\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(user1, user2); // true\n\n// Use in a HashSet or as keys in a Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true\n```\n\n**Explanation:**  \n- `Data.struct` creates immutable objects with value-based equality.\n- Use for domain entities, value objects, and when storing objects in sets or as map keys.\n- Avoids bugs from reference-based comparison.\n\n## Anti-Pattern\n\nUsing plain JavaScript objects for value-based logic, which compares by reference and can lead to incorrect equality checks and collection behavior."
  },
  {
    "id": "comparing-data-by-value-with-structural-equality",
    "title": "Comparing Data by Value with Structural Equality",
    "description": "Use Data.struct or implement the Equal interface for value-based comparison of objects and classes.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "We define two points using `Data.struct`. Even though `p1` and `p2` are different instances in memory, `Equal.equals` correctly reports them as equal because their contents match.\n\n```typescript\nimport { Data, Equal, Effect } from \"effect\";\n\n// Define a Point type with structural equality\ninterface Point {\n  readonly _tag: \"Point\";\n  readonly x: number;\n  readonly y: number;\n}\n\nconst Point = Data.tagged<Point>(\"Point\");\n\n// Create a program to demonstrate structural equality\nconst program = Effect.gen(function* () {\n  const p1 = Point({ x: 1, y: 2 });\n  const p2 = Point({ x: 1, y: 2 });\n  const p3 = Point({ x: 3, y: 4 });\n\n  // Standard reference equality fails\n  yield* Effect.log(\"Comparing points with reference equality (===):\");\n  yield* Effect.log(`p1 === p2: ${p1 === p2}`);\n\n  // Structural equality works as expected\n  yield* Effect.log(\"\\nComparing points with structural equality:\");\n  yield* Effect.log(`p1 equals p2: ${Equal.equals(p1, p2)}`);\n  yield* Effect.log(`p1 equals p3: ${Equal.equals(p1, p3)}`);\n\n  // Show the actual points\n  yield* Effect.log(\"\\nPoint values:\");\n  yield* Effect.log(`p1: ${JSON.stringify(p1)}`);\n  yield* Effect.log(`p2: ${JSON.stringify(p2)}`);\n  yield* Effect.log(`p3: ${JSON.stringify(p3)}`);\n});\n\n// Run the program\nEffect.runPromise(program);\n```\n\n---",
    "antiPattern": "Relying on `===` for object or array comparison. This will lead to bugs when you expect two objects with the same values to be treated as equal, especially when working with data in collections, `Ref`s, or `Effect`'s success values.\n\n```typescript\n// ‚ùå WRONG: This will not behave as expected.\nconst user1 = { id: 1, name: \"Paul\" };\nconst user2 = { id: 1, name: \"Paul\" };\n\nif (user1 === user2) {\n  // This code block will never be reached.\n  console.log(\"Users are the same.\");\n}\n\n// Another common pitfall\nconst selectedUsers = [user1];\n// This check will fail, even though a user with id 1 is in the array.\nif (selectedUsers.includes({ id: 1, name: \"Paul\" })) {\n  // ...\n}\n```",
    "explanation": "In JavaScript, comparing two non-primitive values with `===` checks for *referential equality*. It only returns `true` if they are the exact same instance in memory. This means two objects with identical contents are not considered equal, which is a common source of bugs.\n\n```typescript\n{ a: 1 } === { a: 1 } // false!\n```\n\nEffect solves this with **structural equality**. All of Effect's built-in data structures (`Option`, `Either`, `Chunk`, etc.) can be compared by their structure and values. By using helpers like `Data.struct`, you can easily give your own data structures this same powerful and predictable behavior.\n\n---",
    "content": "## Guideline\n\nTo compare objects or classes by their contents rather than by their memory reference, use one of two methods:\n1.  **For plain data objects:** Define them with `Data.struct`.\n2.  **For classes:** Extend `Data.Class` or implement the `Equal.Equal` interface.\n\nThen, compare instances using the `Equal.equals(a, b)` function.\n\n---\n\n## Rationale\n\nIn JavaScript, comparing two non-primitive values with `===` checks for *referential equality*. It only returns `true` if they are the exact same instance in memory. This means two objects with identical contents are not considered equal, which is a common source of bugs.\n\n```typescript\n{ a: 1 } === { a: 1 } // false!\n```\n\nEffect solves this with **structural equality**. All of Effect's built-in data structures (`Option`, `Either`, `Chunk`, etc.) can be compared by their structure and values. By using helpers like `Data.struct`, you can easily give your own data structures this same powerful and predictable behavior.\n\n---\n\n## Good Example\n\nWe define two points using `Data.struct`. Even though `p1` and `p2` are different instances in memory, `Equal.equals` correctly reports them as equal because their contents match.\n\n```typescript\nimport { Data, Equal, Effect } from \"effect\";\n\n// Define a Point type with structural equality\ninterface Point {\n  readonly _tag: \"Point\";\n  readonly x: number;\n  readonly y: number;\n}\n\nconst Point = Data.tagged<Point>(\"Point\");\n\n// Create a program to demonstrate structural equality\nconst program = Effect.gen(function* () {\n  const p1 = Point({ x: 1, y: 2 });\n  const p2 = Point({ x: 1, y: 2 });\n  const p3 = Point({ x: 3, y: 4 });\n\n  // Standard reference equality fails\n  yield* Effect.log(\"Comparing points with reference equality (===):\");\n  yield* Effect.log(`p1 === p2: ${p1 === p2}`);\n\n  // Structural equality works as expected\n  yield* Effect.log(\"\\nComparing points with structural equality:\");\n  yield* Effect.log(`p1 equals p2: ${Equal.equals(p1, p2)}`);\n  yield* Effect.log(`p1 equals p3: ${Equal.equals(p1, p3)}`);\n\n  // Show the actual points\n  yield* Effect.log(\"\\nPoint values:\");\n  yield* Effect.log(`p1: ${JSON.stringify(p1)}`);\n  yield* Effect.log(`p2: ${JSON.stringify(p2)}`);\n  yield* Effect.log(`p3: ${JSON.stringify(p3)}`);\n});\n\n// Run the program\nEffect.runPromise(program);\n```\n\n---\n\n## Anti-Pattern\n\nRelying on `===` for object or array comparison. This will lead to bugs when you expect two objects with the same values to be treated as equal, especially when working with data in collections, `Ref`s, or `Effect`'s success values.\n\n```typescript\n// ‚ùå WRONG: This will not behave as expected.\nconst user1 = { id: 1, name: \"Paul\" };\nconst user2 = { id: 1, name: \"Paul\" };\n\nif (user1 === user2) {\n  // This code block will never be reached.\n  console.log(\"Users are the same.\");\n}\n\n// Another common pitfall\nconst selectedUsers = [user1];\n// This check will fail, even though a user with id 1 is in the array.\nif (selectedUsers.includes({ id: 1, name: \"Paul\" })) {\n  // ...\n}\n```"
  },
  {
    "id": "compose-scoped-layers",
    "title": "Compose Resource Lifecycles with `Layer.merge`",
    "description": "Compose multiple scoped layers using `Layer.merge` or by providing one layer to another.",
    "skillLevel": "intermediate",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Effect, Layer, Console } from \"effect\";\n\n// --- Service 1: Database ---\ninterface DatabaseOps {\n  query: (sql: string) => Effect.Effect<string, never, never>;\n}\n\nclass Database extends Effect.Service<DatabaseOps>()(\n  \"Database\",\n  {\n    sync: () => ({\n      query: (sql: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `db says: ${sql}`)\n    })\n  }\n) {}\n\n// --- Service 2: API Client ---\ninterface ApiClientOps {\n  fetch: (path: string) => Effect.Effect<string, never, never>;\n}\n\nclass ApiClient extends Effect.Service<ApiClientOps>()(\n  \"ApiClient\",\n  {\n    sync: () => ({\n      fetch: (path: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `api says: ${path}`)\n    })\n  }\n) {}\n\n// --- Application Layer ---\n// We merge the two independent layers into one.\nconst AppLayer = Layer.merge(Database.Default, ApiClient.Default);\n\n// This program uses both services, unaware of their implementation details.\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const api = yield* ApiClient;\n\n  const dbResult = yield* db.query(\"SELECT *\");\n  const apiResult = yield* api.fetch(\"/users\");\n\n  yield* Effect.log(dbResult);\n  yield* Effect.log(apiResult);\n});\n\n// Provide the combined layer to the program.\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n/*\nOutput (note the LIFO release order):\nDatabase pool opened\nAPI client session started\ndb says: SELECT *\napi says: /users\nAPI client session ended\nDatabase pool closed\n*/\n```\n\n**Explanation:**\nWe define two completely independent services, `Database` and `ApiClient`, each with its own resource lifecycle. By combining them with `Layer.merge`, we create a single `AppLayer`. When `program` runs, Effect acquires the resources for both layers. When `program` finishes, Effect closes the application's scope, releasing the resources in the reverse order they were acquired (`ApiClient` then `Database`), ensuring a clean and predictable shutdown.",
    "antiPattern": "A manual, imperative startup and shutdown script. This approach is brittle and error-prone. The developer is responsible for maintaining the correct order of initialization and, more importantly, the reverse order for shutdown. This becomes unmanageable as an application grows.\n\n```typescript\n// ANTI-PATTERN: Manual, brittle, and error-prone\nasync function main() {\n  const db = await initDb(); // acquire 1\n  const client = await initApiClient(); // acquire 2\n\n  try {\n    await doWork(db, client); // use\n  } finally {\n    // This order is easy to get wrong!\n    await client.close(); // release 2\n    await db.close(); // release 1\n  }\n}\n```",
    "explanation": "This pattern is the ultimate payoff for defining services with `Layer`. It allows for true modularity. Each service can be defined in its own file, declaring its own resource requirements in its `Live` layer, completely unaware of other services.\n\nWhen you assemble the final application layer, Effect analyzes the dependencies:\n1.  **Acquisition Order:** It ensures resources are acquired in the correct order. For example, a `Logger` layer might be initialized before a `Database` layer that uses it for logging.\n2.  **Release Order:** It guarantees that resources are released in the **exact reverse order** of their acquisition. This is critical for preventing shutdown errors, such as a `UserRepository` trying to log a final message after the `Logger` has already been shut down.\n\nThis automates one of the most complex and error-prone parts of application architecture.",
    "content": "# Compose Resource Lifecycles with `Layer.merge`\n\n## Guideline\n\nCombine multiple resource-managing `Layer`s into a single application layer using functions like `Layer.merge`. The Effect runtime will automatically build a dependency graph, acquire resources in the correct order, and release them in the reverse order.\n\n## Rationale\n\nThis pattern is the ultimate payoff for defining services with `Layer`. It allows for true modularity. Each service can be defined in its own file, declaring its own resource requirements in its `Live` layer, completely unaware of other services.\n\nWhen you assemble the final application layer, Effect analyzes the dependencies:\n1.  **Acquisition Order:** It ensures resources are acquired in the correct order. For example, a `Logger` layer might be initialized before a `Database` layer that uses it for logging.\n2.  **Release Order:** It guarantees that resources are released in the **exact reverse order** of their acquisition. This is critical for preventing shutdown errors, such as a `UserRepository` trying to log a final message after the `Logger` has already been shut down.\n\nThis automates one of the most complex and error-prone parts of application architecture.\n\n## Good Example\n\n```typescript\nimport { Effect, Layer, Console } from \"effect\";\n\n// --- Service 1: Database ---\ninterface DatabaseOps {\n  query: (sql: string) => Effect.Effect<string, never, never>;\n}\n\nclass Database extends Effect.Service<DatabaseOps>()(\n  \"Database\",\n  {\n    sync: () => ({\n      query: (sql: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `db says: ${sql}`)\n    })\n  }\n) {}\n\n// --- Service 2: API Client ---\ninterface ApiClientOps {\n  fetch: (path: string) => Effect.Effect<string, never, never>;\n}\n\nclass ApiClient extends Effect.Service<ApiClientOps>()(\n  \"ApiClient\",\n  {\n    sync: () => ({\n      fetch: (path: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `api says: ${path}`)\n    })\n  }\n) {}\n\n// --- Application Layer ---\n// We merge the two independent layers into one.\nconst AppLayer = Layer.merge(Database.Default, ApiClient.Default);\n\n// This program uses both services, unaware of their implementation details.\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const api = yield* ApiClient;\n\n  const dbResult = yield* db.query(\"SELECT *\");\n  const apiResult = yield* api.fetch(\"/users\");\n\n  yield* Effect.log(dbResult);\n  yield* Effect.log(apiResult);\n});\n\n// Provide the combined layer to the program.\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n/*\nOutput (note the LIFO release order):\nDatabase pool opened\nAPI client session started\ndb says: SELECT *\napi says: /users\nAPI client session ended\nDatabase pool closed\n*/\n```\n\n**Explanation:**\nWe define two completely independent services, `Database` and `ApiClient`, each with its own resource lifecycle. By combining them with `Layer.merge`, we create a single `AppLayer`. When `program` runs, Effect acquires the resources for both layers. When `program` finishes, Effect closes the application's scope, releasing the resources in the reverse order they were acquired (`ApiClient` then `Database`), ensuring a clean and predictable shutdown.\n\n## Anti-Pattern\n\nA manual, imperative startup and shutdown script. This approach is brittle and error-prone. The developer is responsible for maintaining the correct order of initialization and, more importantly, the reverse order for shutdown. This becomes unmanageable as an application grows.\n\n```typescript\n// ANTI-PATTERN: Manual, brittle, and error-prone\nasync function main() {\n  const db = await initDb(); // acquire 1\n  const client = await initApiClient(); // acquire 2\n\n  try {\n    await doWork(db, client); // use\n  } finally {\n    // This order is easy to get wrong!\n    await client.close(); // release 2\n    await db.close(); // release 1\n  }\n}\n```"
  },
  {
    "id": "combinator-conditional",
    "title": "Conditional Branching with if, when, and cond",
    "description": "Use combinators such as if, when, and cond to branch computations based on runtime conditions, without imperative if statements.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Branch based on a condition\nconst effect = Effect.if(true, {\n  onTrue: () => Effect.succeed(\"yes\"),\n  onFalse: () => Effect.succeed(\"no\")\n}); // Effect<string>\n\n// Option: Conditionally create an Option\nconst option = true ? Option.some(\"yes\") : Option.none(); // Option<string> (Some(\"yes\"))\n\n// Either: Conditionally create an Either\nconst either = true\n  ? Either.right(\"yes\")\n  : Either.left(\"error\"); // Either<string, string> (Right(\"yes\"))\n\n// Stream: Conditionally emit a stream\nconst stream = false\n  ? Stream.fromIterable([1, 2])\n  : Stream.empty; // Stream<number> (empty)\n```\n\n**Explanation:**  \nThese combinators let you branch your computation based on a boolean or predicate, without leaving the world of composable, type-safe code.  \nYou can also use `when` to run an effect only if a condition is true, or `unless` to run it only if a condition is false.",
    "antiPattern": "Using imperative `if` statements to decide which effect, option, either, or stream to return, breaking composability and making error/context handling less predictable.",
    "explanation": "Declarative branching keeps your code composable, testable, and easy to reason about.  \nIt also ensures that error handling and context propagation are preserved, and that your code remains consistent across different Effect types.",
    "content": "# Conditional Branching with `if`, `when`, and `cond`\n\n## Guideline\n\nUse combinators like `if`, `when`, and `cond` to express conditional logic in a declarative, composable way.  \nThese combinators allow you to branch computations based on runtime conditions, without resorting to imperative `if` statements.\n\n## Rationale\n\nDeclarative branching keeps your code composable, testable, and easy to reason about.  \nIt also ensures that error handling and context propagation are preserved, and that your code remains consistent across different Effect types.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Branch based on a condition\nconst effect = Effect.if(true, {\n  onTrue: () => Effect.succeed(\"yes\"),\n  onFalse: () => Effect.succeed(\"no\")\n}); // Effect<string>\n\n// Option: Conditionally create an Option\nconst option = true ? Option.some(\"yes\") : Option.none(); // Option<string> (Some(\"yes\"))\n\n// Either: Conditionally create an Either\nconst either = true\n  ? Either.right(\"yes\")\n  : Either.left(\"error\"); // Either<string, string> (Right(\"yes\"))\n\n// Stream: Conditionally emit a stream\nconst stream = false\n  ? Stream.fromIterable([1, 2])\n  : Stream.empty; // Stream<number> (empty)\n```\n\n**Explanation:**  \nThese combinators let you branch your computation based on a boolean or predicate, without leaving the world of composable, type-safe code.  \nYou can also use `when` to run an effect only if a condition is true, or `unless` to run it only if a condition is false.\n\n## Anti-Pattern\n\nUsing imperative `if` statements to decide which effect, option, either, or stream to return, breaking composability and making error/context handling less predictable."
  },
  {
    "id": "conditionally-branching-workflows",
    "title": "Conditionally Branching Workflows",
    "description": "Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "Here, we use `Effect.filterOrFail` with named predicates to validate a user before proceeding. The intent is crystal clear, and the business rules (`isActive`, `isAdmin`) are reusable.\n\n```typescript\nimport { Effect } from \"effect\";\n\ninterface User {\n  id: number;\n  status: \"active\" | \"inactive\";\n  roles: string[];\n}\n\ntype UserError = \"DbError\" | \"UserIsInactive\" | \"UserIsNotAdmin\";\n\nconst findUser = (id: number): Effect.Effect<User, \"DbError\"> =>\n  Effect.succeed({ id, status: \"active\", roles: [\"admin\"] });\n\n// Reusable, testable predicates that document business rules.\nconst isActive = (user: User): boolean =>\n  user.status === \"active\";\n\nconst isAdmin = (user: User): boolean =>\n  user.roles.includes(\"admin\");\n\nconst program = (id: number): Effect.Effect<string, UserError> =>\n  findUser(id).pipe(\n    // Validate user is active using Effect.filterOrFail\n    Effect.filterOrFail(\n      isActive,\n      () => \"UserIsInactive\" as const\n    ),\n    // Validate user is admin using Effect.filterOrFail\n    Effect.filterOrFail(\n      isAdmin,\n      () => \"UserIsNotAdmin\" as const\n    ),\n    // Success case\n    Effect.map((user) => `Welcome, admin user #${user.id}!`)\n  );\n\n// We can then handle the specific failures in a type-safe way.\nconst handled = program(123).pipe(\n  Effect.match({\n    onFailure: (error) => {\n      switch (error) {\n        case \"UserIsNotAdmin\":\n          return \"Access denied: requires admin role.\";\n        case \"UserIsInactive\":\n          return \"Access denied: user is not active.\";\n        case \"DbError\":\n          return \"Error: could not find user.\";\n        default:\n          return `Unknown error: ${error}`;\n      }\n    },\n    onSuccess: (result) => result\n  })\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* handled;\n  yield* Effect.log(result);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---",
    "antiPattern": "Using `Effect.flatMap` with a manual `if` statement and forgetting to handle the `else` case. This is a common mistake that leads to an inferred type of `Effect<void, ...>`, which can cause confusing type errors downstream because the success value is lost.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { findUser, isAdmin } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: The `else` case is missing.\nconst program = (id: number) =>\n  findUser(id).pipe(\n    Effect.flatMap((user) => {\n      if (isAdmin(user)) {\n        // This returns Effect<User>, but what happens if the user is not an admin?\n        return Effect.succeed(user);\n      }\n      // Because there's no `else` branch, TypeScript infers that this\n      // block can also implicitly return `void`.\n      // The resulting type is Effect<User | void, \"DbError\">, which is problematic.\n    }),\n    // This `map` will now have a type error because `u` could be `void`.\n    Effect.map((u) => `Welcome, ${u.name}!`),\n  );\n\n// `Effect.filterOrFail` avoids this problem entirely by forcing a failure,\n// which keeps the success channel clean and correctly typed.\n```\n\n### Why This is Better\n\n*   **It's a Real Bug:** This isn't just a style issue; it's a legitimate logical error that leads to incorrect types and broken code.\n*   **It's a Common Mistake:** Developers new to functional pipelines often forget that every path must return a value.\n*   **It Reinforces the \"Why\":** It perfectly demonstrates *why* `Effect.filterOrFail` is superior: `filterOrFail` guarantees that if the condition fails, the computation fails, preserving the integrity of the success channel.",
    "explanation": "This pattern allows you to embed decision-making logic directly into your composition pipelines, making your code more declarative and readable. It solves two key problems:\n\n1.  **Separation of Concerns:** It cleanly separates the logic of producing a value from the logic of validating or making decisions about that value.\n2.  **Reusable Business Logic:** A predicate function (e.g., `const isAdmin = (user: User) => ...`) becomes a named, reusable, and testable piece of business logic, far superior to scattering inline `if` statements throughout your code.\n\nUsing these operators turns conditional logic into a composable part of your `Effect`, rather than an imperative statement that breaks the flow.\n\n---",
    "content": "### Pattern: `conditionally-branching-workflows.mdx`\n\n## Guideline\n\nTo make decisions based on a successful value within an `Effect` pipeline, use predicate-based operators:\n-   **To Validate and Fail:** Use `Effect.filterOrFail(predicate, onFailure)` to stop the workflow if a condition is not met.\n-   **To Choose a Path:** Use `Effect.if(condition, { onTrue, onFalse })` or `Effect.gen` to execute different effects based on a condition.\n\n---\n\n## Rationale\n\nThis pattern allows you to embed decision-making logic directly into your composition pipelines, making your code more declarative and readable. It solves two key problems:\n\n1.  **Separation of Concerns:** It cleanly separates the logic of producing a value from the logic of validating or making decisions about that value.\n2.  **Reusable Business Logic:** A predicate function (e.g., `const isAdmin = (user: User) => ...`) becomes a named, reusable, and testable piece of business logic, far superior to scattering inline `if` statements throughout your code.\n\nUsing these operators turns conditional logic into a composable part of your `Effect`, rather than an imperative statement that breaks the flow.\n\n---\n\n## Good Example: Validating a User\n\nHere, we use `Effect.filterOrFail` with named predicates to validate a user before proceeding. The intent is crystal clear, and the business rules (`isActive`, `isAdmin`) are reusable.\n\n```typescript\nimport { Effect } from \"effect\";\n\ninterface User {\n  id: number;\n  status: \"active\" | \"inactive\";\n  roles: string[];\n}\n\ntype UserError = \"DbError\" | \"UserIsInactive\" | \"UserIsNotAdmin\";\n\nconst findUser = (id: number): Effect.Effect<User, \"DbError\"> =>\n  Effect.succeed({ id, status: \"active\", roles: [\"admin\"] });\n\n// Reusable, testable predicates that document business rules.\nconst isActive = (user: User): boolean =>\n  user.status === \"active\";\n\nconst isAdmin = (user: User): boolean =>\n  user.roles.includes(\"admin\");\n\nconst program = (id: number): Effect.Effect<string, UserError> =>\n  findUser(id).pipe(\n    // Validate user is active using Effect.filterOrFail\n    Effect.filterOrFail(\n      isActive,\n      () => \"UserIsInactive\" as const\n    ),\n    // Validate user is admin using Effect.filterOrFail\n    Effect.filterOrFail(\n      isAdmin,\n      () => \"UserIsNotAdmin\" as const\n    ),\n    // Success case\n    Effect.map((user) => `Welcome, admin user #${user.id}!`)\n  );\n\n// We can then handle the specific failures in a type-safe way.\nconst handled = program(123).pipe(\n  Effect.match({\n    onFailure: (error) => {\n      switch (error) {\n        case \"UserIsNotAdmin\":\n          return \"Access denied: requires admin role.\";\n        case \"UserIsInactive\":\n          return \"Access denied: user is not active.\";\n        case \"DbError\":\n          return \"Error: could not find user.\";\n        default:\n          return `Unknown error: ${error}`;\n      }\n    },\n    onSuccess: (result) => result\n  })\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* handled;\n  yield* Effect.log(result);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---\n\n## Anti-Pattern\n\nUsing `Effect.flatMap` with a manual `if` statement and forgetting to handle the `else` case. This is a common mistake that leads to an inferred type of `Effect<void, ...>`, which can cause confusing type errors downstream because the success value is lost.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { findUser, isAdmin } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: The `else` case is missing.\nconst program = (id: number) =>\n  findUser(id).pipe(\n    Effect.flatMap((user) => {\n      if (isAdmin(user)) {\n        // This returns Effect<User>, but what happens if the user is not an admin?\n        return Effect.succeed(user);\n      }\n      // Because there's no `else` branch, TypeScript infers that this\n      // block can also implicitly return `void`.\n      // The resulting type is Effect<User | void, \"DbError\">, which is problematic.\n    }),\n    // This `map` will now have a type error because `u` could be `void`.\n    Effect.map((u) => `Welcome, ${u.name}!`),\n  );\n\n// `Effect.filterOrFail` avoids this problem entirely by forcing a failure,\n// which keeps the success channel clean and correctly typed.\n```\n\n### Why This is Better\n\n*   **It's a Real Bug:** This isn't just a style issue; it's a legitimate logical error that leads to incorrect types and broken code.\n*   **It's a Common Mistake:** Developers new to functional pipelines often forget that every path must return a value.\n*   **It Reinforces the \"Why\":** It perfectly demonstrates *why* `Effect.filterOrFail` is superior: `filterOrFail` guarantees that if the condition fails, the computation fails, preserving the integrity of the success channel."
  },
  {
    "id": "control-flow-with-combinators",
    "title": "Control Flow with Conditional Combinators",
    "description": "Use conditional combinators for control flow.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\"\n\nconst attemptAdminAction = (user: { isAdmin: boolean }) =>\n  Effect.if(user.isAdmin, {\n    onTrue: () => Effect.succeed(\"Admin action completed.\"),\n    onFalse: () => Effect.fail(\"Permission denied.\")\n  })\n\nconst program = Effect.gen(function* () {\n  // Try with admin user\n  yield* Effect.logInfo(\"\\nTrying with admin user...\")\n  const adminResult = yield* Effect.either(attemptAdminAction({ isAdmin: true }))\n  yield* Effect.logInfo(`Admin result: ${adminResult._tag === 'Right' ? adminResult.right : adminResult.left}`)\n\n  // Try with non-admin user\n  yield* Effect.logInfo(\"\\nTrying with non-admin user...\")\n  const userResult = yield* Effect.either(attemptAdminAction({ isAdmin: false }))\n  yield* Effect.logInfo(`User result: ${userResult._tag === 'Right' ? userResult.right : userResult.left}`)\n})\n\nEffect.runPromise(program)\n```\n\n**Explanation:**  \n`Effect.if` and related combinators allow you to branch logic without leaving\nthe Effect world or breaking the flow of composition.",
    "antiPattern": "Using `Effect.gen` for a single, simple conditional check can be more verbose\nthan necessary. For simple branching, `Effect.if` is often more concise.",
    "explanation": "These combinators allow you to embed conditional logic directly into your\n`.pipe()` compositions, maintaining a declarative style for simple branching.",
    "content": "# Control Flow with Conditional Combinators\n\n## Guideline\n\nUse declarative combinators like `Effect.if`, `Effect.when`, and\n`Effect.unless` to execute effects based on runtime conditions.\n\n## Rationale\n\nThese combinators allow you to embed conditional logic directly into your\n`.pipe()` compositions, maintaining a declarative style for simple branching.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\"\n\nconst attemptAdminAction = (user: { isAdmin: boolean }) =>\n  Effect.if(user.isAdmin, {\n    onTrue: () => Effect.succeed(\"Admin action completed.\"),\n    onFalse: () => Effect.fail(\"Permission denied.\")\n  })\n\nconst program = Effect.gen(function* () {\n  // Try with admin user\n  yield* Effect.logInfo(\"\\nTrying with admin user...\")\n  const adminResult = yield* Effect.either(attemptAdminAction({ isAdmin: true }))\n  yield* Effect.logInfo(`Admin result: ${adminResult._tag === 'Right' ? adminResult.right : adminResult.left}`)\n\n  // Try with non-admin user\n  yield* Effect.logInfo(\"\\nTrying with non-admin user...\")\n  const userResult = yield* Effect.either(attemptAdminAction({ isAdmin: false }))\n  yield* Effect.logInfo(`User result: ${userResult._tag === 'Right' ? userResult.right : userResult.left}`)\n})\n\nEffect.runPromise(program)\n```\n\n**Explanation:**  \n`Effect.if` and related combinators allow you to branch logic without leaving\nthe Effect world or breaking the flow of composition.\n\n## Anti-Pattern\n\nUsing `Effect.gen` for a single, simple conditional check can be more verbose\nthan necessary. For simple branching, `Effect.if` is often more concise."
  },
  {
    "id": "control-repetition-with-schedule",
    "title": "Control Repetition with Schedule",
    "description": "Use Schedule to create composable policies for controlling the repetition and retrying of effects.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "This example demonstrates composition by creating a common, robust retry policy: exponential backoff with jitter, limited to 5 attempts.\n\n```typescript\nimport { Effect, Schedule, Duration } from \"effect\"\n\n// A simple effect that can fail\nconst flakyEffect = Effect.try({\n  try: () => {\n    if (Math.random() > 0.2) {\n      throw new Error(\"Transient error\")\n    }\n    return \"Operation succeeded!\"\n  },\n  catch: (error: unknown) => {\n    Effect.logInfo(\"Operation failed, retrying...\")\n    return error\n  }\n})\n\n// --- Building a Composable Schedule ---\n\n// 1. Start with a base exponential backoff (100ms, 200ms, 400ms...)\nconst exponentialBackoff = Schedule.exponential(\"100 millis\")\n\n// 2. Add random jitter to avoid thundering herd problems\nconst withJitter = Schedule.jittered(exponentialBackoff)\n\n// 3. Limit the schedule to a maximum of 5 repetitions\nconst limitedWithJitter = Schedule.compose(\n  withJitter,\n  Schedule.recurs(5)\n)\n\n// --- Using the Schedule ---\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting operation...\")\n  const result = yield* Effect.retry(flakyEffect, limitedWithJitter)\n  yield* Effect.logInfo(`Final result: ${result}`)\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n---",
    "antiPattern": "Writing manual, imperative retry logic. This is verbose, stateful, hard to reason about, and not easily composable.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { flakyEffect } from \"./somewhere\";\n\n// ‚ùå WRONG: Manual, stateful, and complex retry logic.\nfunction manualRetry(\n  effect: typeof flakyEffect,\n  retriesLeft: number,\n  delay: number,\n): Effect.Effect<string, \"ApiError\"> {\n  return effect.pipe(\n    Effect.catchTag(\"ApiError\", () => {\n      if (retriesLeft > 0) {\n        return Effect.sleep(delay).pipe(\n          Effect.flatMap(() => manualRetry(effect, retriesLeft - 1, delay * 2)),\n        );\n      }\n      return Effect.fail(\"ApiError\" as const);\n    }),\n  );\n}\n\nconst program = manualRetry(flakyEffect, 5, 100);\n```",
    "explanation": "While you could write manual loops or recursive functions, `Schedule` provides a much more powerful, declarative, and composable way to manage repetition. The key benefits are:\n\n-   **Declarative:** You separate the *what* (the effect to run) from the *how* and *when* (the schedule it runs on).\n-   **Composable:** You can build complex schedules from simple, primitive ones. For example, you can create a schedule that runs \"up to 5 times, with an exponential backoff, plus some random jitter\" by composing `Schedule.recurs`, `Schedule.exponential`, and `Schedule.jittered`.\n-   **Stateful:** A `Schedule` keeps track of its own state (like the number of repetitions), making it easy to create policies that depend on the execution history.\n\n---",
    "content": "## Guideline\n\nA `Schedule<In, Out>` is a highly-composable blueprint that defines a recurring schedule. It takes an input of type `In` (e.g., the error from a failed effect) and produces an output of type `Out` (e.g., the decision to continue). Use `Schedule` with operators like `Effect.repeat` and `Effect.retry` to control complex repeating logic.\n\n---\n\n## Rationale\n\nWhile you could write manual loops or recursive functions, `Schedule` provides a much more powerful, declarative, and composable way to manage repetition. The key benefits are:\n\n-   **Declarative:** You separate the *what* (the effect to run) from the *how* and *when* (the schedule it runs on).\n-   **Composable:** You can build complex schedules from simple, primitive ones. For example, you can create a schedule that runs \"up to 5 times, with an exponential backoff, plus some random jitter\" by composing `Schedule.recurs`, `Schedule.exponential`, and `Schedule.jittered`.\n-   **Stateful:** A `Schedule` keeps track of its own state (like the number of repetitions), making it easy to create policies that depend on the execution history.\n\n---\n\n## Good Example\n\nThis example demonstrates composition by creating a common, robust retry policy: exponential backoff with jitter, limited to 5 attempts.\n\n```typescript\nimport { Effect, Schedule, Duration } from \"effect\"\n\n// A simple effect that can fail\nconst flakyEffect = Effect.try({\n  try: () => {\n    if (Math.random() > 0.2) {\n      throw new Error(\"Transient error\")\n    }\n    return \"Operation succeeded!\"\n  },\n  catch: (error: unknown) => {\n    Effect.logInfo(\"Operation failed, retrying...\")\n    return error\n  }\n})\n\n// --- Building a Composable Schedule ---\n\n// 1. Start with a base exponential backoff (100ms, 200ms, 400ms...)\nconst exponentialBackoff = Schedule.exponential(\"100 millis\")\n\n// 2. Add random jitter to avoid thundering herd problems\nconst withJitter = Schedule.jittered(exponentialBackoff)\n\n// 3. Limit the schedule to a maximum of 5 repetitions\nconst limitedWithJitter = Schedule.compose(\n  withJitter,\n  Schedule.recurs(5)\n)\n\n// --- Using the Schedule ---\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting operation...\")\n  const result = yield* Effect.retry(flakyEffect, limitedWithJitter)\n  yield* Effect.logInfo(`Final result: ${result}`)\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n---\n\n## Anti-Pattern\n\nWriting manual, imperative retry logic. This is verbose, stateful, hard to reason about, and not easily composable.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { flakyEffect } from \"./somewhere\";\n\n// ‚ùå WRONG: Manual, stateful, and complex retry logic.\nfunction manualRetry(\n  effect: typeof flakyEffect,\n  retriesLeft: number,\n  delay: number,\n): Effect.Effect<string, \"ApiError\"> {\n  return effect.pipe(\n    Effect.catchTag(\"ApiError\", () => {\n      if (retriesLeft > 0) {\n        return Effect.sleep(delay).pipe(\n          Effect.flatMap(() => manualRetry(effect, retriesLeft - 1, delay * 2)),\n        );\n      }\n      return Effect.fail(\"ApiError\" as const);\n    }),\n  );\n}\n\nconst program = manualRetry(flakyEffect, 5, 100);\n```"
  },
  {
    "id": "constructor-from-nullable-option-either",
    "title": "Converting from Nullable, Option, or Either",
    "description": "Use fromNullable, fromOption, and fromEither to lift nullable values, Option, or Either into Effects or Streams for safe, typeful interop.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Option: Convert a nullable value to an Option\nconst nullableValue: string | null = Math.random() > 0.5 ? \"hello\" : null;\nconst option = Option.fromNullable(nullableValue); // Option<string>\n\n// Effect: Convert an Option to an Effect that may fail\nconst someValue = Option.some(42);\nconst effectFromOption = Option.match(someValue, {\n  onNone: () => Effect.fail(\"No value\"),\n  onSome: (value) => Effect.succeed(value)\n}); // Effect<number, string, never>\n\n// Effect: Convert an Either to an Effect\nconst either = Either.right(\"success\");\nconst effectFromEither = Either.match(either, {\n  onLeft: (error) => Effect.fail(error),\n  onRight: (value) => Effect.succeed(value)\n}); // Effect<string, never, never>\n```\n\n**Explanation:**  \n- `Effect.fromNullable` lifts a nullable value into an Effect, failing if the value is `null` or `undefined`.\n- `Effect.fromOption` lifts an Option into an Effect, failing if the Option is `none`.\n- `Effect.fromEither` lifts an Either into an Effect, failing if the Either is `left`.",
    "antiPattern": "Passing around `null`, `undefined`, or custom option/either types without converting them, which leads to unsafe, non-composable code and harder error handling.",
    "explanation": "Converting to Effect, Stream, Option, or Either lets you use all the combinators, error handling, and resource safety of the Effect ecosystem, while avoiding the pitfalls of `null` and `undefined`.",
    "content": "# Converting from Nullable, Option, or Either\n\n## Guideline\n\nUse the `fromNullable`, `fromOption`, and `fromEither` constructors to convert nullable values, `Option`, or `Either` into Effects or Streams.  \nThis enables safe, typeful interop with legacy code, APIs, or libraries that use `null`, `undefined`, or their own option/either types.\n\n## Rationale\n\nConverting to Effect, Stream, Option, or Either lets you use all the combinators, error handling, and resource safety of the Effect ecosystem, while avoiding the pitfalls of `null` and `undefined`.\n\n## Good Example\n\n```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Option: Convert a nullable value to an Option\nconst nullableValue: string | null = Math.random() > 0.5 ? \"hello\" : null;\nconst option = Option.fromNullable(nullableValue); // Option<string>\n\n// Effect: Convert an Option to an Effect that may fail\nconst someValue = Option.some(42);\nconst effectFromOption = Option.match(someValue, {\n  onNone: () => Effect.fail(\"No value\"),\n  onSome: (value) => Effect.succeed(value)\n}); // Effect<number, string, never>\n\n// Effect: Convert an Either to an Effect\nconst either = Either.right(\"success\");\nconst effectFromEither = Either.match(either, {\n  onLeft: (error) => Effect.fail(error),\n  onRight: (value) => Effect.succeed(value)\n}); // Effect<string, never, never>\n```\n\n**Explanation:**  \n- `Effect.fromNullable` lifts a nullable value into an Effect, failing if the value is `null` or `undefined`.\n- `Effect.fromOption` lifts an Option into an Effect, failing if the Option is `none`.\n- `Effect.fromEither` lifts an Either into an Effect, failing if the Either is `left`.\n\n## Anti-Pattern\n\nPassing around `null`, `undefined`, or custom option/either types without converting them, which leads to unsafe, non-composable code and harder error handling."
  },
  {
    "id": "launch-http-server",
    "title": "Create a Basic HTTP Server",
    "description": "Use Http.server.serve with a platform-specific layer to run an HTTP application.",
    "skillLevel": "beginner",
    "useCases": [
      "building-apis"
    ],
    "example": "This example creates a minimal server that responds to all requests with \"Hello, World!\". The application logic is a simple `Effect` that returns an `Http.response`. We use `NodeRuntime.runMain` to execute the server effect, which is the standard way to launch a long-running application.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\nimport * as http from \"http\";\n\n// Create HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  sync: () => ({\n    start: () =>\n      Effect.gen(function* () {\n        const server = http.createServer(\n          (req: http.IncomingMessage, res: http.ServerResponse) => {\n            res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n            res.end(\"Hello, World!\");\n          }\n        );\n\n        // Add cleanup finalizer\n        yield* Effect.addFinalizer(() =>\n          Effect.gen(function* () {\n            yield* Effect.sync(() => server.close());\n            yield* Effect.logInfo(\"Server shut down\");\n          })\n        );\n\n        // Start server with timeout\n        yield* Effect.async<void, Error>((resume) => {\n          server.on(\"error\", (error) => resume(Effect.fail(error)));\n          server.listen(3456, \"localhost\", () => {\n            resume(Effect.succeed(void 0));\n          });\n        }).pipe(\n          Effect.timeout(Duration.seconds(5)),\n          Effect.catchAll((error) =>\n            Effect.gen(function* () {\n              yield* Effect.logError(`Failed to start server: ${error}`);\n              return yield* Effect.fail(error);\n            })\n          )\n        );\n\n        yield* Effect.logInfo(\"Server running at http://localhost:3456/\");\n\n        // Run for a short duration to demonstrate the server is working\n        yield* Effect.sleep(Duration.seconds(3));\n        yield* Effect.logInfo(\"Server demonstration complete\");\n      }),\n  }),\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start();\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up properly\n);\n\n// Run the server with proper error handling\nconst programWithErrorHandling = Effect.provide(program, HttpServer.Default).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program failed: ${error}`);\n      return yield* Effect.fail(error);\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling).catch(() => {\n  process.exit(1);\n});\n\n/*\nTo test:\n1. Server will timeout after 5 seconds if it can't start\n2. Server runs on port 3456 to avoid conflicts\n3. Proper cleanup on shutdown\n4. Demonstrates server lifecycle: start -> run -> shutdown\n*/\n\n```",
    "antiPattern": "The common anti-pattern is to use the raw Node.js `http` module directly, outside of the Effect runtime. This approach creates a disconnect between your application logic and the server's lifecycle.\n\n```typescript\nimport * as http from 'http';\n\n// Manually create a server using the Node.js built-in module.\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello, World!');\n});\n\n// Manually start the server and log the port.\nconst port = 3000;\nserver.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n```\n\nThis imperative approach is discouraged when building an Effect application because it forfeits all the benefits of the ecosystem. It runs outside of Effect's structured concurrency, cannot be managed by its resource-safe `Scope`, does not integrate with `Layer` for dependency injection, and requires manual error handling, making it less robust and much harder to compose with other effectful logic.",
    "explanation": "In Effect, an HTTP server is not just a side effect; it's a managed, effectful process. The `@effect/platform` package provides a platform-agnostic API for defining HTTP applications, while packages like `@effect/platform-node` provide the concrete implementation.\n\nThe core function `Http.server.serve(app)` takes your application logic and returns an `Effect` that, when run, starts the server. This `Effect` is designed to run indefinitely, only terminating if the server crashes or is gracefully shut down.\n\nThis approach provides several key benefits:\n\n1.  **Lifecycle Management**: The server's lifecycle is managed by the Effect runtime. This means structured concurrency applies, ensuring graceful shutdowns and proper resource handling automatically.\n2.  **Integration**: The server is a first-class citizen in the Effect ecosystem. It can seamlessly access dependencies provided by `Layer`, use `Config` for configuration, and integrate with `Logger`.\n3.  **Platform Agnosticism**: By coding to the `Http.App` interface, your application logic remains portable across different JavaScript runtimes (Node.js, Bun, Deno) by simply swapping out the platform layer.\n\n---",
    "content": "## Guideline\n\nTo create and run a web server, define your application as an `Http.App` and execute it using `Http.server.serve`, providing a platform-specific layer like `NodeHttpServer.layer`.\n\n---\n\n## Rationale\n\nIn Effect, an HTTP server is not just a side effect; it's a managed, effectful process. The `@effect/platform` package provides a platform-agnostic API for defining HTTP applications, while packages like `@effect/platform-node` provide the concrete implementation.\n\nThe core function `Http.server.serve(app)` takes your application logic and returns an `Effect` that, when run, starts the server. This `Effect` is designed to run indefinitely, only terminating if the server crashes or is gracefully shut down.\n\nThis approach provides several key benefits:\n\n1.  **Lifecycle Management**: The server's lifecycle is managed by the Effect runtime. This means structured concurrency applies, ensuring graceful shutdowns and proper resource handling automatically.\n2.  **Integration**: The server is a first-class citizen in the Effect ecosystem. It can seamlessly access dependencies provided by `Layer`, use `Config` for configuration, and integrate with `Logger`.\n3.  **Platform Agnosticism**: By coding to the `Http.App` interface, your application logic remains portable across different JavaScript runtimes (Node.js, Bun, Deno) by simply swapping out the platform layer.\n\n---\n\n## Good Example\n\nThis example creates a minimal server that responds to all requests with \"Hello, World!\". The application logic is a simple `Effect` that returns an `Http.response`. We use `NodeRuntime.runMain` to execute the server effect, which is the standard way to launch a long-running application.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\nimport * as http from \"http\";\n\n// Create HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  sync: () => ({\n    start: () =>\n      Effect.gen(function* () {\n        const server = http.createServer(\n          (req: http.IncomingMessage, res: http.ServerResponse) => {\n            res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n            res.end(\"Hello, World!\");\n          }\n        );\n\n        // Add cleanup finalizer\n        yield* Effect.addFinalizer(() =>\n          Effect.gen(function* () {\n            yield* Effect.sync(() => server.close());\n            yield* Effect.logInfo(\"Server shut down\");\n          })\n        );\n\n        // Start server with timeout\n        yield* Effect.async<void, Error>((resume) => {\n          server.on(\"error\", (error) => resume(Effect.fail(error)));\n          server.listen(3456, \"localhost\", () => {\n            resume(Effect.succeed(void 0));\n          });\n        }).pipe(\n          Effect.timeout(Duration.seconds(5)),\n          Effect.catchAll((error) =>\n            Effect.gen(function* () {\n              yield* Effect.logError(`Failed to start server: ${error}`);\n              return yield* Effect.fail(error);\n            })\n          )\n        );\n\n        yield* Effect.logInfo(\"Server running at http://localhost:3456/\");\n\n        // Run for a short duration to demonstrate the server is working\n        yield* Effect.sleep(Duration.seconds(3));\n        yield* Effect.logInfo(\"Server demonstration complete\");\n      }),\n  }),\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start();\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up properly\n);\n\n// Run the server with proper error handling\nconst programWithErrorHandling = Effect.provide(program, HttpServer.Default).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program failed: ${error}`);\n      return yield* Effect.fail(error);\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling).catch(() => {\n  process.exit(1);\n});\n\n/*\nTo test:\n1. Server will timeout after 5 seconds if it can't start\n2. Server runs on port 3456 to avoid conflicts\n3. Proper cleanup on shutdown\n4. Demonstrates server lifecycle: start -> run -> shutdown\n*/\n\n```\n\n## Anti-Pattern\n\nThe common anti-pattern is to use the raw Node.js `http` module directly, outside of the Effect runtime. This approach creates a disconnect between your application logic and the server's lifecycle.\n\n```typescript\nimport * as http from 'http';\n\n// Manually create a server using the Node.js built-in module.\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello, World!');\n});\n\n// Manually start the server and log the port.\nconst port = 3000;\nserver.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n```\n\nThis imperative approach is discouraged when building an Effect application because it forfeits all the benefits of the ecosystem. It runs outside of Effect's structured concurrency, cannot be managed by its resource-safe `Scope`, does not integrate with `Layer` for dependency injection, and requires manual error handling, making it less robust and much harder to compose with other effectful logic."
  },
  {
    "id": "create-managed-runtime-for-scoped-resources",
    "title": "Create a Managed Runtime for Scoped Resources",
    "description": "Create a managed runtime for scoped resources.",
    "skillLevel": "advanced",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Effect, Layer } from \"effect\";\n\nclass DatabasePool extends Effect.Service<DatabasePool>()(\n  \"DbPool\",\n  {\n    effect: Effect.gen(function* () {\n      yield* Effect.log(\"Acquiring pool\");\n      return {\n        query: () => Effect.succeed(\"result\")\n      };\n    })\n  }\n) {}\n\n// Create a program that uses the DatabasePool service\nconst program = Effect.gen(function* () {\n  const db = yield* DatabasePool;\n  yield* Effect.log(\"Using DB\");\n  yield* db.query();\n});\n\n// Run the program with the service implementation\nEffect.runPromise(\n  program.pipe(\n    Effect.provide(DatabasePool.Default),\n    Effect.scoped\n  )\n);\n```\n\n**Explanation:**  \n`Layer.launch` ensures that resources are acquired and released safely, even\nin the event of errors or interruptions.",
    "antiPattern": "Do not use `Layer.toRuntime` with layers that contain scoped resources. This\nwill acquire the resource, but the runtime has no mechanism to release it,\nleading to resource leaks.",
    "explanation": "`Layer.launch` is designed for resource safety. It acquires all resources,\nprovides them to your effect, and‚Äîcrucially‚Äîguarantees that all registered\nfinalizers are executed upon completion or interruption.",
    "content": "# Create a Managed Runtime for Scoped Resources\n\n## Guideline\n\nFor services that manage resources needing explicit cleanup (e.g., a database\nconnection), define them in a `Layer` using `Layer.scoped`. Then, use\n`Layer.launch` to provide this layer to your application.\n\n## Rationale\n\n`Layer.launch` is designed for resource safety. It acquires all resources,\nprovides them to your effect, and‚Äîcrucially‚Äîguarantees that all registered\nfinalizers are executed upon completion or interruption.\n\n## Good Example\n\n```typescript\nimport { Effect, Layer } from \"effect\";\n\nclass DatabasePool extends Effect.Service<DatabasePool>()(\n  \"DbPool\",\n  {\n    effect: Effect.gen(function* () {\n      yield* Effect.log(\"Acquiring pool\");\n      return {\n        query: () => Effect.succeed(\"result\")\n      };\n    })\n  }\n) {}\n\n// Create a program that uses the DatabasePool service\nconst program = Effect.gen(function* () {\n  const db = yield* DatabasePool;\n  yield* Effect.log(\"Using DB\");\n  yield* db.query();\n});\n\n// Run the program with the service implementation\nEffect.runPromise(\n  program.pipe(\n    Effect.provide(DatabasePool.Default),\n    Effect.scoped\n  )\n);\n```\n\n**Explanation:**  \n`Layer.launch` ensures that resources are acquired and released safely, even\nin the event of errors or interruptions.\n\n## Anti-Pattern\n\nDo not use `Layer.toRuntime` with layers that contain scoped resources. This\nwill acquire the resource, but the runtime has no mechanism to release it,\nleading to resource leaks."
  },
  {
    "id": "create-reusable-runtime-from-layers",
    "title": "Create a Reusable Runtime from Layers",
    "description": "Create a reusable runtime from layers.",
    "skillLevel": "advanced",
    "useCases": [
      "project-setup--execution"
    ],
    "example": "```typescript\nimport { Effect, Layer, Runtime } from \"effect\";\n\nclass GreeterService extends Effect.Service<GreeterService>()(\n  \"Greeter\",\n  {\n    sync: () => ({\n      greet: (name: string) => Effect.sync(() => `Hello ${name}`)\n    })\n  }\n) {}\n\nconst runtime = Effect.runSync(\n  Layer.toRuntime(GreeterService.Default).pipe(\n    Effect.scoped\n  )\n);\n\n// In a server, you would reuse `run` for every request.\nRuntime.runPromise(runtime)(Effect.log(\"Hello\"));\n```\n\n**Explanation:**  \nBy compiling your layers into a Runtime once, you avoid rebuilding the\ndependency graph for every effect execution.",
    "antiPattern": "For a long-running application, avoid providing layers and running an effect\nin a single operation. This forces Effect to rebuild the dependency graph on\nevery execution.",
    "explanation": "Building the dependency graph from layers has a one-time cost. Creating a\n`Runtime` once when your application starts is highly efficient for\nlong-running applications.",
    "content": "# Create a Reusable Runtime from Layers\n\n## Guideline\n\nFor applications that need to run multiple effects (e.g., a web server), use\n`Layer.toRuntime(appLayer)` to compile your dependency graph into a single,\nreusable `Runtime` object.\n\n## Rationale\n\nBuilding the dependency graph from layers has a one-time cost. Creating a\n`Runtime` once when your application starts is highly efficient for\nlong-running applications.\n\n## Good Example\n\n```typescript\nimport { Effect, Layer, Runtime } from \"effect\";\n\nclass GreeterService extends Effect.Service<GreeterService>()(\n  \"Greeter\",\n  {\n    sync: () => ({\n      greet: (name: string) => Effect.sync(() => `Hello ${name}`)\n    })\n  }\n) {}\n\nconst runtime = Effect.runSync(\n  Layer.toRuntime(GreeterService.Default).pipe(\n    Effect.scoped\n  )\n);\n\n// In a server, you would reuse `run` for every request.\nRuntime.runPromise(runtime)(Effect.log(\"Hello\"));\n```\n\n**Explanation:**  \nBy compiling your layers into a Runtime once, you avoid rebuilding the\ndependency graph for every effect execution.\n\n## Anti-Pattern\n\nFor a long-running application, avoid providing layers and running an effect\nin a single operation. This forces Effect to rebuild the dependency graph on\nevery execution."
  },
  {
    "id": "scoped-service-layer",
    "title": "Create a Service Layer from a Managed Resource",
    "description": "Provide a managed resource to the application context using `Layer.scoped`.",
    "skillLevel": "intermediate",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Effect, Console } from \"effect\";\n\n// 1. Define the service interface\ninterface DatabaseService {\n  readonly query: (sql: string) => Effect.Effect<string[], never, never>\n}\n\n// 2. Define the service implementation with scoped resource management\nclass Database extends Effect.Service<DatabaseService>()(\n  \"Database\",\n  {\n    // The scoped property manages the resource lifecycle\n    scoped: Effect.gen(function* () {\n      const id = Math.floor(Math.random() * 1000);\n      \n      // Acquire the connection\n      yield* Effect.log(`[Pool ${id}] Acquired`);\n      \n      // Setup cleanup to run when scope closes\n      yield* Effect.addFinalizer(() => Effect.log(`[Pool ${id}] Released`));\n      \n      // Return the service implementation\n      return {\n        query: (sql: string) => Effect.sync(() => \n          [`Result for '${sql}' from pool ${id}`]\n        )\n      };\n    })\n  }\n) {}\n\n// 3. Use the service in your program\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const users = yield* db.query(\"SELECT * FROM users\");\n  yield* Effect.log(`Query successful: ${users[0]}`);\n});\n\n// 4. Run the program with scoped resource management\nEffect.runPromise(\n  Effect.scoped(program).pipe(\n    Effect.provide(Database.Default)\n  )\n);\n\n/*\nOutput:\n[Pool 458] Acquired\nQuery successful: Result for 'SELECT * FROM users' from pool 458\n[Pool 458] Released\n*/\n```\n\n**Explanation:**\nThe `Effect.Service` helper creates the `Database` class, which acts as both the service definition and its context key (Tag). The `Database.Live` layer connects this service to a concrete, lifecycle-managed implementation. When `program` asks for the `Database` service, the Effect runtime uses the `Live` layer to run the `acquire` effect once, caches the resulting `DbPool`, and injects it. The `release` effect is automatically run when the program completes.",
    "antiPattern": "Creating and exporting a global singleton instance of a resource. This tightly couples your application to a specific implementation, makes testing difficult, and offers no guarantees about graceful shutdown.\n\n```typescript\n// ANTI-PATTERN: Global singleton\nexport const dbPool = makeDbPoolSync(); // Eagerly created, hard to test/mock\n\nfunction someBusinessLogic() {\n  // This function has a hidden dependency on the global dbPool\n  return dbPool.query(\"SELECT * FROM products\");\n}\n```",
    "explanation": "This pattern is the key to building robust, testable, and leak-proof applications in Effect. It elevates a managed resource into a first-class service that can be used anywhere in your application. The `Effect.Service` helper simplifies defining the service's interface and context key. This approach decouples your business logic from the concrete implementation, as the logic only depends on the abstract service. The `Layer` declaratively handles the resource's entire lifecycle, ensuring it is acquired lazily, shared safely, and released automatically.",
    "content": "# Create a Service Layer from a Managed Resource\n\n## Guideline\n\nDefine a service using `class MyService extends Effect.Service(...)`.   Implement the service using the `scoped` property of the service class. This property should be a scoped `Effect` (typically from `Effect.acquireRelease`) that builds and releases the underlying resource.\n\n## Rationale\n\nThis pattern is the key to building robust, testable, and leak-proof applications in Effect. It elevates a managed resource into a first-class service that can be used anywhere in your application. The `Effect.Service` helper simplifies defining the service's interface and context key. This approach decouples your business logic from the concrete implementation, as the logic only depends on the abstract service. The `Layer` declaratively handles the resource's entire lifecycle, ensuring it is acquired lazily, shared safely, and released automatically.\n\n## Good Example\n\n```typescript\nimport { Effect, Console } from \"effect\";\n\n// 1. Define the service interface\ninterface DatabaseService {\n  readonly query: (sql: string) => Effect.Effect<string[], never, never>\n}\n\n// 2. Define the service implementation with scoped resource management\nclass Database extends Effect.Service<DatabaseService>()(\n  \"Database\",\n  {\n    // The scoped property manages the resource lifecycle\n    scoped: Effect.gen(function* () {\n      const id = Math.floor(Math.random() * 1000);\n      \n      // Acquire the connection\n      yield* Effect.log(`[Pool ${id}] Acquired`);\n      \n      // Setup cleanup to run when scope closes\n      yield* Effect.addFinalizer(() => Effect.log(`[Pool ${id}] Released`));\n      \n      // Return the service implementation\n      return {\n        query: (sql: string) => Effect.sync(() => \n          [`Result for '${sql}' from pool ${id}`]\n        )\n      };\n    })\n  }\n) {}\n\n// 3. Use the service in your program\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const users = yield* db.query(\"SELECT * FROM users\");\n  yield* Effect.log(`Query successful: ${users[0]}`);\n});\n\n// 4. Run the program with scoped resource management\nEffect.runPromise(\n  Effect.scoped(program).pipe(\n    Effect.provide(Database.Default)\n  )\n);\n\n/*\nOutput:\n[Pool 458] Acquired\nQuery successful: Result for 'SELECT * FROM users' from pool 458\n[Pool 458] Released\n*/\n```\n\n**Explanation:**\nThe `Effect.Service` helper creates the `Database` class, which acts as both the service definition and its context key (Tag). The `Database.Live` layer connects this service to a concrete, lifecycle-managed implementation. When `program` asks for the `Database` service, the Effect runtime uses the `Live` layer to run the `acquire` effect once, caches the resulting `DbPool`, and injects it. The `release` effect is automatically run when the program completes.\n\n## Anti-Pattern\n\nCreating and exporting a global singleton instance of a resource. This tightly couples your application to a specific implementation, makes testing difficult, and offers no guarantees about graceful shutdown.\n\n```typescript\n// ANTI-PATTERN: Global singleton\nexport const dbPool = makeDbPoolSync(); // Eagerly created, hard to test/mock\n\nfunction someBusinessLogic() {\n  // This function has a hidden dependency on the global dbPool\n  return dbPool.query(\"SELECT * FROM products\");\n}\n```"
  },
  {
    "id": "stream-from-iterable",
    "title": "Create a Stream from a List",
    "description": "Use Stream.fromIterable to begin a pipeline from an in-memory collection.",
    "skillLevel": "beginner",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example takes a simple array of numbers, creates a stream from it, performs a transformation on each number, and then runs the stream to collect the results.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\nconst numbers = [1, 2, 3, 4, 5];\n\n// Create a stream from the array of numbers.\nconst program = Stream.fromIterable(numbers).pipe(\n  // Perform a simple, synchronous transformation on each item.\n  Stream.map((n) => `Item: ${n}`),\n  // Run the stream and collect all the transformed items into a Chunk.\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const processedItems = yield* program;\n  yield* Effect.log(`Processed items: ${JSON.stringify(Chunk.toArray(processedItems))}`);\n  return processedItems;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n[ 'Item: 1', 'Item: 2', 'Item: 3', 'Item: 4', 'Item: 5' ]\n*/\n```",
    "antiPattern": "The common alternative is to use standard array methods like `.map()` or a `for...of` loop. While perfectly fine for simple, synchronous tasks, this approach is an anti-pattern when building a *pipeline*.\n\n```typescript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Using Array.prototype.map\nconst processedItems = numbers.map((n) => `Item: ${n}`);\n\nconsole.log(processedItems);\n```\n\nThis is an anti-pattern in the context of building a larger pipeline because:\n\n1.  **It's Not Composable with Effects**: The result is just a new array. If the next step in your pipeline was an asynchronous database call for each item, you couldn't simply `.pipe()` the result into it. You would have to leave the synchronous world of `.map()` and start a new `Effect.forEach`, breaking the unified pipeline structure.\n2.  **It's Eager**: The `.map()` operation processes the entire array at once. `Stream` is lazy; it only processes items as they are requested by downstream consumers, which is far more efficient for large collections or complex transformations.",
    "explanation": "Every data pipeline needs a source. The simplest and most common source is a pre-existing list of items in memory. `Stream.fromIterable` is the bridge from standard JavaScript data structures to the powerful, composable world of Effect's `Stream`.\n\nThis pattern is fundamental for several reasons:\n\n1.  **Entry Point**: It's the \"Hello, World!\" of data pipelines, providing the easiest way to start experimenting with stream transformations.\n2.  **Testing**: In tests, you frequently need to simulate a data source (like a database query or API call). Creating a stream from a mock array of data is the standard way to do this, allowing you to test your pipeline's logic in isolation.\n3.  **Composability**: It transforms a static, eager data structure (an array) into a lazy, pull-based stream. This allows you to pipe it into the rest of the Effect ecosystem, enabling asynchronous operations, concurrency, and resource management in subsequent steps.\n\n---",
    "content": "## Guideline\n\nTo start a data pipeline from an existing in-memory collection like an array, use `Stream.fromIterable`.\n\n---\n\n## Rationale\n\nEvery data pipeline needs a source. The simplest and most common source is a pre-existing list of items in memory. `Stream.fromIterable` is the bridge from standard JavaScript data structures to the powerful, composable world of Effect's `Stream`.\n\nThis pattern is fundamental for several reasons:\n\n1.  **Entry Point**: It's the \"Hello, World!\" of data pipelines, providing the easiest way to start experimenting with stream transformations.\n2.  **Testing**: In tests, you frequently need to simulate a data source (like a database query or API call). Creating a stream from a mock array of data is the standard way to do this, allowing you to test your pipeline's logic in isolation.\n3.  **Composability**: It transforms a static, eager data structure (an array) into a lazy, pull-based stream. This allows you to pipe it into the rest of the Effect ecosystem, enabling asynchronous operations, concurrency, and resource management in subsequent steps.\n\n---\n\n## Good Example\n\nThis example takes a simple array of numbers, creates a stream from it, performs a transformation on each number, and then runs the stream to collect the results.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\nconst numbers = [1, 2, 3, 4, 5];\n\n// Create a stream from the array of numbers.\nconst program = Stream.fromIterable(numbers).pipe(\n  // Perform a simple, synchronous transformation on each item.\n  Stream.map((n) => `Item: ${n}`),\n  // Run the stream and collect all the transformed items into a Chunk.\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const processedItems = yield* program;\n  yield* Effect.log(`Processed items: ${JSON.stringify(Chunk.toArray(processedItems))}`);\n  return processedItems;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n[ 'Item: 1', 'Item: 2', 'Item: 3', 'Item: 4', 'Item: 5' ]\n*/\n```\n\n## Anti-Pattern\n\nThe common alternative is to use standard array methods like `.map()` or a `for...of` loop. While perfectly fine for simple, synchronous tasks, this approach is an anti-pattern when building a *pipeline*.\n\n```typescript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Using Array.prototype.map\nconst processedItems = numbers.map((n) => `Item: ${n}`);\n\nconsole.log(processedItems);\n```\n\nThis is an anti-pattern in the context of building a larger pipeline because:\n\n1.  **It's Not Composable with Effects**: The result is just a new array. If the next step in your pipeline was an asynchronous database call for each item, you couldn't simply `.pipe()` the result into it. You would have to leave the synchronous world of `.map()` and start a new `Effect.forEach`, breaking the unified pipeline structure.\n2.  **It's Eager**: The `.map()` operation processes the entire array at once. `Stream` is lazy; it only processes items as they are requested by downstream consumers, which is far more efficient for large collections or complex transformations."
  },
  {
    "id": "create-a-testable-http-client-service",
    "title": "Create a Testable HTTP Client Service",
    "description": "Define an HttpClient service with distinct Live and Test layers to enable testable API interactions.",
    "skillLevel": "intermediate",
    "useCases": [
      "making-http-requests"
    ],
    "example": "### 1. Define the Service\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\";\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\";\n  readonly error: unknown;\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\");\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>;\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\"HttpClient\", {\n  sync: () => ({\n    get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n      Effect.tryPromise<T>(() =>\n        fetch(url).then((res) => res.json() as T)\n      ).pipe(\n        Effect.catchAll((error) => Effect.fail(HttpError({ error })))\n      ),\n  }),\n}) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T),\n  })\n);\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient;\n  yield* Effect.logInfo(\"Fetching data...\");\n  const data = yield* client.get<{ title: string }>(\n    \"https://api.example.com/data\"\n  );\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`);\n});\n\n// Run with test implementation\nEffect.runPromise(Effect.provide(program, TestLayer));\n\n```\n\n### 2. Create the Live Implementation\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\"\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\"\n  readonly error: unknown\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\")\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\n  \"HttpClient\",\n  {\n    sync: () => ({\n      get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n        Effect.tryPromise({\n          try: () => fetch(url).then((res) => res.json()),\n          catch: (error) => HttpError({ error })\n        })\n    })\n  }\n) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T)\n  })\n)\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient\n  yield* Effect.logInfo(\"Fetching data...\")\n  const data = yield* client.get<{ title: string }>(\"https://api.example.com/data\")\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`)\n})\n\n// Run with test implementation\nEffect.runPromise(\n  Effect.provide(program, TestLayer)\n)\n```\n\n### 3. Create the Test Implementation\n\n```typescript\n// src/services/HttpClientTest.ts\nimport { Effect, Layer } from \"effect\";\nimport { HttpClient } from \"./HttpClient\";\n\nexport const HttpClientTest = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: (url) => Effect.succeed({ mock: \"data\", url }),\n  }),\n);\n```\n\n### 4. Usage in Business Logic\n\nYour business logic is now clean and only depends on the abstract `HttpClient`.\n\n```typescript\n// src/features/User/UserService.ts\nimport { Effect } from \"effect\";\nimport { HttpClient } from \"../../services/HttpClient\";\n\nexport const getUserFromApi = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    const data = yield* client.get(`https://api.example.com/users/${id}`);\n    // ... logic to parse and return user\n    return data;\n  });\n```\n\n---",
    "antiPattern": "Calling `fetch` directly from within your business logic functions. This creates a hard dependency on the global `fetch` API, making the function difficult to test and reuse.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This function is not easily testable.\nexport const getUserDirectly = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://api.example.com/users/${id}`).then((res) => res.json()),\n    catch: () => \"ApiError\" as const,\n  });\n```",
    "explanation": "Directly using `fetch` in your business logic makes it nearly impossible to test. Your tests would become slow, flaky (dependent on network conditions), and could have unintended side effects.\n\nBy abstracting the HTTP client into a service, you decouple your application's logic from the specific implementation of how HTTP requests are made. Your business logic depends only on the abstract `HttpClient` interface. In production, you provide the `Live` layer. In tests, you provide the `Test` layer. This makes your tests fast, deterministic, and reliable.\n\n---",
    "content": "## Guideline\n\nTo interact with external APIs, define an `HttpClient` service. Create two separate `Layer` implementations for this service:\n1.  **`HttpClientLive`**: The production implementation that uses a real HTTP client (like `fetch`) to make network requests.\n2.  **`HttpClientTest`**: A test implementation that returns mock data, allowing you to test your business logic without making actual network calls.\n\n---\n\n## Rationale\n\nDirectly using `fetch` in your business logic makes it nearly impossible to test. Your tests would become slow, flaky (dependent on network conditions), and could have unintended side effects.\n\nBy abstracting the HTTP client into a service, you decouple your application's logic from the specific implementation of how HTTP requests are made. Your business logic depends only on the abstract `HttpClient` interface. In production, you provide the `Live` layer. In tests, you provide the `Test` layer. This makes your tests fast, deterministic, and reliable.\n\n---\n\n## Good Example\n\n### 1. Define the Service\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\";\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\";\n  readonly error: unknown;\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\");\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>;\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\"HttpClient\", {\n  sync: () => ({\n    get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n      Effect.tryPromise<T>(() =>\n        fetch(url).then((res) => res.json() as T)\n      ).pipe(\n        Effect.catchAll((error) => Effect.fail(HttpError({ error })))\n      ),\n  }),\n}) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T),\n  })\n);\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient;\n  yield* Effect.logInfo(\"Fetching data...\");\n  const data = yield* client.get<{ title: string }>(\n    \"https://api.example.com/data\"\n  );\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`);\n});\n\n// Run with test implementation\nEffect.runPromise(Effect.provide(program, TestLayer));\n\n```\n\n### 2. Create the Live Implementation\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\"\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\"\n  readonly error: unknown\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\")\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\n  \"HttpClient\",\n  {\n    sync: () => ({\n      get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n        Effect.tryPromise({\n          try: () => fetch(url).then((res) => res.json()),\n          catch: (error) => HttpError({ error })\n        })\n    })\n  }\n) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T)\n  })\n)\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient\n  yield* Effect.logInfo(\"Fetching data...\")\n  const data = yield* client.get<{ title: string }>(\"https://api.example.com/data\")\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`)\n})\n\n// Run with test implementation\nEffect.runPromise(\n  Effect.provide(program, TestLayer)\n)\n```\n\n### 3. Create the Test Implementation\n\n```typescript\n// src/services/HttpClientTest.ts\nimport { Effect, Layer } from \"effect\";\nimport { HttpClient } from \"./HttpClient\";\n\nexport const HttpClientTest = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: (url) => Effect.succeed({ mock: \"data\", url }),\n  }),\n);\n```\n\n### 4. Usage in Business Logic\n\nYour business logic is now clean and only depends on the abstract `HttpClient`.\n\n```typescript\n// src/features/User/UserService.ts\nimport { Effect } from \"effect\";\nimport { HttpClient } from \"../../services/HttpClient\";\n\nexport const getUserFromApi = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    const data = yield* client.get(`https://api.example.com/users/${id}`);\n    // ... logic to parse and return user\n    return data;\n  });\n```\n\n---\n\n## Anti-Pattern\n\nCalling `fetch` directly from within your business logic functions. This creates a hard dependency on the global `fetch` API, making the function difficult to test and reuse.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This function is not easily testable.\nexport const getUserDirectly = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://api.example.com/users/${id}`).then((res) => res.json()),\n    catch: () => \"ApiError\" as const,\n  });\n```"
  },
  {
    "id": "create-pre-resolved-effect",
    "title": "Create Pre-resolved Effects with succeed and fail",
    "description": "Create pre-resolved effects with succeed and fail.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Data } from \"effect\"\n\n// Create a custom error type\nclass MyError extends Data.TaggedError(\"MyError\") {}\n\n// Create a program that demonstrates pre-resolved effects\nconst program = Effect.gen(function* () {\n  // Success effect\n  yield* Effect.logInfo(\"Running success effect...\")\n  yield* Effect.gen(function* () {\n    const value = yield* Effect.succeed(42)\n    yield* Effect.logInfo(`Success value: ${value}`)\n  })\n\n  // Failure effect\n  yield* Effect.logInfo(\"\\nRunning failure effect...\")\n  yield* Effect.gen(function* () {\n    // Use return yield* for effects that never succeed\n    return yield* Effect.fail(new MyError())\n  }).pipe(\n    Effect.catchTag(\"MyError\", (error) =>\n      Effect.logInfo(`Error occurred: ${error._tag}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n**Explanation:**  \nUse `Effect.succeed` for values you already have, and `Effect.fail` for\nimmediate, known errors.",
    "antiPattern": "Do not wrap a static value in `Effect.sync`. While it works, `Effect.succeed`\nis more descriptive and direct for values that are already available.",
    "explanation": "These are the simplest effect constructors, essential for returning static\nvalues within functions that must return an `Effect`.",
    "content": "# Create Pre-resolved Effects with succeed and fail\n\n## Guideline\n\nTo lift a pure, already-known value into an `Effect`, use `Effect.succeed()`.\nTo represent an immediate and known failure, use `Effect.fail()`.\n\n## Rationale\n\nThese are the simplest effect constructors, essential for returning static\nvalues within functions that must return an `Effect`.\n\n## Good Example\n\n```typescript\nimport { Effect, Data } from \"effect\"\n\n// Create a custom error type\nclass MyError extends Data.TaggedError(\"MyError\") {}\n\n// Create a program that demonstrates pre-resolved effects\nconst program = Effect.gen(function* () {\n  // Success effect\n  yield* Effect.logInfo(\"Running success effect...\")\n  yield* Effect.gen(function* () {\n    const value = yield* Effect.succeed(42)\n    yield* Effect.logInfo(`Success value: ${value}`)\n  })\n\n  // Failure effect\n  yield* Effect.logInfo(\"\\nRunning failure effect...\")\n  yield* Effect.gen(function* () {\n    // Use return yield* for effects that never succeed\n    return yield* Effect.fail(new MyError())\n  }).pipe(\n    Effect.catchTag(\"MyError\", (error) =>\n      Effect.logInfo(`Error occurred: ${error._tag}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n**Explanation:**  \nUse `Effect.succeed` for values you already have, and `Effect.fail` for\nimmediate, known errors.\n\n## Anti-Pattern\n\nDo not wrap a static value in `Effect.sync`. While it works, `Effect.succeed`\nis more descriptive and direct for values that are already available."
  },
  {
    "id": "constructor-from-iterable",
    "title": "Creating from Collections",
    "description": "Use fromIterable and fromArray to lift collections into Streams or Effects for batch or streaming processing.",
    "skillLevel": "beginner",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Stream, Effect } from \"effect\";\n\n// Stream: Create a stream from an array\nconst numbers = [1, 2, 3, 4];\nconst numberStream = Stream.fromIterable(numbers); // Stream<number>\n\n// Stream: Create a stream from any iterable\nfunction* gen() {\n  yield \"a\";\n  yield \"b\";\n}\nconst letterStream = Stream.fromIterable(gen()); // Stream<string>\n\n// Effect: Create an effect from an array of effects (batch)\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst batchEffect = Effect.all(effects); // Effect<[1, 2]>\n```\n\n**Explanation:**  \n- `Stream.fromIterable` creates a stream from any array or iterable, enabling streaming and batch operations.\n- `Effect.all` (covered elsewhere) can be used to process arrays of effects in batch.",
    "antiPattern": "Manually looping over collections and running effects or streams imperatively, which loses composability, error handling, and resource safety.",
    "explanation": "Lifting collections into Streams or Effects allows you to process data in a composable, resource-safe, and potentially concurrent way.  \nIt also enables you to use all of Effect's combinators for transformation, filtering, and error handling.",
    "content": "# Creating from Collections\n\n## Guideline\n\nUse the `fromIterable` and `fromArray` constructors to create Streams or Effects from arrays, iterables, or other collections.  \nThis is the foundation for batch processing, streaming, and working with large or dynamic data sources.\n\n## Rationale\n\nLifting collections into Streams or Effects allows you to process data in a composable, resource-safe, and potentially concurrent way.  \nIt also enables you to use all of Effect's combinators for transformation, filtering, and error handling.\n\n## Good Example\n\n```typescript\nimport { Stream, Effect } from \"effect\";\n\n// Stream: Create a stream from an array\nconst numbers = [1, 2, 3, 4];\nconst numberStream = Stream.fromIterable(numbers); // Stream<number>\n\n// Stream: Create a stream from any iterable\nfunction* gen() {\n  yield \"a\";\n  yield \"b\";\n}\nconst letterStream = Stream.fromIterable(gen()); // Stream<string>\n\n// Effect: Create an effect from an array of effects (batch)\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst batchEffect = Effect.all(effects); // Effect<[1, 2]>\n```\n\n**Explanation:**  \n- `Stream.fromIterable` creates a stream from any array or iterable, enabling streaming and batch operations.\n- `Effect.all` (covered elsewhere) can be used to process arrays of effects in batch.\n\n## Anti-Pattern\n\nManually looping over collections and running effects or streams imperatively, which loses composability, error handling, and resource safety."
  },
  {
    "id": "constructor-sync-async",
    "title": "Creating from Synchronous and Callback Code",
    "description": "Use sync and async to create Effects from synchronous or callback-based computations, making them composable and type-safe.",
    "skillLevel": "beginner",
    "useCases": [
      "concurrency"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Synchronous: Wrap a computation that is guaranteed not to throw\nconst effectSync = Effect.sync(() => Math.random()); // Effect<never, number, never>\n\n// Callback-based: Wrap a Node.js-style callback API\nfunction legacyReadFile(\n  path: string,\n  cb: (err: Error | null, data?: string) => void\n) {\n  setTimeout(() => cb(null, \"file contents\"), 10);\n}\n\nconst effectAsync = Effect.async<string, Error>((resume) => {\n  legacyReadFile(\"file.txt\", (err, data) => {\n    if (err) resume(Effect.fail(err));\n    else if (data) resume(Effect.succeed(data));\n  });\n}); // Effect<string, Error, never>\n\n```\n\n**Explanation:**  \n- `Effect.sync` is for synchronous computations that are guaranteed not to throw.\n- `Effect.async` is for integrating callback-based APIs, converting them into Effects.",
    "antiPattern": "Directly calling synchronous or callback-based APIs inside Effects without lifting them, which can break composability and error handling.",
    "explanation": "Many APIs are synchronous or use callbacks instead of Promises.  \nBy lifting them into Effects, you gain access to all of Effect's combinators, error handling, and resource safety.",
    "content": "# Creating from Synchronous and Callback Code\n\n## Guideline\n\nUse the `sync` and `async` constructors to lift synchronous or callback-based computations into the Effect world.  \nThis enables safe, composable interop with legacy or third-party code that doesn't use Promises or Effects.\n\n## Rationale\n\nMany APIs are synchronous or use callbacks instead of Promises.  \nBy lifting them into Effects, you gain access to all of Effect's combinators, error handling, and resource safety.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Synchronous: Wrap a computation that is guaranteed not to throw\nconst effectSync = Effect.sync(() => Math.random()); // Effect<never, number, never>\n\n// Callback-based: Wrap a Node.js-style callback API\nfunction legacyReadFile(\n  path: string,\n  cb: (err: Error | null, data?: string) => void\n) {\n  setTimeout(() => cb(null, \"file contents\"), 10);\n}\n\nconst effectAsync = Effect.async<string, Error>((resume) => {\n  legacyReadFile(\"file.txt\", (err, data) => {\n    if (err) resume(Effect.fail(err));\n    else if (data) resume(Effect.succeed(data));\n  });\n}); // Effect<string, Error, never>\n\n```\n\n**Explanation:**  \n- `Effect.sync` is for synchronous computations that are guaranteed not to throw.\n- `Effect.async` is for integrating callback-based APIs, converting them into Effects.\n\n## Anti-Pattern\n\nDirectly calling synchronous or callback-based APIs inside Effects without lifting them, which can break composability and error handling."
  },
  {
    "id": "decouple-fibers-with-queue-pubsub",
    "title": "Decouple Fibers with Queues and PubSub",
    "description": "Use Queue for point-to-point work distribution and PubSub for broadcast messaging between fibers.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "A producer fiber adds jobs to a `Queue`, and a worker fiber takes jobs off the queue to process them.\n\n```typescript\nimport { Effect, Queue, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting queue demo...\");\n\n  // Create a bounded queue that can hold a maximum of 10 items.\n  // This prevents memory issues by applying backpressure when the queue is full.\n  // If a producer tries to add to a full queue, it will suspend until space is available.\n  const queue = yield* Queue.bounded<string>(10);\n  yield* Effect.logInfo(\"Created bounded queue\");\n\n  // Producer Fiber: Add a job to the queue every second.\n  // This fiber runs independently and continuously produces work items.\n  // The producer-consumer pattern decouples work generation from work processing.\n  const producer = yield* Effect.gen(function* () {\n    let i = 0;\n    while (true) {\n      const job = `job-${i++}`;\n      yield* Effect.logInfo(`Producing ${job}...`);\n\n      // Queue.offer adds an item to the queue. If the queue is full,\n      // this operation will suspend the fiber until space becomes available.\n      // This provides natural backpressure control.\n      yield* Queue.offer(queue, job);\n\n      // Sleep for 500ms between job creation. This controls the production rate.\n      // Producer is faster than consumer (500ms vs 1000ms) to demonstrate queue buffering.\n      yield* Effect.sleep(\"500 millis\");\n    }\n  }).pipe(Effect.fork); // Fork creates a new fiber that runs concurrently\n\n  yield* Effect.logInfo(\"Started producer fiber\");\n\n  // Worker Fiber: Take a job from the queue and process it.\n  // This fiber runs independently and processes work items as they become available.\n  // Multiple workers could be created to scale processing capacity.\n  const worker = yield* Effect.gen(function* () {\n    while (true) {\n      // Queue.take removes and returns an item from the queue.\n      // If the queue is empty, this operation will suspend the fiber\n      // until an item becomes available. This prevents busy-waiting.\n      const job = yield* Queue.take(queue);\n      yield* Effect.logInfo(`Processing ${job}...`);\n\n      // Simulate work by sleeping for 1 second.\n      // This makes the worker slower than the producer, causing queue buildup.\n      yield* Effect.sleep(\"1 second\");\n      yield* Effect.logInfo(`Completed ${job}`);\n    }\n  }).pipe(Effect.fork); // Fork creates another independent fiber\n\n  yield* Effect.logInfo(\"Started worker fiber\");\n\n  // Let them run for a while...\n  // The main fiber sleeps while the producer and worker fibers run concurrently.\n  // During this time, you'll see the queue acting as a buffer between\n  // the fast producer and slow worker.\n  yield* Effect.logInfo(\"Running for 10 seconds...\");\n  yield* Effect.sleep(\"10 seconds\");\n  yield* Effect.logInfo(\"Done!\");\n\n  // Interrupt both fibers to clean up resources.\n  // Fiber.interrupt sends an interruption signal to the fiber,\n  // allowing it to perform cleanup operations before terminating.\n  // This is safer than forcefully killing fibers.\n  yield* Fiber.interrupt(producer);\n  yield* Fiber.interrupt(worker);\n\n  // Note: In a real application, you might want to:\n  // 1. Drain the queue before interrupting workers\n  // 2. Use Fiber.join to wait for graceful shutdown\n  // 3. Handle interruption signals in the fiber loops\n});\n\n// Run the program\n// This demonstrates the producer-consumer pattern with Effect fibers:\n// - Fibers are lightweight threads that can be created in large numbers\n// - Queues provide safe communication between fibers\n// - Backpressure prevents resource exhaustion\n// - Interruption allows for graceful shutdown\nEffect.runPromise(program);\n\n```\n\n\nA publisher sends an event, and multiple subscribers react to it independently.\n\n```typescript\nimport { Effect, PubSub } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  const pubsub = yield* PubSub.bounded<string>(10);\n\n  // Subscriber 1: The \"Audit\" service\n  const auditSub = PubSub.subscribe(pubsub).pipe(\n    Effect.flatMap((subscription) =>\n      Effect.gen(function* () {\n        while (true) {\n          const event = yield* Queue.take(subscription);\n          yield* Effect.log(`AUDIT: Received event: ${event}`);\n        }\n      }),\n    ),\n    Effect.fork,\n  );\n\n  // Subscriber 2: The \"Notifier\" service\n  const notifierSub = PubSub.subscribe(pubsub).pipe(\n    Effect.flatMap((subscription) =>\n      Effect.gen(function* () {\n        while (true) {\n          const event = yield* Queue.take(subscription);\n          yield* Effect.log(`NOTIFIER: Sending notification for: ${event}`);\n        }\n      }),\n    ),\n    Effect.fork,\n  );\n\n  // Give subscribers time to start\n  yield* Effect.sleep(\"1 second\");\n\n  // Publisher: Publish an event that both subscribers will receive.\n  yield* PubSub.publish(pubsub, \"user_logged_in\");\n});\n```\n\n---",
    "antiPattern": "Simulating a queue with a simple `Ref<A[]>`. This approach is inefficient due to polling and is not safe from race conditions without manual, complex locking mechanisms. It also lacks critical features like back-pressure.\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\n// ‚ùå WRONG: This is inefficient and prone to race conditions.\nconst program = Effect.gen(function* () {\n  const queueRef = yield* Ref.make<string[]>([]);\n\n  // Producer adds to the array\n  const producer = Ref.update(queueRef, (q) => [...q, \"new_item\"]);\n\n  // Consumer has to constantly poll the array to see if it's empty.\n  const consumer = Ref.get(queueRef).pipe(\n    Effect.flatMap((q) =>\n      q.length > 0\n        ? Ref.set(queueRef, q.slice(1)).pipe(Effect.as(q[0]))\n        : Effect.sleep(\"1 second\").pipe(Effect.flatMap(() => consumer)), // Inefficient polling\n    ),\n  );\n});\n```",
    "explanation": "Directly calling functions between different logical parts of a concurrent application creates tight coupling, making the system brittle and hard to scale. `Queue` and `PubSub` solve this by acting as asynchronous, fiber-safe message brokers.\n\nThis decouples the **producer** of a message from its **consumer(s)**. The producer doesn't need to know who is listening, or how many listeners there are. This allows you to build resilient, scalable systems where you can add or remove workers/listeners without changing the producer's code.\n\nFurthermore, bounded `Queue`s and `PubSub`s provide automatic **back-pressure**. If consumers can't keep up, the producer will automatically pause before adding new items, preventing your system from becoming overloaded.\n\n---",
    "content": "## Guideline\n\nTo enable communication between independent, concurrent fibers, use one of Effect's specialized data structures:\n-   **``Queue<A>``**: For distributing work items. Each item put on the queue is taken and processed by only **one** consumer.\n-   **``PubSub<A>``**: For broadcasting events. Each message published is delivered to **every** subscriber.\n\n---\n\n## Rationale\n\nDirectly calling functions between different logical parts of a concurrent application creates tight coupling, making the system brittle and hard to scale. `Queue` and `PubSub` solve this by acting as asynchronous, fiber-safe message brokers.\n\nThis decouples the **producer** of a message from its **consumer(s)**. The producer doesn't need to know who is listening, or how many listeners there are. This allows you to build resilient, scalable systems where you can add or remove workers/listeners without changing the producer's code.\n\nFurthermore, bounded `Queue`s and `PubSub`s provide automatic **back-pressure**. If consumers can't keep up, the producer will automatically pause before adding new items, preventing your system from becoming overloaded.\n\n---\n\n## Good Example 1: `Queue` for a Work Pool\n\nA producer fiber adds jobs to a `Queue`, and a worker fiber takes jobs off the queue to process them.\n\n```typescript\nimport { Effect, Queue, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting queue demo...\");\n\n  // Create a bounded queue that can hold a maximum of 10 items.\n  // This prevents memory issues by applying backpressure when the queue is full.\n  // If a producer tries to add to a full queue, it will suspend until space is available.\n  const queue = yield* Queue.bounded<string>(10);\n  yield* Effect.logInfo(\"Created bounded queue\");\n\n  // Producer Fiber: Add a job to the queue every second.\n  // This fiber runs independently and continuously produces work items.\n  // The producer-consumer pattern decouples work generation from work processing.\n  const producer = yield* Effect.gen(function* () {\n    let i = 0;\n    while (true) {\n      const job = `job-${i++}`;\n      yield* Effect.logInfo(`Producing ${job}...`);\n\n      // Queue.offer adds an item to the queue. If the queue is full,\n      // this operation will suspend the fiber until space becomes available.\n      // This provides natural backpressure control.\n      yield* Queue.offer(queue, job);\n\n      // Sleep for 500ms between job creation. This controls the production rate.\n      // Producer is faster than consumer (500ms vs 1000ms) to demonstrate queue buffering.\n      yield* Effect.sleep(\"500 millis\");\n    }\n  }).pipe(Effect.fork); // Fork creates a new fiber that runs concurrently\n\n  yield* Effect.logInfo(\"Started producer fiber\");\n\n  // Worker Fiber: Take a job from the queue and process it.\n  // This fiber runs independently and processes work items as they become available.\n  // Multiple workers could be created to scale processing capacity.\n  const worker = yield* Effect.gen(function* () {\n    while (true) {\n      // Queue.take removes and returns an item from the queue.\n      // If the queue is empty, this operation will suspend the fiber\n      // until an item becomes available. This prevents busy-waiting.\n      const job = yield* Queue.take(queue);\n      yield* Effect.logInfo(`Processing ${job}...`);\n\n      // Simulate work by sleeping for 1 second.\n      // This makes the worker slower than the producer, causing queue buildup.\n      yield* Effect.sleep(\"1 second\");\n      yield* Effect.logInfo(`Completed ${job}`);\n    }\n  }).pipe(Effect.fork); // Fork creates another independent fiber\n\n  yield* Effect.logInfo(\"Started worker fiber\");\n\n  // Let them run for a while...\n  // The main fiber sleeps while the producer and worker fibers run concurrently.\n  // During this time, you'll see the queue acting as a buffer between\n  // the fast producer and slow worker.\n  yield* Effect.logInfo(\"Running for 10 seconds...\");\n  yield* Effect.sleep(\"10 seconds\");\n  yield* Effect.logInfo(\"Done!\");\n\n  // Interrupt both fibers to clean up resources.\n  // Fiber.interrupt sends an interruption signal to the fiber,\n  // allowing it to perform cleanup operations before terminating.\n  // This is safer than forcefully killing fibers.\n  yield* Fiber.interrupt(producer);\n  yield* Fiber.interrupt(worker);\n\n  // Note: In a real application, you might want to:\n  // 1. Drain the queue before interrupting workers\n  // 2. Use Fiber.join to wait for graceful shutdown\n  // 3. Handle interruption signals in the fiber loops\n});\n\n// Run the program\n// This demonstrates the producer-consumer pattern with Effect fibers:\n// - Fibers are lightweight threads that can be created in large numbers\n// - Queues provide safe communication between fibers\n// - Backpressure prevents resource exhaustion\n// - Interruption allows for graceful shutdown\nEffect.runPromise(program);\n\n```\n\n## Good Example 2: `PubSub` for Event Broadcasting\n\nA publisher sends an event, and multiple subscribers react to it independently.\n\n```typescript\nimport { Effect, PubSub } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  const pubsub = yield* PubSub.bounded<string>(10);\n\n  // Subscriber 1: The \"Audit\" service\n  const auditSub = PubSub.subscribe(pubsub).pipe(\n    Effect.flatMap((subscription) =>\n      Effect.gen(function* () {\n        while (true) {\n          const event = yield* Queue.take(subscription);\n          yield* Effect.log(`AUDIT: Received event: ${event}`);\n        }\n      }),\n    ),\n    Effect.fork,\n  );\n\n  // Subscriber 2: The \"Notifier\" service\n  const notifierSub = PubSub.subscribe(pubsub).pipe(\n    Effect.flatMap((subscription) =>\n      Effect.gen(function* () {\n        while (true) {\n          const event = yield* Queue.take(subscription);\n          yield* Effect.log(`NOTIFIER: Sending notification for: ${event}`);\n        }\n      }),\n    ),\n    Effect.fork,\n  );\n\n  // Give subscribers time to start\n  yield* Effect.sleep(\"1 second\");\n\n  // Publisher: Publish an event that both subscribers will receive.\n  yield* PubSub.publish(pubsub, \"user_logged_in\");\n});\n```\n\n---\n\n## Anti-Pattern\n\nSimulating a queue with a simple `Ref<A[]>`. This approach is inefficient due to polling and is not safe from race conditions without manual, complex locking mechanisms. It also lacks critical features like back-pressure.\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\n// ‚ùå WRONG: This is inefficient and prone to race conditions.\nconst program = Effect.gen(function* () {\n  const queueRef = yield* Ref.make<string[]>([]);\n\n  // Producer adds to the array\n  const producer = Ref.update(queueRef, (q) => [...q, \"new_item\"]);\n\n  // Consumer has to constantly poll the array to see if it's empty.\n  const consumer = Ref.get(queueRef).pipe(\n    Effect.flatMap((q) =>\n      q.length > 0\n        ? Ref.set(queueRef, q.slice(1)).pipe(Effect.as(q[0]))\n        : Effect.sleep(\"1 second\").pipe(Effect.flatMap(() => consumer)), // Inefficient polling\n    ),\n  );\n});\n```"
  },
  {
    "id": "define-config-schema",
    "title": "Define a Type-Safe Configuration Schema",
    "description": "Define a type-safe configuration schema.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Config, Effect, ConfigProvider, Layer } from \"effect\"\n\nconst ServerConfig = Config.nested(\"SERVER\")(\n  Config.all({\n    host: Config.string(\"HOST\"),\n    port: Config.number(\"PORT\"),\n  })\n)\n\n// Example program that uses the config\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig\n  yield* Effect.logInfo(`Server config loaded: ${JSON.stringify(config)}`)\n})\n\n// Create a config provider with test values\nconst TestConfig = ConfigProvider.fromMap(\n  new Map([\n    [\"SERVER.HOST\", \"localhost\"],\n    [\"SERVER.PORT\", \"3000\"]\n  ])\n)\n\n// Run with test config\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Layer.setConfigProvider(TestConfig)\n  )\n)\n```\n\n**Explanation:**  \nThis schema ensures that both `host` and `port` are present and properly typed, and that their source is clearly defined.",
    "antiPattern": "Directly accessing `process.env`. This is not type-safe, scatters configuration access throughout your codebase, and can lead to parsing errors or `undefined` values.",
    "explanation": "This creates a single, type-safe source of truth for your configuration, eliminating runtime errors from missing or malformed environment variables and making the required configuration explicit.",
    "content": "# Define a Type-Safe Configuration Schema\n\n## Guideline\n\nDefine all external configuration values your application needs using the schema-building functions from `Effect.Config`, such as `Config.string` and `Config.number`.\n\n## Rationale\n\nThis creates a single, type-safe source of truth for your configuration, eliminating runtime errors from missing or malformed environment variables and making the required configuration explicit.\n\n## Good Example\n\n```typescript\nimport { Config, Effect, ConfigProvider, Layer } from \"effect\"\n\nconst ServerConfig = Config.nested(\"SERVER\")(\n  Config.all({\n    host: Config.string(\"HOST\"),\n    port: Config.number(\"PORT\"),\n  })\n)\n\n// Example program that uses the config\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig\n  yield* Effect.logInfo(`Server config loaded: ${JSON.stringify(config)}`)\n})\n\n// Create a config provider with test values\nconst TestConfig = ConfigProvider.fromMap(\n  new Map([\n    [\"SERVER.HOST\", \"localhost\"],\n    [\"SERVER.PORT\", \"3000\"]\n  ])\n)\n\n// Run with test config\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Layer.setConfigProvider(TestConfig)\n  )\n)\n```\n\n**Explanation:**  \nThis schema ensures that both `host` and `port` are present and properly typed, and that their source is clearly defined.\n\n## Anti-Pattern\n\nDirectly accessing `process.env`. This is not type-safe, scatters configuration access throughout your codebase, and can lead to parsing errors or `undefined` values."
  },
  {
    "id": "define-contracts-with-schema",
    "title": "Define Contracts Upfront with Schema",
    "description": "Define contracts upfront with schema.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Schema, Effect, Data } from \"effect\"\n\n// Define User schema and type\nconst UserSchema = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String\n})\n\ntype User = Schema.Schema.Type<typeof UserSchema>\n\n// Define error type\nclass UserNotFound extends Data.TaggedError(\"UserNotFound\")<{\n  readonly id: number\n}> {}\n\n// Create database service implementation\nexport class Database extends Effect.Service<Database>()(\n  \"Database\",\n  {\n    sync: () => ({\n      getUser: (id: number) =>\n        id === 1\n          ? Effect.succeed({ id: 1, name: \"John\" })\n          : Effect.fail(new UserNotFound({ id }))\n    })\n  }\n) {}\n\n// Create a program that demonstrates schema and error handling\nconst program = Effect.gen(function* () {\n  const db = yield* Database\n  \n  // Try to get an existing user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  const user1 = yield* db.getUser(1)\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user1)}`)\n  \n  // Try to get a non-existent user\n  yield* Effect.logInfo(\"\\nLooking up user 999...\")\n  yield* Effect.logInfo(\"Attempting to get user 999...\")\n  yield* Effect.gen(function* () {\n    const user = yield* db.getUser(999)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) => {\n      if (error instanceof UserNotFound) {\n        return Effect.logInfo(`Error: User with id ${error.id} not found`)\n      }\n      return Effect.logInfo(`Unexpected error: ${error}`)\n    })\n  )\n\n  // Try to decode invalid data\n  yield* Effect.logInfo(\"\\nTrying to decode invalid user data...\")\n  const invalidUser = { id: \"not-a-number\", name: 123 } as any\n  yield* Effect.gen(function* () {\n    const user = yield* Schema.decode(UserSchema)(invalidUser)\n    yield* Effect.logInfo(`Decoded user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Validation failed:\\n${JSON.stringify(error, null, 2)}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Database.Default)\n)\n```\n\n**Explanation:**  \nDefining schemas upfront clarifies your contracts and ensures both type safety\nand runtime validation.",
    "antiPattern": "Defining logic with implicit `any` types first and adding validation later as\nan afterthought. This leads to brittle code that lacks a clear contract.",
    "explanation": "This \"schema-first\" approach separates the \"what\" (the data shape) from the\n\"how\" (the implementation). It provides a single source of truth for both\ncompile-time static types and runtime validation.",
    "content": "# Define Contracts Upfront with Schema\n\n## Guideline\n\nBefore writing implementation logic, define the shape of your data models and\nfunction signatures using `Effect/Schema`.\n\n## Rationale\n\nThis \"schema-first\" approach separates the \"what\" (the data shape) from the\n\"how\" (the implementation). It provides a single source of truth for both\ncompile-time static types and runtime validation.\n\n## Good Example\n\n```typescript\nimport { Schema, Effect, Data } from \"effect\"\n\n// Define User schema and type\nconst UserSchema = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String\n})\n\ntype User = Schema.Schema.Type<typeof UserSchema>\n\n// Define error type\nclass UserNotFound extends Data.TaggedError(\"UserNotFound\")<{\n  readonly id: number\n}> {}\n\n// Create database service implementation\nexport class Database extends Effect.Service<Database>()(\n  \"Database\",\n  {\n    sync: () => ({\n      getUser: (id: number) =>\n        id === 1\n          ? Effect.succeed({ id: 1, name: \"John\" })\n          : Effect.fail(new UserNotFound({ id }))\n    })\n  }\n) {}\n\n// Create a program that demonstrates schema and error handling\nconst program = Effect.gen(function* () {\n  const db = yield* Database\n  \n  // Try to get an existing user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  const user1 = yield* db.getUser(1)\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user1)}`)\n  \n  // Try to get a non-existent user\n  yield* Effect.logInfo(\"\\nLooking up user 999...\")\n  yield* Effect.logInfo(\"Attempting to get user 999...\")\n  yield* Effect.gen(function* () {\n    const user = yield* db.getUser(999)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) => {\n      if (error instanceof UserNotFound) {\n        return Effect.logInfo(`Error: User with id ${error.id} not found`)\n      }\n      return Effect.logInfo(`Unexpected error: ${error}`)\n    })\n  )\n\n  // Try to decode invalid data\n  yield* Effect.logInfo(\"\\nTrying to decode invalid user data...\")\n  const invalidUser = { id: \"not-a-number\", name: 123 } as any\n  yield* Effect.gen(function* () {\n    const user = yield* Schema.decode(UserSchema)(invalidUser)\n    yield* Effect.logInfo(`Decoded user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Validation failed:\\n${JSON.stringify(error, null, 2)}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Database.Default)\n)\n```\n\n**Explanation:**  \nDefining schemas upfront clarifies your contracts and ensures both type safety\nand runtime validation.\n\n## Anti-Pattern\n\nDefining logic with implicit `any` types first and adding validation later as\nan afterthought. This leads to brittle code that lacks a clear contract."
  },
  {
    "id": "define-tagged-errors",
    "title": "Define Type-Safe Errors with Data.TaggedError",
    "description": "Define type-safe errors with Data.TaggedError.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data, Effect } from \"effect\"\n\n// Define our tagged error type\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly cause: unknown\n}> {}\n\n// Function that simulates a database error\nconst findUser = (id: number): Effect.Effect<{ id: number; name: string }, DatabaseError> =>\n  Effect.gen(function* () {\n    if (id < 0) {\n      return yield* Effect.fail(new DatabaseError({ cause: \"Invalid ID\" }))\n    }\n    return { id, name: `User ${id}` }\n  })\n\n// Create a program that demonstrates error handling\nconst program = Effect.gen(function* () {\n  // Try to find a valid user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Error finding user: ${error._tag} - ${error.cause}`)\n    )\n  )\n\n  // Try to find an invalid user\n  yield* Effect.logInfo(\"\\nLooking up user -1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(-1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchTag(\"DatabaseError\", (error) =>\n      Effect.logInfo(`Database error: ${error._tag} - ${error.cause}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n**Explanation:**  \nTagged errors allow you to handle errors in a type-safe, self-documenting way.",
    "antiPattern": "Using generic `Error` objects or strings in the error channel. This loses all\ntype information, forcing consumers to use `catchAll` and perform unsafe\nchecks.",
    "explanation": "This gives each error a unique, literal `_tag` that Effect can use for type\ndiscrimination with `Effect.catchTag`, making your error handling fully\ntype-safe.",
    "content": "# Define Type-Safe Errors with Data.TaggedError\n\n## Guideline\n\nFor any distinct failure mode in your application, define a custom error class\nthat extends `Data.TaggedError`.\n\n## Rationale\n\nThis gives each error a unique, literal `_tag` that Effect can use for type\ndiscrimination with `Effect.catchTag`, making your error handling fully\ntype-safe.\n\n## Good Example\n\n```typescript\nimport { Data, Effect } from \"effect\"\n\n// Define our tagged error type\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly cause: unknown\n}> {}\n\n// Function that simulates a database error\nconst findUser = (id: number): Effect.Effect<{ id: number; name: string }, DatabaseError> =>\n  Effect.gen(function* () {\n    if (id < 0) {\n      return yield* Effect.fail(new DatabaseError({ cause: \"Invalid ID\" }))\n    }\n    return { id, name: `User ${id}` }\n  })\n\n// Create a program that demonstrates error handling\nconst program = Effect.gen(function* () {\n  // Try to find a valid user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Error finding user: ${error._tag} - ${error.cause}`)\n    )\n  )\n\n  // Try to find an invalid user\n  yield* Effect.logInfo(\"\\nLooking up user -1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(-1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchTag(\"DatabaseError\", (error) =>\n      Effect.logInfo(`Database error: ${error._tag} - ${error.cause}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n**Explanation:**  \nTagged errors allow you to handle errors in a type-safe, self-documenting way.\n\n## Anti-Pattern\n\nUsing generic `Error` objects or strings in the error channel. This loses all\ntype information, forcing consumers to use `catchAll` and perform unsafe\nchecks."
  },
  {
    "id": "distinguish-not-found-from-errors",
    "title": "Distinguish 'Not Found' from Errors",
    "description": "Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "This function to find a user can fail if the database is down, or it can succeed but find no user. The return type ``Effect.Effect<Option.Option<User>, DatabaseError>`` makes this contract perfectly clear.\n\n````typescript\nimport { Effect, Option, Data } from \"effect\"\n\ninterface User {\n  id: number\n  name: string\n}\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\") {}\n\n// This signature is extremely honest about its possible outcomes.\nconst findUserInDb = (\n  id: number\n): Effect.Effect<Option.Option<User>, DatabaseError> =>\n  Effect.gen(function* () {\n    // This could fail with a DatabaseError\n    const dbResult = yield* Effect.try({\n      try: () => (id === 1 ? { id: 1, name: \"Paul\" } : null),\n      catch: () => new DatabaseError()\n    })\n\n    // We wrap the potentially null result in an Option\n    return Option.fromNullable(dbResult)\n  })\n\n// The caller can now handle all three cases explicitly.\nconst program = (id: number) =>\n  findUserInDb(id).pipe(\n    Effect.flatMap((maybeUser) =>\n      Option.match(maybeUser, {\n        onNone: () =>\n          Effect.logInfo(`Result: User with ID ${id} was not found.`),\n        onSome: (user) =>\n          Effect.logInfo(`Result: Found user ${user.name}.`)\n      })\n    ),\n    Effect.catchAll((error) =>\n      Effect.logInfo(\"Error: Could not connect to the database.\")\n    )\n  )\n\n// Run the program with different IDs\nEffect.runPromise(\n  Effect.gen(function* () {\n    // Try with existing user\n    yield* Effect.logInfo(\"Looking for user with ID 1...\")\n    yield* program(1)\n\n    // Try with non-existent user\n    yield* Effect.logInfo(\"\\nLooking for user with ID 2...\")\n    yield* program(2)\n  })\n)\n````",
    "antiPattern": "A common alternative is to create a specific NotFoundError and put it in the error channel alongside other errors.\n\n````typescript\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\t\n\t// ‚ùå This signature conflates two different kinds of failure.\n\tconst findUserUnsafely = (\n\t  id: number,\n\t): Effect.Effect<User, DatabaseError | NotFoundError> => {\n\t  // ...\n\t  return Effect.fail(new NotFoundError());\n\t};\n````\n\nWhile this works, it can be less expressive. It treats a \"not found\" result‚Äîwhich might be a normal part of your application's flow‚Äîthe same as a catastrophic DatabaseError. \n\nUsing ````Effect<Option<A>>```` often leads to clearer and more precise business logic.",
    "explanation": "This pattern provides a precise way to handle three distinct outcomes of an operation:\n\n1.  **Success with a value:** `Effect.succeed(Option.some(value))`\n2.  **Success with no value:** `Effect.succeed(Option.none())` (e.g., user not found)\n3.  **Failure:** `Effect.fail(new DatabaseError())` (e.g., database connection lost)\n\nBy using `Option` inside the success channel of an `Effect`, you keep the error channel clean for true, unexpected, or unrecoverable errors. The \"not found\" case is often an expected and recoverable part of your business logic, and `Option.none()` models this perfectly.\n\n---",
    "content": "## Guideline\n\nWhen a computation can fail (e.g., a network error) or succeed but find nothing, model its return type as ``Effect<Option<A>>``. This separates the \"hard failure\" channel from the \"soft failure\" (or empty) channel.\n\n---\n\n## Rationale\n\nThis pattern provides a precise way to handle three distinct outcomes of an operation:\n\n1.  **Success with a value:** `Effect.succeed(Option.some(value))`\n2.  **Success with no value:** `Effect.succeed(Option.none())` (e.g., user not found)\n3.  **Failure:** `Effect.fail(new DatabaseError())` (e.g., database connection lost)\n\nBy using `Option` inside the success channel of an `Effect`, you keep the error channel clean for true, unexpected, or unrecoverable errors. The \"not found\" case is often an expected and recoverable part of your business logic, and `Option.none()` models this perfectly.\n\n---\n\n## Good Example\n\nThis function to find a user can fail if the database is down, or it can succeed but find no user. The return type ``Effect.Effect<Option.Option<User>, DatabaseError>`` makes this contract perfectly clear.\n\n````typescript\nimport { Effect, Option, Data } from \"effect\"\n\ninterface User {\n  id: number\n  name: string\n}\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\") {}\n\n// This signature is extremely honest about its possible outcomes.\nconst findUserInDb = (\n  id: number\n): Effect.Effect<Option.Option<User>, DatabaseError> =>\n  Effect.gen(function* () {\n    // This could fail with a DatabaseError\n    const dbResult = yield* Effect.try({\n      try: () => (id === 1 ? { id: 1, name: \"Paul\" } : null),\n      catch: () => new DatabaseError()\n    })\n\n    // We wrap the potentially null result in an Option\n    return Option.fromNullable(dbResult)\n  })\n\n// The caller can now handle all three cases explicitly.\nconst program = (id: number) =>\n  findUserInDb(id).pipe(\n    Effect.flatMap((maybeUser) =>\n      Option.match(maybeUser, {\n        onNone: () =>\n          Effect.logInfo(`Result: User with ID ${id} was not found.`),\n        onSome: (user) =>\n          Effect.logInfo(`Result: Found user ${user.name}.`)\n      })\n    ),\n    Effect.catchAll((error) =>\n      Effect.logInfo(\"Error: Could not connect to the database.\")\n    )\n  )\n\n// Run the program with different IDs\nEffect.runPromise(\n  Effect.gen(function* () {\n    // Try with existing user\n    yield* Effect.logInfo(\"Looking for user with ID 1...\")\n    yield* program(1)\n\n    // Try with non-existent user\n    yield* Effect.logInfo(\"\\nLooking for user with ID 2...\")\n    yield* program(2)\n  })\n)\n````\n\n## Anti-Pattern\n\nA common alternative is to create a specific NotFoundError and put it in the error channel alongside other errors.\n\n````typescript\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\t\n\t// ‚ùå This signature conflates two different kinds of failure.\n\tconst findUserUnsafely = (\n\t  id: number,\n\t): Effect.Effect<User, DatabaseError | NotFoundError> => {\n\t  // ...\n\t  return Effect.fail(new NotFoundError());\n\t};\n````\n\nWhile this works, it can be less expressive. It treats a \"not found\" result‚Äîwhich might be a normal part of your application's flow‚Äîthe same as a catastrophic DatabaseError. \n\nUsing ````Effect<Option<A>>```` often leads to clearer and more precise business logic."
  },
  {
    "id": "pattern-matcheffect",
    "title": "Effectful Pattern Matching with matchEffect",
    "description": "Use matchEffect to pattern match on the result of an Effect, running effectful logic for both success and failure cases.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Effect: Run different Effects on success or failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.matchEffect({\n    onFailure: (err) => Effect.logError(`Error: ${err}`),\n    onSuccess: (value) => Effect.log(`Success: ${value}`),\n  })\n); // Effect<void>\n```\n\n**Explanation:**  \n- `matchEffect` allows you to run an Effect for both the success and failure cases.\n- This is useful for logging, cleanup, retries, or any effectful side effect that depends on the outcome.",
    "antiPattern": "Using `match` to return values and then wrapping them in Effects, or duplicating logic for side effects, instead of using `matchEffect` for direct effectful branching.",
    "explanation": "Sometimes, handling a success or failure requires running additional Effects (e.g., logging, retries, cleanup).  \n`matchEffect` lets you do this declaratively, keeping your code composable and type-safe.",
    "content": "# Effectful Pattern Matching with `matchEffect`\n\n## Guideline\n\nUse the `matchEffect` combinator to perform effectful branching based on whether an Effect succeeds or fails.  \nThis allows you to run different Effects for each case, enabling rich, composable workflows.\n\n## Rationale\n\nSometimes, handling a success or failure requires running additional Effects (e.g., logging, retries, cleanup).  \n`matchEffect` lets you do this declaratively, keeping your code composable and type-safe.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Effect: Run different Effects on success or failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.matchEffect({\n    onFailure: (err) => Effect.logError(`Error: ${err}`),\n    onSuccess: (value) => Effect.log(`Success: ${value}`),\n  })\n); // Effect<void>\n```\n\n**Explanation:**  \n- `matchEffect` allows you to run an Effect for both the success and failure cases.\n- This is useful for logging, cleanup, retries, or any effectful side effect that depends on the outcome.\n\n## Anti-Pattern\n\nUsing `match` to return values and then wrapping them in Effects, or duplicating logic for side effects, instead of using `matchEffect` for direct effectful branching."
  },
  {
    "id": "execute-with-runpromise",
    "title": "Execute Asynchronous Effects with Effect.runPromise",
    "description": "Execute asynchronous effects with Effect.runPromise.",
    "skillLevel": "beginner",
    "useCases": [
      "project-setup--execution"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.succeed(\"Hello, World!\").pipe(\n  Effect.delay(\"1 second\"),\n);\n\nconst promise = Effect.runPromise(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(result); // Logs \"Hello, World!\" after 1 second.\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \n`Effect.runPromise` executes your effect and returns a Promise, making it\neasy to integrate with existing JavaScript async workflows.",
    "antiPattern": "Never call `runPromise` inside another `Effect` composition. Effects are\nmeant to be composed together *before* being run once at the end.",
    "explanation": "`Effect.runPromise` is the bridge from the Effect world to the Promise-based\nworld of Node.js and browsers. If the Effect succeeds, the Promise resolves;\nif it fails, the Promise rejects.",
    "content": "# Execute Asynchronous Effects with Effect.runPromise\n\n## Guideline\n\nTo execute an `Effect` that may be asynchronous and retrieve its result, use\n`Effect.runPromise`. This should only be done at the outermost layer of your\napplication.\n\n## Rationale\n\n`Effect.runPromise` is the bridge from the Effect world to the Promise-based\nworld of Node.js and browsers. If the Effect succeeds, the Promise resolves;\nif it fails, the Promise rejects.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.succeed(\"Hello, World!\").pipe(\n  Effect.delay(\"1 second\"),\n);\n\nconst promise = Effect.runPromise(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(result); // Logs \"Hello, World!\" after 1 second.\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \n`Effect.runPromise` executes your effect and returns a Promise, making it\neasy to integrate with existing JavaScript async workflows.\n\n## Anti-Pattern\n\nNever call `runPromise` inside another `Effect` composition. Effects are\nmeant to be composed together *before* being run once at the end."
  },
  {
    "id": "execute-long-running-apps-with-runfork",
    "title": "Execute Long-Running Apps with Effect.runFork",
    "description": "Use Effect.runFork to launch a long-running application as a manageable, detached fiber.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This example starts a simple \"server\" that runs forever. We use `runFork` to launch it and then use the returned `Fiber` to shut it down gracefully after 5 seconds.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\n// A server that listens for requests forever\nconst server = Effect.log(\"Server received a request.\").pipe(\n  Effect.delay(\"1 second\"),\n  Effect.forever,\n);\n\nEffect.runSync(Effect.log(\"Starting server...\"));\n\n// Launch the server as a detached, top-level fiber\nconst appFiber = Effect.runFork(server);\n\n// In a real app, you would listen for OS signals.\n// Here, we simulate a shutdown signal after 5 seconds.\nsetTimeout(() => {\n  const shutdownProgram = Effect.gen(function* () {\n    yield* Effect.log(\"Shutdown signal received. Interrupting server fiber...\");\n    // This ensures all cleanup logic within the server effect would run.\n    yield* Fiber.interrupt(appFiber);\n  });\n  Effect.runPromise(shutdownProgram);\n}, 5000);\n```\n\n---",
    "antiPattern": "Using `runFork` when you immediately need the result of the effect. If you call `runFork` and then immediately call `Fiber.join` on the result, you have simply implemented a more complex and less direct version of `runPromise`.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst someEffect = Effect.succeed(42);\n\n// ‚ùå WRONG: This is just a complicated way to write `Effect.runPromise(someEffect)`\nconst resultPromise = Effect.runFork(someEffect).pipe(Fiber.join, Effect.runPromise);\n```",
    "explanation": "Unlike `Effect.runPromise`, which waits for the effect to complete, `Effect.runFork` starts the effect and immediately returns a `Fiber`. This is the ideal way to run an application that is meant to run forever, because it gives you a handle to the process.\n\nThe most critical use case for this is enabling graceful shutdown. You can start your application with `runFork`, and then set up listeners for OS signals (like `SIGINT` for Ctrl+C). When a shutdown signal is received, you call `Fiber.interrupt` on the application fiber, which guarantees that all finalizers (like closing database connections) are run before the process exits.\n\n---",
    "content": "## Guideline\n\nTo launch a long-running application (like a server or daemon) as a non-blocking, top-level process, use `Effect.runFork`. It immediately returns a `Fiber` representing your running application, which you can use to manage its lifecycle.\n\n---\n\n## Rationale\n\nUnlike `Effect.runPromise`, which waits for the effect to complete, `Effect.runFork` starts the effect and immediately returns a `Fiber`. This is the ideal way to run an application that is meant to run forever, because it gives you a handle to the process.\n\nThe most critical use case for this is enabling graceful shutdown. You can start your application with `runFork`, and then set up listeners for OS signals (like `SIGINT` for Ctrl+C). When a shutdown signal is received, you call `Fiber.interrupt` on the application fiber, which guarantees that all finalizers (like closing database connections) are run before the process exits.\n\n---\n\n## Good Example\n\nThis example starts a simple \"server\" that runs forever. We use `runFork` to launch it and then use the returned `Fiber` to shut it down gracefully after 5 seconds.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\n// A server that listens for requests forever\nconst server = Effect.log(\"Server received a request.\").pipe(\n  Effect.delay(\"1 second\"),\n  Effect.forever,\n);\n\nEffect.runSync(Effect.log(\"Starting server...\"));\n\n// Launch the server as a detached, top-level fiber\nconst appFiber = Effect.runFork(server);\n\n// In a real app, you would listen for OS signals.\n// Here, we simulate a shutdown signal after 5 seconds.\nsetTimeout(() => {\n  const shutdownProgram = Effect.gen(function* () {\n    yield* Effect.log(\"Shutdown signal received. Interrupting server fiber...\");\n    // This ensures all cleanup logic within the server effect would run.\n    yield* Fiber.interrupt(appFiber);\n  });\n  Effect.runPromise(shutdownProgram);\n}, 5000);\n```\n\n---\n\n## Anti-Pattern\n\nUsing `runFork` when you immediately need the result of the effect. If you call `runFork` and then immediately call `Fiber.join` on the result, you have simply implemented a more complex and less direct version of `runPromise`.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst someEffect = Effect.succeed(42);\n\n// ‚ùå WRONG: This is just a complicated way to write `Effect.runPromise(someEffect)`\nconst resultPromise = Effect.runFork(someEffect).pipe(Fiber.join, Effect.runPromise);\n```"
  },
  {
    "id": "execute-with-runsync",
    "title": "Execute Synchronous Effects with Effect.runSync",
    "description": "Execute synchronous effects with Effect.runSync.",
    "skillLevel": "beginner",
    "useCases": [
      "project-setup--execution"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\"\n\n// Simple synchronous program\nconst program1 = Effect.gen(function* () {\n  const n = 10\n  const result = n * 2\n  yield* Effect.log(`Simple program result: ${result}`)\n  return result\n})\n\n// Run simple program\nEffect.runSync(program1)\n\n// Program with logging\nconst program2 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting calculation...\")\n  const n = yield* Effect.sync(() => 10)\n  yield* Effect.logInfo(`Got number: ${n}`)\n  const result = yield* Effect.sync(() => n * 2)\n  yield* Effect.logInfo(`Result: ${result}`)\n  return result\n})\n\n// Run with logging\nEffect.runSync(program2)\n\n// Program with error handling\nconst program3 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting division...\")\n  const n = yield* Effect.sync(() => 10)\n  const divisor = yield* Effect.sync(() => 0)\n  \n  yield* Effect.logInfo(`Attempting to divide ${n} by ${divisor}...`)\n  return yield* Effect.try({\n    try: () => {\n      if (divisor === 0) throw new Error(\"Cannot divide by zero\")\n      return n / divisor\n    },\n    catch: (error) => {\n      if (error instanceof Error) {\n        return error\n      }\n      return new Error(\"Unknown error occurred\")\n    }\n  })\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.logInfo(`Error occurred: ${error.message}`)\n  )\n)\n\n// Run with error handling\nEffect.runSync(program3)\n```\n\n**Explanation:**  \nUse `runSync` only for Effects that are fully synchronous. If the Effect\ncontains async code, use `runPromise` instead.",
    "antiPattern": "Do not use `runSync` on an Effect that contains asynchronous operations like\n`Effect.delay` or `Effect.promise`. This will result in a runtime error.",
    "explanation": "`Effect.runSync` is an optimized runner for Effects that don't involve any\nasynchronous operations. If the Effect contains any async operations,\n`runSync` will throw an error.",
    "content": "# Execute Synchronous Effects with Effect.runSync\n\n## Guideline\n\nTo execute an `Effect` that is guaranteed to be synchronous, use\n`Effect.runSync`. This will return the success value directly or throw the\nerror.\n\n## Rationale\n\n`Effect.runSync` is an optimized runner for Effects that don't involve any\nasynchronous operations. If the Effect contains any async operations,\n`runSync` will throw an error.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\"\n\n// Simple synchronous program\nconst program1 = Effect.gen(function* () {\n  const n = 10\n  const result = n * 2\n  yield* Effect.log(`Simple program result: ${result}`)\n  return result\n})\n\n// Run simple program\nEffect.runSync(program1)\n\n// Program with logging\nconst program2 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting calculation...\")\n  const n = yield* Effect.sync(() => 10)\n  yield* Effect.logInfo(`Got number: ${n}`)\n  const result = yield* Effect.sync(() => n * 2)\n  yield* Effect.logInfo(`Result: ${result}`)\n  return result\n})\n\n// Run with logging\nEffect.runSync(program2)\n\n// Program with error handling\nconst program3 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting division...\")\n  const n = yield* Effect.sync(() => 10)\n  const divisor = yield* Effect.sync(() => 0)\n  \n  yield* Effect.logInfo(`Attempting to divide ${n} by ${divisor}...`)\n  return yield* Effect.try({\n    try: () => {\n      if (divisor === 0) throw new Error(\"Cannot divide by zero\")\n      return n / divisor\n    },\n    catch: (error) => {\n      if (error instanceof Error) {\n        return error\n      }\n      return new Error(\"Unknown error occurred\")\n    }\n  })\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.logInfo(`Error occurred: ${error.message}`)\n  )\n)\n\n// Run with error handling\nEffect.runSync(program3)\n```\n\n**Explanation:**  \nUse `runSync` only for Effects that are fully synchronous. If the Effect\ncontains async code, use `runPromise` instead.\n\n## Anti-Pattern\n\nDo not use `runSync` on an Effect that contains asynchronous operations like\n`Effect.delay` or `Effect.promise`. This will result in a runtime error."
  },
  {
    "id": "extract-path-parameters",
    "title": "Extract Path Parameters",
    "description": "Define routes with colon-prefixed parameters (e.g., /users/:id) and access their values within the handler.",
    "skillLevel": "beginner",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines a route that captures a `userId`. The handler for this route accesses the parsed parameters and uses the `userId` to construct a personalized greeting. The router automatically makes the parameters available to the handler.\n\n```typescript\nimport { Data, Effect } from 'effect'\n\n// Define tagged error for invalid paths\ninterface InvalidPathErrorSchema {\n  readonly _tag: \"InvalidPathError\"\n  readonly path: string\n}\n\nconst makeInvalidPathError = (path: string): InvalidPathErrorSchema => ({\n  _tag: \"InvalidPathError\",\n  path\n})\n\n// Define service interface\ninterface PathOps {\n  readonly extractUserId: (path: string) => Effect.Effect<string, InvalidPathErrorSchema>\n  readonly greetUser: (userId: string) => Effect.Effect<string>\n}\n\n// Create service\nclass PathService extends Effect.Service<PathService>()(\n  \"PathService\",\n  {\n    sync: () => ({\n      extractUserId: (path: string) =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Attempting to extract user ID from path: ${path}`)\n          \n          const match = path.match(/\\/users\\/([^/]+)/);\n          if (!match) {\n            yield* Effect.logInfo(`No user ID found in path: ${path}`)\n            return yield* Effect.fail(makeInvalidPathError(path))\n          }\n          \n          const userId = match[1];\n          yield* Effect.logInfo(`Successfully extracted user ID: ${userId}`)\n          return userId\n        }),\n\n      greetUser: (userId: string) =>\n        Effect.gen(function* () {\n          const greeting = `Hello, user ${userId}!`\n          yield* Effect.logInfo(greeting)\n          return greeting\n        })\n    })\n  }\n) {}\n\n// Compose the functions with proper error handling\nconst processPath = (path: string): Effect.Effect<string, InvalidPathErrorSchema, PathService> =>\n  Effect.gen(function* () {\n    const pathService = yield* PathService\n    yield* Effect.logInfo(`Processing path: ${path}`)\n    const userId = yield* pathService.extractUserId(path)\n    return yield* pathService.greetUser(userId)\n  })\n\n// Run examples with proper error handling\nconst program = Effect.gen(function* () {\n  // Test valid paths\n  yield* Effect.logInfo(\"=== Testing valid paths ===\")\n  const result1 = yield* processPath('/users/123')\n  yield* Effect.logInfo(`Result 1: ${result1}`)\n  \n  const result2 = yield* processPath('/users/abc')\n  yield* Effect.logInfo(`Result 2: ${result2}`)\n  \n  // Test invalid path\n  yield* Effect.logInfo(\"\\n=== Testing invalid path ===\")\n  const result3 = yield* processPath('/invalid/path').pipe(\n    Effect.catchTag(\"InvalidPathError\", (error) =>\n      Effect.succeed(`Error: Invalid path ${error.path}`)\n    )\n  )\n  yield* Effect.logInfo(result3)\n})\n\nEffect.runPromise(\n  Effect.provide(program, PathService.Default)\n)\n```",
    "antiPattern": "The anti-pattern is to manually parse the URL string inside the handler. This approach is brittle, imperative, and mixes concerns.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// This route matches any sub-path of /users/, forcing manual parsing.\nconst app = Http.router.get(\n  '/users/*', // Using a wildcard\n  Http.request.ServerRequest.pipe(\n    Effect.flatMap((req) => {\n      // Manually split the URL to find the ID.\n      const parts = req.url.split('/'); // e.g., ['', 'users', '123']\n      if (parts.length === 3 && parts[2]) {\n        const userId = parts[2];\n        return Http.response.text(`Hello, user ${userId}!`);\n      }\n      // Manual handling for missing ID.\n      return Http.response.empty({ status: 404 });\n    })\n  )\n);\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual method is highly discouraged. It's fragile‚Äîa change in the base path or an extra slash could break the logic (`parts[2]`). It's also not declarative; the intent is hidden inside imperative code. The router's built-in parameter handling is safer, clearer, and the correct approach.",
    "explanation": "APIs often need to operate on specific resources identified by a unique key in the URL, such as `/products/123` or `/orders/abc`. The `Http.router` provides a clean, declarative way to handle these dynamic paths without resorting to manual string parsing.\n\nBy defining parameters directly in the path string, you gain several benefits:\n\n1.  **Declarative**: The route's structure is immediately obvious from its definition. The code clearly states, \"this route expects a dynamic segment here.\"\n2.  **Safe and Robust**: The router handles the logic of extracting the parameter. This is less error-prone and more robust than manually splitting or using regular expressions on the URL string.\n3.  **Clean Handler Logic**: The business logic inside your handler is separated from the concern of URL parsing. The handler simply receives the parameters it needs to do its job.\n4.  **Composability**: This pattern composes perfectly with the rest of the `Http` module, allowing you to build complex and well-structured APIs.\n\n---",
    "content": "## Guideline\n\nTo capture dynamic parts of a URL, define your route path with a colon-prefixed placeholder (e.g., `/users/:userId`) and access the parsed parameters within your handler `Effect`.\n\n---\n\n## Rationale\n\nAPIs often need to operate on specific resources identified by a unique key in the URL, such as `/products/123` or `/orders/abc`. The `Http.router` provides a clean, declarative way to handle these dynamic paths without resorting to manual string parsing.\n\nBy defining parameters directly in the path string, you gain several benefits:\n\n1.  **Declarative**: The route's structure is immediately obvious from its definition. The code clearly states, \"this route expects a dynamic segment here.\"\n2.  **Safe and Robust**: The router handles the logic of extracting the parameter. This is less error-prone and more robust than manually splitting or using regular expressions on the URL string.\n3.  **Clean Handler Logic**: The business logic inside your handler is separated from the concern of URL parsing. The handler simply receives the parameters it needs to do its job.\n4.  **Composability**: This pattern composes perfectly with the rest of the `Http` module, allowing you to build complex and well-structured APIs.\n\n---\n\n## Good Example\n\nThis example defines a route that captures a `userId`. The handler for this route accesses the parsed parameters and uses the `userId` to construct a personalized greeting. The router automatically makes the parameters available to the handler.\n\n```typescript\nimport { Data, Effect } from 'effect'\n\n// Define tagged error for invalid paths\ninterface InvalidPathErrorSchema {\n  readonly _tag: \"InvalidPathError\"\n  readonly path: string\n}\n\nconst makeInvalidPathError = (path: string): InvalidPathErrorSchema => ({\n  _tag: \"InvalidPathError\",\n  path\n})\n\n// Define service interface\ninterface PathOps {\n  readonly extractUserId: (path: string) => Effect.Effect<string, InvalidPathErrorSchema>\n  readonly greetUser: (userId: string) => Effect.Effect<string>\n}\n\n// Create service\nclass PathService extends Effect.Service<PathService>()(\n  \"PathService\",\n  {\n    sync: () => ({\n      extractUserId: (path: string) =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Attempting to extract user ID from path: ${path}`)\n          \n          const match = path.match(/\\/users\\/([^/]+)/);\n          if (!match) {\n            yield* Effect.logInfo(`No user ID found in path: ${path}`)\n            return yield* Effect.fail(makeInvalidPathError(path))\n          }\n          \n          const userId = match[1];\n          yield* Effect.logInfo(`Successfully extracted user ID: ${userId}`)\n          return userId\n        }),\n\n      greetUser: (userId: string) =>\n        Effect.gen(function* () {\n          const greeting = `Hello, user ${userId}!`\n          yield* Effect.logInfo(greeting)\n          return greeting\n        })\n    })\n  }\n) {}\n\n// Compose the functions with proper error handling\nconst processPath = (path: string): Effect.Effect<string, InvalidPathErrorSchema, PathService> =>\n  Effect.gen(function* () {\n    const pathService = yield* PathService\n    yield* Effect.logInfo(`Processing path: ${path}`)\n    const userId = yield* pathService.extractUserId(path)\n    return yield* pathService.greetUser(userId)\n  })\n\n// Run examples with proper error handling\nconst program = Effect.gen(function* () {\n  // Test valid paths\n  yield* Effect.logInfo(\"=== Testing valid paths ===\")\n  const result1 = yield* processPath('/users/123')\n  yield* Effect.logInfo(`Result 1: ${result1}`)\n  \n  const result2 = yield* processPath('/users/abc')\n  yield* Effect.logInfo(`Result 2: ${result2}`)\n  \n  // Test invalid path\n  yield* Effect.logInfo(\"\\n=== Testing invalid path ===\")\n  const result3 = yield* processPath('/invalid/path').pipe(\n    Effect.catchTag(\"InvalidPathError\", (error) =>\n      Effect.succeed(`Error: Invalid path ${error.path}`)\n    )\n  )\n  yield* Effect.logInfo(result3)\n})\n\nEffect.runPromise(\n  Effect.provide(program, PathService.Default)\n)\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to manually parse the URL string inside the handler. This approach is brittle, imperative, and mixes concerns.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// This route matches any sub-path of /users/, forcing manual parsing.\nconst app = Http.router.get(\n  '/users/*', // Using a wildcard\n  Http.request.ServerRequest.pipe(\n    Effect.flatMap((req) => {\n      // Manually split the URL to find the ID.\n      const parts = req.url.split('/'); // e.g., ['', 'users', '123']\n      if (parts.length === 3 && parts[2]) {\n        const userId = parts[2];\n        return Http.response.text(`Hello, user ${userId}!`);\n      }\n      // Manual handling for missing ID.\n      return Http.response.empty({ status: 404 });\n    })\n  )\n);\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual method is highly discouraged. It's fragile‚Äîa change in the base path or an extra slash could break the logic (`parts[2]`). It's also not declarative; the intent is hidden inside imperative code. The router's built-in parameter handling is safer, clearer, and the correct approach."
  },
  {
    "id": "combinator-filter",
    "title": "Filtering Results with filter",
    "description": "Use filter to declaratively express conditional logic, keeping only values that satisfy a predicate.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Only succeed if the value is even, fail otherwise\nconst effect = Effect.succeed(4).pipe(\n  Effect.filterOrFail(\n    (n): n is number => n % 2 === 0,\n    () => \"Number is not even\"\n  )\n); // Effect<number, string>\n\n// Option: Only keep the value if it is even\nconst option = Option.some(4).pipe(\n  Option.filter((n): n is number => n % 2 === 0)\n); // Option<number>\n\n// Either: Use map and flatMap to filter\nconst either = Either.right(4).pipe(\n  Either.flatMap((n) => \n    n % 2 === 0\n      ? Either.right(n)\n      : Either.left(\"Number is not even\")\n  )\n); // Either<string, number>\n\n// Stream: Only emit even numbers\nconst stream = Stream.fromIterable([1, 2, 3, 4]).pipe(\n  Stream.filter((n): n is number => n % 2 === 0)\n); // Stream<number>\n```\n\n**Explanation:**  \n`filter` applies a predicate to the value(s) inside the structure. If the predicate fails, the result is a failure (`Effect.fail`, `Either.left`), `Option.none`, or an empty stream.",
    "antiPattern": "Using `map` with a conditional that returns `Option` or `Either`, then manually flattening, instead of using `filter`.  \nThis leads to unnecessary complexity and less readable code.",
    "explanation": "`filter` lets you express \"only continue if...\" logic without resorting to manual checks or imperative branching.  \nIt keeps your code composable and type-safe, and ensures that failures or empty results are handled consistently.",
    "content": "# Filtering Results with `filter`\n\n## Guideline\n\nUse the `filter` combinator to keep only those values that satisfy a predicate.  \nThis works for `Effect`, `Stream`, `Option`, and `Either`, allowing you to express conditional logic declaratively and safely.\n\n## Rationale\n\n`filter` lets you express \"only continue if...\" logic without resorting to manual checks or imperative branching.  \nIt keeps your code composable and type-safe, and ensures that failures or empty results are handled consistently.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Only succeed if the value is even, fail otherwise\nconst effect = Effect.succeed(4).pipe(\n  Effect.filterOrFail(\n    (n): n is number => n % 2 === 0,\n    () => \"Number is not even\"\n  )\n); // Effect<number, string>\n\n// Option: Only keep the value if it is even\nconst option = Option.some(4).pipe(\n  Option.filter((n): n is number => n % 2 === 0)\n); // Option<number>\n\n// Either: Use map and flatMap to filter\nconst either = Either.right(4).pipe(\n  Either.flatMap((n) => \n    n % 2 === 0\n      ? Either.right(n)\n      : Either.left(\"Number is not even\")\n  )\n); // Either<string, number>\n\n// Stream: Only emit even numbers\nconst stream = Stream.fromIterable([1, 2, 3, 4]).pipe(\n  Stream.filter((n): n is number => n % 2 === 0)\n); // Stream<number>\n```\n\n**Explanation:**  \n`filter` applies a predicate to the value(s) inside the structure. If the predicate fails, the result is a failure (`Effect.fail`, `Either.left`), `Option.none`, or an empty stream.\n\n## Anti-Pattern\n\nUsing `map` with a conditional that returns `Option` or `Either`, then manually flattening, instead of using `filter`.  \nThis leads to unnecessary complexity and less readable code."
  },
  {
    "id": "handle-get-request",
    "title": "Handle a GET Request",
    "description": "Use Http.router.get to associate a URL path with a specific response Effect.",
    "skillLevel": "beginner",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines two separate GET routes, one for the root path (`/`) and one for `/hello`. We create an empty router and add each route to it. The resulting `app` is then served. The router automatically handles sending a `404 Not Found` response for any path that doesn't match.\n\n```typescript\nimport { Data, Effect } from 'effect'\n\n// Define response types\ninterface RouteResponse {\n  readonly status: number;\n  readonly body: string;\n}\n\n// Define error types\nclass RouteNotFoundError extends Data.TaggedError(\"RouteNotFoundError\")<{\n  readonly path: string;\n}> {}\n\nclass RouteHandlerError extends Data.TaggedError(\"RouteHandlerError\")<{\n  readonly path: string;\n  readonly error: string;\n}> {}\n\n// Define route service\nclass RouteService extends Effect.Service<RouteService>()(\n  \"RouteService\",\n  {\n    sync: () => {\n      // Create instance methods\n      const handleRoute = (path: string): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Processing request for path: ${path}`);\n          \n          try {\n            switch (path) {\n              case '/':\n                const home = 'Welcome to the home page!';\n                yield* Effect.logInfo(`Serving home page`);\n                return { status: 200, body: home };\n\n              case '/hello':\n                const hello = 'Hello, Effect!';\n                yield* Effect.logInfo(`Serving hello page`);\n                return { status: 200, body: hello };\n\n              default:\n                yield* Effect.logWarning(`Route not found: ${path}`);\n                return yield* Effect.fail(new RouteNotFoundError({ path }));\n            }\n          } catch (e) {\n            const error = e instanceof Error ? e.message : String(e);\n            yield* Effect.logError(`Error handling route ${path}: ${error}`);\n            return yield* Effect.fail(new RouteHandlerError({ path, error }));\n          }\n        });\n\n      // Return service implementation\n      return {\n        handleRoute,\n        // Simulate GET request\n        simulateGet: (path: string): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`GET ${path}`);\n            const response = yield* handleRoute(path);\n            yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n            return response;\n          })\n      };\n    }\n  }\n) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const router = yield* RouteService;\n  \n  yield* Effect.logInfo(\"=== Starting Route Tests ===\");\n  \n  // Test different routes\n  for (const path of ['/', '/hello', '/other', '/error']) {\n    yield* Effect.logInfo(`\\n--- Testing ${path} ---`);\n    \n    const result = yield* router.simulateGet(path).pipe(\n      Effect.catchTags({\n        RouteNotFoundError: (error) =>\n          Effect.gen(function* () {\n            const response = { status: 404, body: `Not Found: ${error.path}` };\n            yield* Effect.logWarning(`${response.status} ${response.body}`);\n            return response;\n          }),\n        RouteHandlerError: (error) =>\n          Effect.gen(function* () {\n            const response = { status: 500, body: `Internal Error: ${error.error}` };\n            yield* Effect.logError(`${response.status} ${response.body}`);\n            return response;\n          })\n      })\n    );\n    \n    yield* Effect.logInfo(`Final Response: ${JSON.stringify(result)}`);\n  }\n  \n  yield* Effect.logInfo(\"\\n=== Route Tests Complete ===\");\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, RouteService.Default)\n);\n```",
    "antiPattern": "The anti-pattern is to create a single, monolithic handler that uses conditional logic to inspect the request URL. This imperative approach is difficult to maintain and scale.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// A single app that manually checks the URL\nconst app = Http.request.ServerRequest.pipe(\n  Effect.flatMap((req) => {\n    if (req.url === '/') {\n      return Effect.succeed(Http.response.text('Welcome to the home page!'));\n    } else if (req.url === '/hello') {\n      return Effect.succeed(Http.response.text('Hello, Effect!'));\n    } else {\n      return Effect.succeed(Http.response.empty({ status: 404 }));\n    }\n  })\n);\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual routing logic is verbose, error-prone (a typo in a string breaks the route), and mixes the \"what\" (the response) with the \"where\" (the routing). It doesn't scale to handle different HTTP methods, path parameters, or middleware gracefully. The `Http.router` is designed to solve all of these problems elegantly.",
    "explanation": "A real application needs to respond differently to different URLs. The `Http.router` provides a declarative, type-safe, and composable way to manage this routing logic. Instead of a single handler with complex conditional logic, you define many small, focused handlers and assign them to specific paths and HTTP methods.\n\nThis approach has several advantages:\n\n1.  **Declarative and Readable**: Your code clearly expresses the mapping between a URL path and its behavior, making the application's structure easy to understand.\n2.  **Composability**: Routers are just values that can be created, combined, and passed around. This makes it easy to organize routes into logical groups (e.g., a `userRoutes` router and a `productRoutes` router) and merge them.\n3.  **Type Safety**: The router ensures that the handler for a route is only ever called for a matching request, simplifying the logic within the handler itself.\n4.  **Integration**: Each route handler is an `Effect`, meaning it has full access to dependency injection, structured concurrency, and integrated error handling, just like any other part of an Effect application.\n\n---",
    "content": "## Guideline\n\nTo handle specific URL paths, create individual routes using `Http.router` functions (like `Http.router.get`) and combine them into a single `Http.App`.\n\n---\n\n## Rationale\n\nA real application needs to respond differently to different URLs. The `Http.router` provides a declarative, type-safe, and composable way to manage this routing logic. Instead of a single handler with complex conditional logic, you define many small, focused handlers and assign them to specific paths and HTTP methods.\n\nThis approach has several advantages:\n\n1.  **Declarative and Readable**: Your code clearly expresses the mapping between a URL path and its behavior, making the application's structure easy to understand.\n2.  **Composability**: Routers are just values that can be created, combined, and passed around. This makes it easy to organize routes into logical groups (e.g., a `userRoutes` router and a `productRoutes` router) and merge them.\n3.  **Type Safety**: The router ensures that the handler for a route is only ever called for a matching request, simplifying the logic within the handler itself.\n4.  **Integration**: Each route handler is an `Effect`, meaning it has full access to dependency injection, structured concurrency, and integrated error handling, just like any other part of an Effect application.\n\n---\n\n## Good Example\n\nThis example defines two separate GET routes, one for the root path (`/`) and one for `/hello`. We create an empty router and add each route to it. The resulting `app` is then served. The router automatically handles sending a `404 Not Found` response for any path that doesn't match.\n\n```typescript\nimport { Data, Effect } from 'effect'\n\n// Define response types\ninterface RouteResponse {\n  readonly status: number;\n  readonly body: string;\n}\n\n// Define error types\nclass RouteNotFoundError extends Data.TaggedError(\"RouteNotFoundError\")<{\n  readonly path: string;\n}> {}\n\nclass RouteHandlerError extends Data.TaggedError(\"RouteHandlerError\")<{\n  readonly path: string;\n  readonly error: string;\n}> {}\n\n// Define route service\nclass RouteService extends Effect.Service<RouteService>()(\n  \"RouteService\",\n  {\n    sync: () => {\n      // Create instance methods\n      const handleRoute = (path: string): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Processing request for path: ${path}`);\n          \n          try {\n            switch (path) {\n              case '/':\n                const home = 'Welcome to the home page!';\n                yield* Effect.logInfo(`Serving home page`);\n                return { status: 200, body: home };\n\n              case '/hello':\n                const hello = 'Hello, Effect!';\n                yield* Effect.logInfo(`Serving hello page`);\n                return { status: 200, body: hello };\n\n              default:\n                yield* Effect.logWarning(`Route not found: ${path}`);\n                return yield* Effect.fail(new RouteNotFoundError({ path }));\n            }\n          } catch (e) {\n            const error = e instanceof Error ? e.message : String(e);\n            yield* Effect.logError(`Error handling route ${path}: ${error}`);\n            return yield* Effect.fail(new RouteHandlerError({ path, error }));\n          }\n        });\n\n      // Return service implementation\n      return {\n        handleRoute,\n        // Simulate GET request\n        simulateGet: (path: string): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`GET ${path}`);\n            const response = yield* handleRoute(path);\n            yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n            return response;\n          })\n      };\n    }\n  }\n) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const router = yield* RouteService;\n  \n  yield* Effect.logInfo(\"=== Starting Route Tests ===\");\n  \n  // Test different routes\n  for (const path of ['/', '/hello', '/other', '/error']) {\n    yield* Effect.logInfo(`\\n--- Testing ${path} ---`);\n    \n    const result = yield* router.simulateGet(path).pipe(\n      Effect.catchTags({\n        RouteNotFoundError: (error) =>\n          Effect.gen(function* () {\n            const response = { status: 404, body: `Not Found: ${error.path}` };\n            yield* Effect.logWarning(`${response.status} ${response.body}`);\n            return response;\n          }),\n        RouteHandlerError: (error) =>\n          Effect.gen(function* () {\n            const response = { status: 500, body: `Internal Error: ${error.error}` };\n            yield* Effect.logError(`${response.status} ${response.body}`);\n            return response;\n          })\n      })\n    );\n    \n    yield* Effect.logInfo(`Final Response: ${JSON.stringify(result)}`);\n  }\n  \n  yield* Effect.logInfo(\"\\n=== Route Tests Complete ===\");\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, RouteService.Default)\n);\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to create a single, monolithic handler that uses conditional logic to inspect the request URL. This imperative approach is difficult to maintain and scale.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// A single app that manually checks the URL\nconst app = Http.request.ServerRequest.pipe(\n  Effect.flatMap((req) => {\n    if (req.url === '/') {\n      return Effect.succeed(Http.response.text('Welcome to the home page!'));\n    } else if (req.url === '/hello') {\n      return Effect.succeed(Http.response.text('Hello, Effect!'));\n    } else {\n      return Effect.succeed(Http.response.empty({ status: 404 }));\n    }\n  })\n);\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual routing logic is verbose, error-prone (a typo in a string breaks the route), and mixes the \"what\" (the response) with the \"where\" (the routing). It doesn't scale to handle different HTTP methods, path parameters, or middleware gracefully. The `Http.router` is designed to solve all of these problems elegantly."
  },
  {
    "id": "handle-api-errors",
    "title": "Handle API Errors",
    "description": "Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines two custom error types, `UserNotFoundError` and `InvalidIdError`. The route logic can fail with either. The `unhandledErrorResponse` function inspects the error and returns a `404` or `400` response accordingly, with a generic `500` for any other unexpected errors.\n\n```typescript\nimport { Cause, Data, Effect } from 'effect';\n\n// Define our domain types\nexport interface User {\n  readonly id: string;\n  readonly name: string;\n  readonly email: string;\n  readonly role: 'admin' | 'user';\n}\n\n// Define specific, typed errors for our domain\nexport class UserNotFoundError extends Data.TaggedError('UserNotFoundError')<{\n  readonly id: string;\n}> { }\n\nexport class InvalidIdError extends Data.TaggedError('InvalidIdError')<{\n  readonly id: string;\n  readonly reason: string;\n}> { }\n\nexport class UnauthorizedError extends Data.TaggedError('UnauthorizedError')<{\n  readonly action: string;\n  readonly role: string;\n}> { }\n\n// Define error handler service\nexport class ErrorHandlerService extends Effect.Service<ErrorHandlerService>()(\n  'ErrorHandlerService',\n  {\n    sync: () => ({\n      // Handle API errors with proper logging\n      handleApiError: <E>(error: E): Effect.Effect<ApiResponse, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`API Error: ${JSON.stringify(error)}`);\n\n          if (error instanceof UserNotFoundError) {\n            return { error: 'Not Found', message: `User ${error.id} not found` };\n          }\n          if (error instanceof InvalidIdError) {\n            return { error: 'Bad Request', message: error.reason };\n          }\n          if (error instanceof UnauthorizedError) {\n            return { error: 'Unauthorized', message: `${error.role} cannot ${error.action}` };\n          }\n\n          return { error: 'Internal Server Error', message: 'An unexpected error occurred' };\n        }),\n\n      // Handle unexpected errors\n      handleUnexpectedError: (cause: Cause.Cause<unknown>): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError('Unexpected error occurred');\n\n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === 'Some') {\n              const error = defect.value as Error;\n              yield* Effect.logError(`Defect: ${error.message}`);\n              yield* Effect.logError(`Stack: ${error.stack?.split('\\n')[1]?.trim() ?? 'N/A'}`);\n            }\n          }\n\n          return Effect.succeed(void 0);\n        })\n    })\n  }\n) { }\n\n// Define UserRepository service\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  'UserRepository',\n  {\n    sync: () => {\n      const users = new Map<string, User>([\n        ['user_123', { id: 'user_123', name: 'Paul', email: 'paul@example.com', role: 'admin' }],\n        ['user_456', { id: 'user_456', name: 'Alice', email: 'alice@example.com', role: 'user' }]\n      ]);\n\n      return {\n        // Get user by ID with proper error handling\n        getUser: (id: string): Effect.Effect<User, UserNotFoundError | InvalidIdError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Attempting to get user with id: ${id}`);\n\n            // Validate ID format\n            if (!id.match(/^user_\\d+$/)) {\n              yield* Effect.logWarning(`Invalid user ID format: ${id}`);\n              return yield* Effect.fail(new InvalidIdError({\n                id,\n                reason: 'ID must be in format user_<number>'\n              }));\n            }\n\n            const user = users.get(id);\n            if (user === undefined) {\n              yield* Effect.logWarning(`User not found with id: ${id}`);\n              return yield* Effect.fail(new UserNotFoundError({ id }));\n            }\n\n            yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n            return user;\n          }),\n\n        // Check if user has required role\n        checkRole: (user: User, requiredRole: 'admin' | 'user'): Effect.Effect<void, UnauthorizedError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Checking if user ${user.id} has role: ${requiredRole}`);\n\n            if (user.role !== requiredRole && user.role !== 'admin') {\n              yield* Effect.logWarning(`User ${user.id} with role ${user.role} cannot access ${requiredRole} resources`);\n              return yield* Effect.fail(new UnauthorizedError({\n                action: 'access_user',\n                role: user.role\n              }));\n            }\n\n            yield* Effect.logInfo(`User ${user.id} has required role: ${user.role}`);\n            return Effect.succeed(void 0);\n          })\n      };\n    }\n  }\n) { }\n\ninterface ApiResponse {\n  readonly error?: string;\n  readonly message?: string;\n  readonly data?: User;\n}\n\n// Create routes with proper error handling\nconst createRoutes = () => Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const errorHandler = yield* ErrorHandlerService;\n\n  yield* Effect.logInfo('=== Processing API request ===');\n\n  // Test different scenarios\n  for (const userId of ['user_123', 'user_456', 'invalid_id', 'user_789']) {\n    yield* Effect.logInfo(`\\n--- Testing user ID: ${userId} ---`);\n\n    const response = yield* repo.getUser(userId).pipe(\n      Effect.map(user => ({\n        data: {\n          ...user,\n          email: user.role === 'admin' ? user.email : '[hidden]'\n        }\n      })),\n      Effect.catchAll(error => errorHandler.handleApiError(error))\n    );\n\n    yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n  }\n\n  // Test role checking\n  const adminUser = yield* repo.getUser('user_123');\n  const regularUser = yield* repo.getUser('user_456');\n\n  yield* Effect.logInfo('\\n=== Testing role checks ===');\n\n  yield* repo.checkRole(adminUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('Admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  yield* repo.checkRole(regularUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('User admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  return { message: 'Tests completed successfully' };\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      createRoutes(),\n      ErrorHandlerService.Default\n    ),\n    UserRepository.Default\n  )\n);\n```",
    "antiPattern": "The anti-pattern is to handle HTTP-specific error logic inside each route handler using functions like `Effect.catchTag`.\n\n```typescript\nimport { Effect, Data } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nclass UserNotFoundError extends Data.TaggedError('UserNotFoundError')<{ id: string }> {}\n// ... same getUser function and error classes\n\nconst userRoute = Http.router.get(\n  '/users/:userId',\n  Effect.flatMap(Http.request.ServerRequest, (req) => getUser(req.params.userId)).pipe(\n    Effect.map(Http.response.json),\n    // Manually catching errors inside the route logic\n    Effect.catchTag('UserNotFoundError', (e) =>\n      Http.response.text(`User ${e.id} not found`, { status: 404 })\n    ),\n    Effect.catchTag('InvalidIdError', (e) =>\n      Http.response.text(`ID ${e.id} is not a valid format`, { status: 400 })\n    )\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(userRoute));\n\n// No centralized error handling\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis approach is problematic because it pollutes the business logic of the route handler with details about HTTP status codes. It's also highly repetitive; if ten different routes could produce a `UserNotFoundError`, you would need to copy this `catchTag` logic into all ten of them, making the API difficult to maintain.",
    "explanation": "By default, any unhandled failure in an Effect route handler results in a generic `500 Internal Server Error`. This is a safe default, but it's not helpful for API clients who need to know *why* their request failed. Was it a client-side error (like a non-existent resource, `404`) or a true server-side problem (`500`)?\n\nCentralizing error handling at the server level provides a clean separation of concerns:\n\n1.  **Domain-Focused Logic**: Your business logic can fail with specific, descriptive errors (e.g., `UserNotFoundError`) without needing any knowledge of HTTP status codes.\n2.  **Centralized Mapping**: You define the mapping from application errors to HTTP responses in a single location. This makes your API's error handling consistent and easy to maintain. If you need to change how an error is reported, you only change it in one place.\n3.  **Type Safety**: Using `Data.TaggedClass` for your errors allows you to use `Match` to exhaustively handle all known error cases, preventing you from forgetting to map a specific error type.\n4.  **Clear Client Communication**: It produces a predictable and useful API, allowing clients to programmatically react to different failure scenarios.\n\n---",
    "content": "## Guideline\n\nDefine specific error types for your application logic and use `Http.server.serveOptions` with a custom `unhandledErrorResponse` function to map those errors to appropriate HTTP status codes and responses.\n\n---\n\n## Rationale\n\nBy default, any unhandled failure in an Effect route handler results in a generic `500 Internal Server Error`. This is a safe default, but it's not helpful for API clients who need to know *why* their request failed. Was it a client-side error (like a non-existent resource, `404`) or a true server-side problem (`500`)?\n\nCentralizing error handling at the server level provides a clean separation of concerns:\n\n1.  **Domain-Focused Logic**: Your business logic can fail with specific, descriptive errors (e.g., `UserNotFoundError`) without needing any knowledge of HTTP status codes.\n2.  **Centralized Mapping**: You define the mapping from application errors to HTTP responses in a single location. This makes your API's error handling consistent and easy to maintain. If you need to change how an error is reported, you only change it in one place.\n3.  **Type Safety**: Using `Data.TaggedClass` for your errors allows you to use `Match` to exhaustively handle all known error cases, preventing you from forgetting to map a specific error type.\n4.  **Clear Client Communication**: It produces a predictable and useful API, allowing clients to programmatically react to different failure scenarios.\n\n---\n\n## Good Example\n\nThis example defines two custom error types, `UserNotFoundError` and `InvalidIdError`. The route logic can fail with either. The `unhandledErrorResponse` function inspects the error and returns a `404` or `400` response accordingly, with a generic `500` for any other unexpected errors.\n\n```typescript\nimport { Cause, Data, Effect } from 'effect';\n\n// Define our domain types\nexport interface User {\n  readonly id: string;\n  readonly name: string;\n  readonly email: string;\n  readonly role: 'admin' | 'user';\n}\n\n// Define specific, typed errors for our domain\nexport class UserNotFoundError extends Data.TaggedError('UserNotFoundError')<{\n  readonly id: string;\n}> { }\n\nexport class InvalidIdError extends Data.TaggedError('InvalidIdError')<{\n  readonly id: string;\n  readonly reason: string;\n}> { }\n\nexport class UnauthorizedError extends Data.TaggedError('UnauthorizedError')<{\n  readonly action: string;\n  readonly role: string;\n}> { }\n\n// Define error handler service\nexport class ErrorHandlerService extends Effect.Service<ErrorHandlerService>()(\n  'ErrorHandlerService',\n  {\n    sync: () => ({\n      // Handle API errors with proper logging\n      handleApiError: <E>(error: E): Effect.Effect<ApiResponse, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`API Error: ${JSON.stringify(error)}`);\n\n          if (error instanceof UserNotFoundError) {\n            return { error: 'Not Found', message: `User ${error.id} not found` };\n          }\n          if (error instanceof InvalidIdError) {\n            return { error: 'Bad Request', message: error.reason };\n          }\n          if (error instanceof UnauthorizedError) {\n            return { error: 'Unauthorized', message: `${error.role} cannot ${error.action}` };\n          }\n\n          return { error: 'Internal Server Error', message: 'An unexpected error occurred' };\n        }),\n\n      // Handle unexpected errors\n      handleUnexpectedError: (cause: Cause.Cause<unknown>): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError('Unexpected error occurred');\n\n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === 'Some') {\n              const error = defect.value as Error;\n              yield* Effect.logError(`Defect: ${error.message}`);\n              yield* Effect.logError(`Stack: ${error.stack?.split('\\n')[1]?.trim() ?? 'N/A'}`);\n            }\n          }\n\n          return Effect.succeed(void 0);\n        })\n    })\n  }\n) { }\n\n// Define UserRepository service\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  'UserRepository',\n  {\n    sync: () => {\n      const users = new Map<string, User>([\n        ['user_123', { id: 'user_123', name: 'Paul', email: 'paul@example.com', role: 'admin' }],\n        ['user_456', { id: 'user_456', name: 'Alice', email: 'alice@example.com', role: 'user' }]\n      ]);\n\n      return {\n        // Get user by ID with proper error handling\n        getUser: (id: string): Effect.Effect<User, UserNotFoundError | InvalidIdError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Attempting to get user with id: ${id}`);\n\n            // Validate ID format\n            if (!id.match(/^user_\\d+$/)) {\n              yield* Effect.logWarning(`Invalid user ID format: ${id}`);\n              return yield* Effect.fail(new InvalidIdError({\n                id,\n                reason: 'ID must be in format user_<number>'\n              }));\n            }\n\n            const user = users.get(id);\n            if (user === undefined) {\n              yield* Effect.logWarning(`User not found with id: ${id}`);\n              return yield* Effect.fail(new UserNotFoundError({ id }));\n            }\n\n            yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n            return user;\n          }),\n\n        // Check if user has required role\n        checkRole: (user: User, requiredRole: 'admin' | 'user'): Effect.Effect<void, UnauthorizedError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Checking if user ${user.id} has role: ${requiredRole}`);\n\n            if (user.role !== requiredRole && user.role !== 'admin') {\n              yield* Effect.logWarning(`User ${user.id} with role ${user.role} cannot access ${requiredRole} resources`);\n              return yield* Effect.fail(new UnauthorizedError({\n                action: 'access_user',\n                role: user.role\n              }));\n            }\n\n            yield* Effect.logInfo(`User ${user.id} has required role: ${user.role}`);\n            return Effect.succeed(void 0);\n          })\n      };\n    }\n  }\n) { }\n\ninterface ApiResponse {\n  readonly error?: string;\n  readonly message?: string;\n  readonly data?: User;\n}\n\n// Create routes with proper error handling\nconst createRoutes = () => Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const errorHandler = yield* ErrorHandlerService;\n\n  yield* Effect.logInfo('=== Processing API request ===');\n\n  // Test different scenarios\n  for (const userId of ['user_123', 'user_456', 'invalid_id', 'user_789']) {\n    yield* Effect.logInfo(`\\n--- Testing user ID: ${userId} ---`);\n\n    const response = yield* repo.getUser(userId).pipe(\n      Effect.map(user => ({\n        data: {\n          ...user,\n          email: user.role === 'admin' ? user.email : '[hidden]'\n        }\n      })),\n      Effect.catchAll(error => errorHandler.handleApiError(error))\n    );\n\n    yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n  }\n\n  // Test role checking\n  const adminUser = yield* repo.getUser('user_123');\n  const regularUser = yield* repo.getUser('user_456');\n\n  yield* Effect.logInfo('\\n=== Testing role checks ===');\n\n  yield* repo.checkRole(adminUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('Admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  yield* repo.checkRole(regularUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('User admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  return { message: 'Tests completed successfully' };\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      createRoutes(),\n      ErrorHandlerService.Default\n    ),\n    UserRepository.Default\n  )\n);\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to handle HTTP-specific error logic inside each route handler using functions like `Effect.catchTag`.\n\n```typescript\nimport { Effect, Data } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nclass UserNotFoundError extends Data.TaggedError('UserNotFoundError')<{ id: string }> {}\n// ... same getUser function and error classes\n\nconst userRoute = Http.router.get(\n  '/users/:userId',\n  Effect.flatMap(Http.request.ServerRequest, (req) => getUser(req.params.userId)).pipe(\n    Effect.map(Http.response.json),\n    // Manually catching errors inside the route logic\n    Effect.catchTag('UserNotFoundError', (e) =>\n      Http.response.text(`User ${e.id} not found`, { status: 404 })\n    ),\n    Effect.catchTag('InvalidIdError', (e) =>\n      Http.response.text(`ID ${e.id} is not a valid format`, { status: 400 })\n    )\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(userRoute));\n\n// No centralized error handling\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis approach is problematic because it pollutes the business logic of the route handler with details about HTTP status codes. It's also highly repetitive; if ten different routes could produce a `UserNotFoundError`, you would need to copy this `catchTag` logic into all ten of them, making the API difficult to maintain."
  },
  {
    "id": "handle-errors-with-catch",
    "title": "Handle Errors with catchTag, catchTags, and catchAll",
    "description": "Handle errors with catchTag, catchTags, and catchAll.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Data, Effect } from \"effect\";\n\n// Define domain types\ninterface User {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define specific error types\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly url: string;\n  readonly code: number;\n}> { }\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> { }\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly id: string;\n}> { }\n\n// Define UserService\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    // Fetch user data\n    fetchUser: (\n      id: string\n    ): Effect.Effect<User, NetworkError | NotFoundError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Fetching user with id: ${id}`);\n\n        if (id === \"invalid\") {\n          const url = \"/api/users/\" + id;\n          yield* Effect.logWarning(`Network error accessing: ${url}`);\n          return yield* Effect.fail(new NetworkError({ url, code: 500 }));\n        }\n\n        if (id === \"missing\") {\n          yield* Effect.logWarning(`User not found: ${id}`);\n          return yield* Effect.fail(new NotFoundError({ id }));\n        }\n\n        const user = { id, name: \"John Doe\" };\n        yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n        return user;\n      }),\n\n    // Validate user data\n    validateUser: (user: User): Effect.Effect<string, ValidationError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Validating user: ${JSON.stringify(user)}`);\n\n        if (user.name.length < 3) {\n          yield* Effect.logWarning(\n            `Validation failed: name too short for user ${user.id}`\n          );\n          return yield* Effect.fail(\n            new ValidationError({ field: \"name\", message: \"Name too short\" })\n          );\n        }\n\n        const message = `User ${user.name} is valid`;\n        yield* Effect.logInfo(message);\n        return message;\n      }),\n  }),\n}) { }\n\n// Compose operations with error handling using catchTags\nconst processUser = (\n  userId: string\n): Effect.Effect<string, never, UserService> =>\n  Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    yield* Effect.logInfo(`=== Processing user ID: ${userId} ===`);\n\n    const result = yield* userService.fetchUser(userId).pipe(\n      Effect.flatMap(userService.validateUser),\n      // Handle different error types with specific recovery logic\n      Effect.catchTags({\n        NetworkError: (e) =>\n          Effect.gen(function* () {\n            const message = `Network error: ${e.code} for ${e.url}`;\n            yield* Effect.logError(message);\n            return message;\n          }),\n        NotFoundError: (e) =>\n          Effect.gen(function* () {\n            const message = `User ${e.id} not found`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n        ValidationError: (e) =>\n          Effect.gen(function* () {\n            const message = `Invalid ${e.field}: ${e.message}`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Test with different scenarios\nconst runTests = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Starting User Processing Tests ===\");\n\n  const testCases = [\"valid\", \"invalid\", \"missing\"];\n  const results = yield* Effect.forEach(testCases, (id) => processUser(id));\n\n  yield* Effect.logInfo(\"=== User Processing Tests Complete ===\");\n  return results;\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(runTests, UserService.Default));\n\n```\n\n**Explanation:**  \nUse `catchTag` to handle specific error types in a type-safe, composable way.",
    "antiPattern": "Using `try/catch` blocks inside your Effect compositions. It breaks the\ndeclarative flow and bypasses Effect's powerful, type-safe error channels.",
    "explanation": "Effect's structured error handling allows you to build resilient applications.\nBy using tagged errors and `catchTag`, you can handle different failure\nscenarios with different logic in a type-safe way.",
    "content": "# Handle Errors with catchTag, catchTags, and catchAll\n\n## Guideline\n\nTo recover from failures, use the `catch*` family of functions.\n`Effect.catchTag` for specific tagged errors, `Effect.catchTags` for multiple,\nand `Effect.catchAll` for any error.\n\n## Rationale\n\nEffect's structured error handling allows you to build resilient applications.\nBy using tagged errors and `catchTag`, you can handle different failure\nscenarios with different logic in a type-safe way.\n\n## Good Example\n\n```typescript\nimport { Data, Effect } from \"effect\";\n\n// Define domain types\ninterface User {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define specific error types\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly url: string;\n  readonly code: number;\n}> { }\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> { }\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly id: string;\n}> { }\n\n// Define UserService\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    // Fetch user data\n    fetchUser: (\n      id: string\n    ): Effect.Effect<User, NetworkError | NotFoundError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Fetching user with id: ${id}`);\n\n        if (id === \"invalid\") {\n          const url = \"/api/users/\" + id;\n          yield* Effect.logWarning(`Network error accessing: ${url}`);\n          return yield* Effect.fail(new NetworkError({ url, code: 500 }));\n        }\n\n        if (id === \"missing\") {\n          yield* Effect.logWarning(`User not found: ${id}`);\n          return yield* Effect.fail(new NotFoundError({ id }));\n        }\n\n        const user = { id, name: \"John Doe\" };\n        yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n        return user;\n      }),\n\n    // Validate user data\n    validateUser: (user: User): Effect.Effect<string, ValidationError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Validating user: ${JSON.stringify(user)}`);\n\n        if (user.name.length < 3) {\n          yield* Effect.logWarning(\n            `Validation failed: name too short for user ${user.id}`\n          );\n          return yield* Effect.fail(\n            new ValidationError({ field: \"name\", message: \"Name too short\" })\n          );\n        }\n\n        const message = `User ${user.name} is valid`;\n        yield* Effect.logInfo(message);\n        return message;\n      }),\n  }),\n}) { }\n\n// Compose operations with error handling using catchTags\nconst processUser = (\n  userId: string\n): Effect.Effect<string, never, UserService> =>\n  Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    yield* Effect.logInfo(`=== Processing user ID: ${userId} ===`);\n\n    const result = yield* userService.fetchUser(userId).pipe(\n      Effect.flatMap(userService.validateUser),\n      // Handle different error types with specific recovery logic\n      Effect.catchTags({\n        NetworkError: (e) =>\n          Effect.gen(function* () {\n            const message = `Network error: ${e.code} for ${e.url}`;\n            yield* Effect.logError(message);\n            return message;\n          }),\n        NotFoundError: (e) =>\n          Effect.gen(function* () {\n            const message = `User ${e.id} not found`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n        ValidationError: (e) =>\n          Effect.gen(function* () {\n            const message = `Invalid ${e.field}: ${e.message}`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Test with different scenarios\nconst runTests = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Starting User Processing Tests ===\");\n\n  const testCases = [\"valid\", \"invalid\", \"missing\"];\n  const results = yield* Effect.forEach(testCases, (id) => processUser(id));\n\n  yield* Effect.logInfo(\"=== User Processing Tests Complete ===\");\n  return results;\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(runTests, UserService.Default));\n\n```\n\n**Explanation:**  \nUse `catchTag` to handle specific error types in a type-safe, composable way.\n\n## Anti-Pattern\n\nUsing `try/catch` blocks inside your Effect compositions. It breaks the\ndeclarative flow and bypasses Effect's powerful, type-safe error channels."
  },
  {
    "id": "handle-flaky-operations-with-retry-timeout",
    "title": "Handle Flaky Operations with Retries and Timeouts",
    "description": "Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "This program attempts to fetch data from a flaky API. It will retry the request up to 3 times with increasing delays if it fails. It will also give up entirely if any single attempt takes longer than 2 seconds.\n\n```typescript\nimport { Data, Duration, Effect, Schedule } from \"effect\";\n\n// Define domain types\ninterface ApiResponse {\n  readonly data: string;\n}\n\n// Define error types\nclass ApiError extends Data.TaggedError(\"ApiError\")<{\n  readonly message: string;\n  readonly attempt: number;\n}> { }\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\")<{\n  readonly duration: string;\n  readonly attempt: number;\n}> { }\n\n// Define API service\nclass ApiService extends Effect.Service<ApiService>()(\n  \"ApiService\",\n  {\n    sync: () => ({\n      // Flaky API call that might fail or be slow\n      fetchData: (): Effect.Effect<ApiResponse, ApiError | TimeoutError> =>\n        Effect.gen(function* () {\n          const attempt = Math.floor(Math.random() * 5) + 1;\n          yield* Effect.logInfo(`Attempt ${attempt}: Making API call...`);\n\n          if (Math.random() > 0.3) {\n            yield* Effect.logWarning(`Attempt ${attempt}: API call failed`);\n            return yield* Effect.fail(new ApiError({\n              message: \"API Error\",\n              attempt\n            }));\n          }\n\n          const delay = Math.random() * 3000;\n          yield* Effect.logInfo(`Attempt ${attempt}: API call will take ${delay.toFixed(0)}ms`);\n\n          yield* Effect.sleep(Duration.millis(delay));\n\n          const response = { data: \"some important data\" };\n          yield* Effect.logInfo(`Attempt ${attempt}: API call succeeded with data: ${JSON.stringify(response)}`);\n          return response;\n        })\n    })\n  }\n) { }\n\n// Define retry policy: exponential backoff, up to 3 retries\nconst retryPolicy = Schedule.exponential(Duration.millis(100)).pipe(\n  Schedule.compose(Schedule.recurs(3)),\n  Schedule.tapInput((error: ApiError | TimeoutError) =>\n    Effect.logWarning(`Retrying after error: ${error._tag} (Attempt ${error.attempt})`)\n  )\n);\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const api = yield* ApiService;\n\n  yield* Effect.logInfo(\"=== Starting API calls with retry and timeout ===\");\n\n  // Make multiple test calls\n  for (let i = 1; i <= 3; i++) {\n    yield* Effect.logInfo(`\\n--- Test Call ${i} ---`);\n\n    const result = yield* api.fetchData().pipe(\n      Effect.timeout(Duration.seconds(2)),\n      Effect.catchTag(\"TimeoutException\", () =>\n        Effect.fail(new TimeoutError({ duration: \"2 seconds\", attempt: i }))\n      ),\n      Effect.retry(retryPolicy),\n      Effect.catchTags({\n        ApiError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries failed: ${error.message} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to API error\" } as ApiResponse;\n          }),\n        TimeoutError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries timed out after ${error.duration} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to timeout\" } as ApiResponse;\n          })\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${JSON.stringify(result)}`);\n  }\n\n  yield* Effect.logInfo(\"\\n=== API calls complete ===\");\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, ApiService.Default)\n);\n```\n\n---",
    "antiPattern": "Writing manual retry and timeout logic. This is verbose, complex, and easy to get wrong. It clutters your business logic with concerns that Effect can handle declaratively.\n\n```typescript\n// ‚ùå WRONG: Manual, complex, and error-prone logic.\nasync function manualRetryAndTimeout() {\n  for (let i = 0; i < 3; i++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 2000);\n\n      const response = await fetch(\"...\", { signal: controller.signal });\n      clearTimeout(timeoutId);\n\n      return await response.json();\n    } catch (error) {\n      if (i === 2) throw error; // Last attempt, re-throw\n      await new Promise((res) => setTimeout(res, 100 * 2 ** i)); // Manual backoff\n    }\n  }\n}\n```",
    "explanation": "In distributed systems, failure is normal. APIs can fail intermittently, and network latency can spike. Hard-coding your application to try an operation only once makes it brittle.\n\n-   **Retries:** The `Effect.retry` operator, combined with a `Schedule` policy, provides a powerful, declarative way to handle transient failures. Instead of writing complex `try/catch` loops, you can simply define a policy like \"retry 3 times, with an exponential backoff delay between attempts.\"\n\n-   **Timeouts:** An operation might not fail, but instead hang indefinitely. `Effect.timeout` prevents this by racing your effect against a timer. If your effect doesn't complete within the specified duration, it is automatically interrupted, preventing your application from getting stuck.\n\nCombining these two patterns is a best practice for any interaction with an external service.\n\n---",
    "content": "## Guideline\n\nTo build robust applications that can withstand unreliable external systems, apply two key operators to your effects:\n-   **`Effect.retry(policy)`**: To automatically re-run a failing effect according to a schedule.\n-   **`Effect.timeout(duration)`**: To interrupt an effect that takes too long to complete.\n\n---\n\n## Rationale\n\nIn distributed systems, failure is normal. APIs can fail intermittently, and network latency can spike. Hard-coding your application to try an operation only once makes it brittle.\n\n-   **Retries:** The `Effect.retry` operator, combined with a `Schedule` policy, provides a powerful, declarative way to handle transient failures. Instead of writing complex `try/catch` loops, you can simply define a policy like \"retry 3 times, with an exponential backoff delay between attempts.\"\n\n-   **Timeouts:** An operation might not fail, but instead hang indefinitely. `Effect.timeout` prevents this by racing your effect against a timer. If your effect doesn't complete within the specified duration, it is automatically interrupted, preventing your application from getting stuck.\n\nCombining these two patterns is a best practice for any interaction with an external service.\n\n---\n\n## Good Example\n\nThis program attempts to fetch data from a flaky API. It will retry the request up to 3 times with increasing delays if it fails. It will also give up entirely if any single attempt takes longer than 2 seconds.\n\n```typescript\nimport { Data, Duration, Effect, Schedule } from \"effect\";\n\n// Define domain types\ninterface ApiResponse {\n  readonly data: string;\n}\n\n// Define error types\nclass ApiError extends Data.TaggedError(\"ApiError\")<{\n  readonly message: string;\n  readonly attempt: number;\n}> { }\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\")<{\n  readonly duration: string;\n  readonly attempt: number;\n}> { }\n\n// Define API service\nclass ApiService extends Effect.Service<ApiService>()(\n  \"ApiService\",\n  {\n    sync: () => ({\n      // Flaky API call that might fail or be slow\n      fetchData: (): Effect.Effect<ApiResponse, ApiError | TimeoutError> =>\n        Effect.gen(function* () {\n          const attempt = Math.floor(Math.random() * 5) + 1;\n          yield* Effect.logInfo(`Attempt ${attempt}: Making API call...`);\n\n          if (Math.random() > 0.3) {\n            yield* Effect.logWarning(`Attempt ${attempt}: API call failed`);\n            return yield* Effect.fail(new ApiError({\n              message: \"API Error\",\n              attempt\n            }));\n          }\n\n          const delay = Math.random() * 3000;\n          yield* Effect.logInfo(`Attempt ${attempt}: API call will take ${delay.toFixed(0)}ms`);\n\n          yield* Effect.sleep(Duration.millis(delay));\n\n          const response = { data: \"some important data\" };\n          yield* Effect.logInfo(`Attempt ${attempt}: API call succeeded with data: ${JSON.stringify(response)}`);\n          return response;\n        })\n    })\n  }\n) { }\n\n// Define retry policy: exponential backoff, up to 3 retries\nconst retryPolicy = Schedule.exponential(Duration.millis(100)).pipe(\n  Schedule.compose(Schedule.recurs(3)),\n  Schedule.tapInput((error: ApiError | TimeoutError) =>\n    Effect.logWarning(`Retrying after error: ${error._tag} (Attempt ${error.attempt})`)\n  )\n);\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const api = yield* ApiService;\n\n  yield* Effect.logInfo(\"=== Starting API calls with retry and timeout ===\");\n\n  // Make multiple test calls\n  for (let i = 1; i <= 3; i++) {\n    yield* Effect.logInfo(`\\n--- Test Call ${i} ---`);\n\n    const result = yield* api.fetchData().pipe(\n      Effect.timeout(Duration.seconds(2)),\n      Effect.catchTag(\"TimeoutException\", () =>\n        Effect.fail(new TimeoutError({ duration: \"2 seconds\", attempt: i }))\n      ),\n      Effect.retry(retryPolicy),\n      Effect.catchTags({\n        ApiError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries failed: ${error.message} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to API error\" } as ApiResponse;\n          }),\n        TimeoutError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries timed out after ${error.duration} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to timeout\" } as ApiResponse;\n          })\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${JSON.stringify(result)}`);\n  }\n\n  yield* Effect.logInfo(\"\\n=== API calls complete ===\");\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, ApiService.Default)\n);\n```\n\n---\n\n## Anti-Pattern\n\nWriting manual retry and timeout logic. This is verbose, complex, and easy to get wrong. It clutters your business logic with concerns that Effect can handle declaratively.\n\n```typescript\n// ‚ùå WRONG: Manual, complex, and error-prone logic.\nasync function manualRetryAndTimeout() {\n  for (let i = 0; i < 3; i++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 2000);\n\n      const response = await fetch(\"...\", { signal: controller.signal });\n      clearTimeout(timeoutId);\n\n      return await response.json();\n    } catch (error) {\n      if (i === 2) throw error; // Last attempt, re-throw\n      await new Promise((res) => setTimeout(res, 100 * 2 ** i)); // Manual backoff\n    }\n  }\n}\n```"
  },
  {
    "id": "data-cause",
    "title": "Handle Unexpected Errors by Inspecting the Cause",
    "description": "Use Cause to inspect, analyze, and handle all possible failure modes of an Effect, including expected errors, defects, and interruptions.",
    "skillLevel": "advanced",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Cause, Effect } from \"effect\";\n\n// An Effect that may fail with an error or defect\nconst program = Effect.try({\n  try: () => {\n    throw new Error(\"Unexpected failure!\");\n  },\n  catch: (err) => err,\n});\n\n// Catch all causes and inspect them\nconst handled = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Effect.sync(() => {\n      if (Cause.isDie(cause)) {\n        console.error(\"Defect (die):\", Cause.pretty(cause));\n      } else if (Cause.isFailure(cause)) {\n        console.error(\"Expected error:\", Cause.pretty(cause));\n      } else if (Cause.isInterrupted(cause)) {\n        console.error(\"Interrupted:\", Cause.pretty(cause));\n      }\n      // Handle or rethrow as needed\n    })\n  )\n);\n\n```\n\n**Explanation:**  \n- `Cause` distinguishes between expected errors (`fail`), defects (`die`), and interruptions.\n- Use `Cause.pretty` for human-readable error traces.\n- Enables advanced error handling and debugging.",
    "antiPattern": "Catching only expected errors and ignoring defects or interruptions, which can lead to silent failures, missed bugs, and harder debugging.",
    "explanation": "Traditional error handling often loses information about *why* a failure occurred.  \n`Cause` preserves the full error context, enabling advanced debugging, error reporting, and robust recovery strategies.",
    "content": "# Handle Unexpected Errors by Inspecting the `Cause`\n\n## Guideline\n\nUse the `Cause<E>` data type to get rich, structured information about errors and failures in your Effects.  \n`Cause` captures not just expected errors, but also defects (unhandled exceptions), interruptions, and error traces.\n\n## Rationale\n\nTraditional error handling often loses information about *why* a failure occurred.  \n`Cause` preserves the full error context, enabling advanced debugging, error reporting, and robust recovery strategies.\n\n## Good Example\n\n```typescript\nimport { Cause, Effect } from \"effect\";\n\n// An Effect that may fail with an error or defect\nconst program = Effect.try({\n  try: () => {\n    throw new Error(\"Unexpected failure!\");\n  },\n  catch: (err) => err,\n});\n\n// Catch all causes and inspect them\nconst handled = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Effect.sync(() => {\n      if (Cause.isDie(cause)) {\n        console.error(\"Defect (die):\", Cause.pretty(cause));\n      } else if (Cause.isFailure(cause)) {\n        console.error(\"Expected error:\", Cause.pretty(cause));\n      } else if (Cause.isInterrupted(cause)) {\n        console.error(\"Interrupted:\", Cause.pretty(cause));\n      }\n      // Handle or rethrow as needed\n    })\n  )\n);\n\n```\n\n**Explanation:**  \n- `Cause` distinguishes between expected errors (`fail`), defects (`die`), and interruptions.\n- Use `Cause.pretty` for human-readable error traces.\n- Enables advanced error handling and debugging.\n\n## Anti-Pattern\n\nCatching only expected errors and ignoring defects or interruptions, which can lead to silent failures, missed bugs, and harder debugging."
  },
  {
    "id": "handle-unexpected-errors-with-cause",
    "title": "Handle Unexpected Errors by Inspecting the Cause",
    "description": "Handle unexpected errors by inspecting the cause.",
    "skillLevel": "advanced",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Cause, Effect, Data, Schedule, Duration } from \"effect\";\n\n// Define domain types\ninterface DatabaseConfig {\n  readonly url: string;\n}\n\ninterface DatabaseConnection {\n  readonly success: true;\n}\n\ninterface UserData {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define error types\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly operation: string;\n  readonly details: string;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define database service\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      // Connect to database with proper error handling\n      connect: (config: DatabaseConfig): Effect.Effect<DatabaseConnection, DatabaseError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Connecting to database: ${config.url}`);\n          \n          if (!config.url) {\n            const error = new DatabaseError({\n              operation: \"connect\",\n              details: \"Missing URL\"\n            });\n            yield* Effect.logError(`Database error: ${JSON.stringify(error)}`);\n            return yield* Effect.fail(error);\n          }\n          \n          // Simulate unexpected errors\n          if (config.url === \"invalid\") {\n            yield* Effect.logError(\"Invalid connection string\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Failed to parse connection string\");\n            });\n          }\n          \n          if (config.url === \"timeout\") {\n            yield* Effect.logError(\"Connection timeout\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Connection timed out\");\n            });\n          }\n          \n          yield* Effect.logInfo(\"Database connection successful\");\n          return { success: true };\n        })\n    })\n  }\n) {}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\n  \"UserService\",\n  {\n    sync: () => ({\n      // Parse user data with validation\n      parseUser: (input: unknown): Effect.Effect<UserData, ValidationError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Parsing user data: ${JSON.stringify(input)}`);\n          \n          try {\n            if (typeof input !== \"object\" || !input) {\n              const error = new ValidationError({\n                field: \"input\",\n                message: \"Invalid input type\"\n              });\n              yield* Effect.logWarning(`Validation error: ${JSON.stringify(error)}`);\n              throw error;\n            }\n            \n            const data = input as Record<string, unknown>;\n            \n            if (typeof data.id !== \"string\" || typeof data.name !== \"string\") {\n              const error = new ValidationError({\n                field: \"input\",\n                message: \"Missing required fields\"\n              });\n              yield* Effect.logWarning(`Validation error: ${JSON.stringify(error)}`);\n              throw error;\n            }\n            \n            const user = { id: data.id, name: data.name };\n            yield* Effect.logInfo(`Successfully parsed user: ${JSON.stringify(user)}`);\n            return user;\n          } catch (e) {\n            if (e instanceof ValidationError) {\n              return yield* Effect.fail(e);\n            }\n            yield* Effect.logError(`Unexpected error: ${e instanceof Error ? e.message : String(e)}`);\n            throw e;\n          }\n        })\n    })\n  }\n) {}\n\n// Define test service\nclass TestService extends Effect.Service<TestService>()(\n  \"TestService\",\n  {\n    sync: () => {\n      // Create instance methods\n      const printCause = (prefix: string, cause: Cause.Cause<unknown>): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`\\n=== ${prefix} ===`);\n          \n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === \"Some\") {\n              const error = defect.value as Error;\n              yield* Effect.logError(\"Defect (unexpected error)\");\n              yield* Effect.logError(`Message: ${error.message}`);\n              yield* Effect.logError(`Stack: ${error.stack?.split('\\n')[1]?.trim() ?? 'N/A'}`);\n            }\n          } else if (Cause.isFailure(cause)) {\n            const error = Cause.failureOption(cause);\n            yield* Effect.logWarning(\"Expected failure\");\n            yield* Effect.logWarning(`Error: ${JSON.stringify(error)}`);\n          }\n\n          // Don't return an Effect inside Effect.gen, just return the value directly\n          return void 0;\n        });\n\n      const runScenario = <E, A extends { [key: string]: any }>(\n        name: string,\n        program: Effect.Effect<A, E>\n      ): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`\\n=== Testing: ${name} ===`);\n          \n          type TestError = { readonly _tag: \"error\"; readonly cause: Cause.Cause<E> };\n          \n          const result = yield* Effect.catchAllCause(\n            program,\n            (cause) => Effect.succeed({ _tag: \"error\" as const, cause } as TestError)\n          );\n          \n          if (\"cause\" in result) {\n            yield* printCause(\"Error details\", result.cause);\n          } else {\n            yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n          }\n\n          // Don't return an Effect inside Effect.gen, just return the value directly\n          return void 0;\n        });\n\n      // Return bound methods\n      return {\n        printCause,\n        runScenario\n      };\n    }\n  }\n) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const db = yield* DatabaseService;\n  const users = yield* UserService;\n  const test = yield* TestService;\n  \n  yield* Effect.logInfo(\"=== Starting Error Handling Tests ===\");\n  \n  // Test expected database errors\n  yield* test.runScenario(\n    \"Expected database error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"\" }),\n        Schedule.exponential(100)\n      ).pipe(\n        Effect.timeout(Duration.seconds(5)),\n        Effect.catchAll(() => Effect.fail(\"Connection timeout\"))\n      );\n      return result;\n    })\n  );\n  \n  // Test unexpected connection errors\n  yield* test.runScenario(\n    \"Unexpected connection error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"invalid\" }),\n        Schedule.recurs(3)\n      ).pipe(\n        Effect.catchAllCause(cause =>\n          Effect.gen(function* () {\n            yield* Effect.logError(\"Failed after 3 retries\");\n            yield* Effect.logError(Cause.pretty(cause));\n            return yield* Effect.fail(\"Max retries exceeded\");\n          })\n        )\n      );\n      return result;\n    })\n  );\n  \n  // Test user validation with recovery\n  yield* test.runScenario(\n    \"Valid user data\",\n    Effect.gen(function* () {\n      const result = yield* users.parseUser({ id: \"1\", name: \"John\" }).pipe(\n        Effect.orElse(() => \n          Effect.succeed({ id: \"default\", name: \"Default User\" })\n        )\n      );\n      return result;\n    })\n  );\n  \n  // Test concurrent error handling with timeout\n  yield* test.runScenario(\n    \"Concurrent operations\",\n    Effect.gen(function* () {\n      const results = yield* Effect.all([\n        db.connect({ url: \"\" }).pipe(\n          Effect.timeout(Duration.seconds(1)),\n          Effect.catchAll(() => Effect.succeed({ success: true }))\n        ),\n        users.parseUser({ id: \"invalid\" }).pipe(\n          Effect.timeout(Duration.seconds(1)),\n          Effect.catchAll(() => Effect.succeed({ id: \"timeout\", name: \"Timeout\" }))\n        )\n      ], { concurrency: 2 });\n      return results;\n    })\n  );\n  \n  yield* Effect.logInfo(\"\\n=== Error Handling Tests Complete ===\");\n\n  // Don't return an Effect inside Effect.gen, just return the value directly\n  return void 0;\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      Effect.provide(\n        program,\n        TestService.Default\n      ),\n      DatabaseService.Default\n    ),\n    UserService.Default\n  )\n);\n```\n\n**Explanation:**  \nBy inspecting the `Cause`, you can distinguish between expected and unexpected\nfailures, logging or escalating as appropriate.",
    "antiPattern": "Using a simple `Effect.catchAll` can dangerously conflate expected errors and\nunexpected defects, masking critical bugs as recoverable errors.",
    "explanation": "The `Cause` object explains *why* an effect failed. A `Fail` is an expected\nerror (e.g., `ValidationError`). A `Die` is an unexpected defect (e.g., a\nthrown exception). They should be handled differently.",
    "content": "# Handle Unexpected Errors by Inspecting the Cause\n\n## Guideline\n\nTo build truly resilient applications, differentiate between known business\nerrors (`Fail`) and unknown defects (`Die`). Use `Effect.catchAllCause` to\ninspect the full `Cause` of a failure.\n\n## Rationale\n\nThe `Cause` object explains *why* an effect failed. A `Fail` is an expected\nerror (e.g., `ValidationError`). A `Die` is an unexpected defect (e.g., a\nthrown exception). They should be handled differently.\n\n## Good Example\n\n```typescript\nimport { Cause, Effect, Data, Schedule, Duration } from \"effect\";\n\n// Define domain types\ninterface DatabaseConfig {\n  readonly url: string;\n}\n\ninterface DatabaseConnection {\n  readonly success: true;\n}\n\ninterface UserData {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define error types\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly operation: string;\n  readonly details: string;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define database service\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      // Connect to database with proper error handling\n      connect: (config: DatabaseConfig): Effect.Effect<DatabaseConnection, DatabaseError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Connecting to database: ${config.url}`);\n          \n          if (!config.url) {\n            const error = new DatabaseError({\n              operation: \"connect\",\n              details: \"Missing URL\"\n            });\n            yield* Effect.logError(`Database error: ${JSON.stringify(error)}`);\n            return yield* Effect.fail(error);\n          }\n          \n          // Simulate unexpected errors\n          if (config.url === \"invalid\") {\n            yield* Effect.logError(\"Invalid connection string\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Failed to parse connection string\");\n            });\n          }\n          \n          if (config.url === \"timeout\") {\n            yield* Effect.logError(\"Connection timeout\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Connection timed out\");\n            });\n          }\n          \n          yield* Effect.logInfo(\"Database connection successful\");\n          return { success: true };\n        })\n    })\n  }\n) {}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\n  \"UserService\",\n  {\n    sync: () => ({\n      // Parse user data with validation\n      parseUser: (input: unknown): Effect.Effect<UserData, ValidationError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Parsing user data: ${JSON.stringify(input)}`);\n          \n          try {\n            if (typeof input !== \"object\" || !input) {\n              const error = new ValidationError({\n                field: \"input\",\n                message: \"Invalid input type\"\n              });\n              yield* Effect.logWarning(`Validation error: ${JSON.stringify(error)}`);\n              throw error;\n            }\n            \n            const data = input as Record<string, unknown>;\n            \n            if (typeof data.id !== \"string\" || typeof data.name !== \"string\") {\n              const error = new ValidationError({\n                field: \"input\",\n                message: \"Missing required fields\"\n              });\n              yield* Effect.logWarning(`Validation error: ${JSON.stringify(error)}`);\n              throw error;\n            }\n            \n            const user = { id: data.id, name: data.name };\n            yield* Effect.logInfo(`Successfully parsed user: ${JSON.stringify(user)}`);\n            return user;\n          } catch (e) {\n            if (e instanceof ValidationError) {\n              return yield* Effect.fail(e);\n            }\n            yield* Effect.logError(`Unexpected error: ${e instanceof Error ? e.message : String(e)}`);\n            throw e;\n          }\n        })\n    })\n  }\n) {}\n\n// Define test service\nclass TestService extends Effect.Service<TestService>()(\n  \"TestService\",\n  {\n    sync: () => {\n      // Create instance methods\n      const printCause = (prefix: string, cause: Cause.Cause<unknown>): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`\\n=== ${prefix} ===`);\n          \n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === \"Some\") {\n              const error = defect.value as Error;\n              yield* Effect.logError(\"Defect (unexpected error)\");\n              yield* Effect.logError(`Message: ${error.message}`);\n              yield* Effect.logError(`Stack: ${error.stack?.split('\\n')[1]?.trim() ?? 'N/A'}`);\n            }\n          } else if (Cause.isFailure(cause)) {\n            const error = Cause.failureOption(cause);\n            yield* Effect.logWarning(\"Expected failure\");\n            yield* Effect.logWarning(`Error: ${JSON.stringify(error)}`);\n          }\n\n          // Don't return an Effect inside Effect.gen, just return the value directly\n          return void 0;\n        });\n\n      const runScenario = <E, A extends { [key: string]: any }>(\n        name: string,\n        program: Effect.Effect<A, E>\n      ): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`\\n=== Testing: ${name} ===`);\n          \n          type TestError = { readonly _tag: \"error\"; readonly cause: Cause.Cause<E> };\n          \n          const result = yield* Effect.catchAllCause(\n            program,\n            (cause) => Effect.succeed({ _tag: \"error\" as const, cause } as TestError)\n          );\n          \n          if (\"cause\" in result) {\n            yield* printCause(\"Error details\", result.cause);\n          } else {\n            yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n          }\n\n          // Don't return an Effect inside Effect.gen, just return the value directly\n          return void 0;\n        });\n\n      // Return bound methods\n      return {\n        printCause,\n        runScenario\n      };\n    }\n  }\n) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const db = yield* DatabaseService;\n  const users = yield* UserService;\n  const test = yield* TestService;\n  \n  yield* Effect.logInfo(\"=== Starting Error Handling Tests ===\");\n  \n  // Test expected database errors\n  yield* test.runScenario(\n    \"Expected database error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"\" }),\n        Schedule.exponential(100)\n      ).pipe(\n        Effect.timeout(Duration.seconds(5)),\n        Effect.catchAll(() => Effect.fail(\"Connection timeout\"))\n      );\n      return result;\n    })\n  );\n  \n  // Test unexpected connection errors\n  yield* test.runScenario(\n    \"Unexpected connection error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"invalid\" }),\n        Schedule.recurs(3)\n      ).pipe(\n        Effect.catchAllCause(cause =>\n          Effect.gen(function* () {\n            yield* Effect.logError(\"Failed after 3 retries\");\n            yield* Effect.logError(Cause.pretty(cause));\n            return yield* Effect.fail(\"Max retries exceeded\");\n          })\n        )\n      );\n      return result;\n    })\n  );\n  \n  // Test user validation with recovery\n  yield* test.runScenario(\n    \"Valid user data\",\n    Effect.gen(function* () {\n      const result = yield* users.parseUser({ id: \"1\", name: \"John\" }).pipe(\n        Effect.orElse(() => \n          Effect.succeed({ id: \"default\", name: \"Default User\" })\n        )\n      );\n      return result;\n    })\n  );\n  \n  // Test concurrent error handling with timeout\n  yield* test.runScenario(\n    \"Concurrent operations\",\n    Effect.gen(function* () {\n      const results = yield* Effect.all([\n        db.connect({ url: \"\" }).pipe(\n          Effect.timeout(Duration.seconds(1)),\n          Effect.catchAll(() => Effect.succeed({ success: true }))\n        ),\n        users.parseUser({ id: \"invalid\" }).pipe(\n          Effect.timeout(Duration.seconds(1)),\n          Effect.catchAll(() => Effect.succeed({ id: \"timeout\", name: \"Timeout\" }))\n        )\n      ], { concurrency: 2 });\n      return results;\n    })\n  );\n  \n  yield* Effect.logInfo(\"\\n=== Error Handling Tests Complete ===\");\n\n  // Don't return an Effect inside Effect.gen, just return the value directly\n  return void 0;\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      Effect.provide(\n        program,\n        TestService.Default\n      ),\n      DatabaseService.Default\n    ),\n    UserService.Default\n  )\n);\n```\n\n**Explanation:**  \nBy inspecting the `Cause`, you can distinguish between expected and unexpected\nfailures, logging or escalating as appropriate.\n\n## Anti-Pattern\n\nUsing a simple `Effect.catchAll` can dangerously conflate expected errors and\nunexpected defects, masking critical bugs as recoverable errors."
  },
  {
    "id": "combinator-error-handling",
    "title": "Handling Errors with catchAll, orElse, and match",
    "description": "Use error handling combinators to recover from failures, provide fallback values, or transform errors in a composable way.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Recover from any error\nconst effect = Effect.fail(\"fail!\").pipe(\n  Effect.catchAll((err) => Effect.succeed(`Recovered from: ${err}`))\n); // Effect<string>\n\n// Option: Provide a fallback if value is None\nconst option = Option.none().pipe(\n  Option.orElse(() => Option.some(\"default\"))\n); // Option<string>\n\n// Either: Provide a fallback if value is Left\nconst either = Either.left(\"error\").pipe(\n  Either.orElse(() => Either.right(\"fallback\"))\n); // Either<never, string>\n\n// Effect: Pattern match on success or failure\nconst matchEffect = Effect.fail(\"fail!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>\n```\n\n**Explanation:**  \nThese combinators let you handle errors, provide defaults, or transform error values in a way that is composable and type-safe.  \nYou can recover from errors, provide alternative computations, or pattern match on success/failure.",
    "antiPattern": "Using try/catch, null checks, or imperative error handling outside the combinator world.  \nThis breaks composability, loses type safety, and makes error propagation unpredictable.",
    "explanation": "Error handling is a first-class concern in functional programming.  \nBy using combinators, you keep error recovery logic close to where errors may occur, and avoid scattering try/catch or null checks throughout your code.",
    "content": "# Handling Errors with `catchAll`, `orElse`, and `match`\n\n## Guideline\n\nUse combinators like `catchAll`, `orElse`, and `match` to handle errors declaratively.  \nThese allow you to recover from failures, provide fallback values, or transform errors, all while preserving composability and type safety.\n\n## Rationale\n\nError handling is a first-class concern in functional programming.  \nBy using combinators, you keep error recovery logic close to where errors may occur, and avoid scattering try/catch or null checks throughout your code.\n\n## Good Example\n\n```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Recover from any error\nconst effect = Effect.fail(\"fail!\").pipe(\n  Effect.catchAll((err) => Effect.succeed(`Recovered from: ${err}`))\n); // Effect<string>\n\n// Option: Provide a fallback if value is None\nconst option = Option.none().pipe(\n  Option.orElse(() => Option.some(\"default\"))\n); // Option<string>\n\n// Either: Provide a fallback if value is Left\nconst either = Either.left(\"error\").pipe(\n  Either.orElse(() => Either.right(\"fallback\"))\n); // Either<never, string>\n\n// Effect: Pattern match on success or failure\nconst matchEffect = Effect.fail(\"fail!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>\n```\n\n**Explanation:**  \nThese combinators let you handle errors, provide defaults, or transform error values in a way that is composable and type-safe.  \nYou can recover from errors, provide alternative computations, or pattern match on success/failure.\n\n## Anti-Pattern\n\nUsing try/catch, null checks, or imperative error handling outside the combinator world.  \nThis breaks composability, loses type safety, and makes error propagation unpredictable."
  },
  {
    "id": "pattern-catchtag",
    "title": "Handling Specific Errors with catchTag and catchTags",
    "description": "Use catchTag and catchTags to handle specific tagged error types in the Effect failure channel, providing targeted recovery logic.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define tagged error types\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{ message: string }> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Handle only ValidationError, let others propagate\nconst effect = Effect.fail(new ValidationError({ message: \"Invalid input\" }) as MyError).pipe(\n  Effect.catchTag(\"ValidationError\", (err) =>\n    Effect.succeed(`Recovered from validation error: ${err.message}`)\n  )\n); // Effect<string>\n\n// Effect: Handle multiple error tags\nconst effect2 = Effect.fail(new NotFoundError() as MyError).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Handled not found!\"),\n    ValidationError: (err) => Effect.succeed(`Handled validation: ${err.message}`),\n  })\n); // Effect<string>\n```\n\n**Explanation:**  \n- `catchTag` lets you recover from a specific tagged error type.\n- `catchTags` lets you handle multiple tagged error types in one place.\n- Unhandled errors continue to propagate, preserving error safety.",
    "antiPattern": "Catching all errors generically (e.g., with `catchAll`) and using manual type checks or property inspection, which is less safe and more error-prone than using tagged error combinators.",
    "explanation": "Not all errors should be handled the same way.  \nBy matching on specific error tags, you can provide targeted recovery logic for each error type, while letting unhandled errors propagate as needed.",
    "content": "# Handling Specific Errors with `catchTag` and `catchTags`\n\n## Guideline\n\nUse the `catchTag` and `catchTags` combinators to recover from or handle specific tagged error types in the Effect failure channel.  \nThis enables precise, type-safe error recovery and is especially useful for domain-specific error handling.\n\n## Rationale\n\nNot all errors should be handled the same way.  \nBy matching on specific error tags, you can provide targeted recovery logic for each error type, while letting unhandled errors propagate as needed.\n\n## Good Example\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define tagged error types\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{ message: string }> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Handle only ValidationError, let others propagate\nconst effect = Effect.fail(new ValidationError({ message: \"Invalid input\" }) as MyError).pipe(\n  Effect.catchTag(\"ValidationError\", (err) =>\n    Effect.succeed(`Recovered from validation error: ${err.message}`)\n  )\n); // Effect<string>\n\n// Effect: Handle multiple error tags\nconst effect2 = Effect.fail(new NotFoundError() as MyError).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Handled not found!\"),\n    ValidationError: (err) => Effect.succeed(`Handled validation: ${err.message}`),\n  })\n); // Effect<string>\n```\n\n**Explanation:**  \n- `catchTag` lets you recover from a specific tagged error type.\n- `catchTags` lets you handle multiple tagged error types in one place.\n- Unhandled errors continue to propagate, preserving error safety.\n\n## Anti-Pattern\n\nCatching all errors generically (e.g., with `catchAll`) and using manual type checks or property inspection, which is less safe and more error-prone than using tagged error combinators."
  },
  {
    "id": "implement-graceful-shutdown",
    "title": "Implement Graceful Shutdown for Your Application",
    "description": "Use Effect.runFork and OS signal listeners to implement graceful shutdown for long-running applications.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This example creates a server with a \"scoped\" database connection. It uses `runFork` to start the server and sets up a `SIGINT` handler to interrupt the server fiber, which in turn guarantees the database finalizer is called.\n\n```typescript\nimport { Effect, Layer, Fiber, Context, Scope } from \"effect\";\nimport * as http from \"http\";\n\n// 1. A service with a finalizer for cleanup\nclass Database extends Effect.Service<Database>()(\"Database\", {\n  effect: Effect.gen(function* () {\n    yield* Effect.log(\"Acquiring DB connection\");\n    return {\n      query: () => Effect.succeed(\"data\"),\n    };\n  }),\n}) {}\n\n// 2. The main server logic\nconst server = Effect.gen(function* () {\n  const db = yield* Database;\n\n  // Create server with proper error handling\n  const httpServer = yield* Effect.sync(() => {\n    const server = http.createServer((_req, res) => {\n      Effect.runFork(\n        Effect.provide(\n          db.query().pipe(Effect.map((data) => res.end(data))),\n          Database.Default\n        )\n      );\n    });\n    return server;\n  });\n\n  // Add a finalizer to close the server\n  yield* Effect.addFinalizer(() =>\n    Effect.gen(function* () {\n      httpServer.close();\n      yield* Effect.log(\"Server closed\");\n    })\n  );\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    httpServer.once('error', (err: Error) => {\n      resume(Effect.fail(new Error(`Failed to start server: ${err.message}`)));\n    });\n\n    httpServer.listen(3456, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.log(\"Server started on port 3456. Press Ctrl+C to exit.\");\n\n  // For testing purposes, we'll run for a short time instead of forever\n  yield* Effect.sleep(\"2 seconds\");\n  yield* Effect.log(\"Shutting down gracefully...\");\n});\n\n// 3. Provide the layer and launch with runFork\nconst app = Effect.provide(server.pipe(Effect.scoped), Database.Default);\n\n// 4. Run the app and handle shutdown\nEffect.runPromise(app).catch((error) => {\n  Effect.runSync(Effect.logError(\"Application error: \" + error));\n  process.exit(1);\n});\n\n```\n\n---",
    "antiPattern": "Letting the Node.js process exit without proper cleanup. If you run a long-running effect with `Effect.runPromise` or don't handle OS signals, pressing Ctrl+C will terminate the process abruptly, and none of your `Effect` finalizers will have a chance to run.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { app } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This will run the server, but Ctrl+C will kill it instantly.\n// The database connection finalizer will NOT be called.\nEffect.runPromise(app);\n```",
    "explanation": "When a server process is terminated, you need to ensure that it cleans up properly. This includes closing database connections, finishing in-flight requests, and releasing file handles. Failing to do so can lead to resource leaks or data corruption.\n\nEffect's structured concurrency makes this robust and easy. When a fiber is interrupted, Effect guarantees that it will run all finalizers registered within that fiber's scope, in the reverse order they were acquired.\n\nBy launching your app with `runFork`, you get a `Fiber` that represents the entire application. Triggering `Fiber.interrupt` on this top-level fiber initiates a clean, orderly shutdown sequence for all its resources.\n\n---",
    "content": "## Guideline\n\nTo enable graceful shutdown for a long-running application:\n1.  Define services with cleanup logic in `scoped` `Layer`s using `Effect.addFinalizer` or `Effect.acquireRelease`.\n2.  Launch your main application `Effect` using `Effect.runFork` to get a `Fiber` handle to the running process.\n3.  Set up listeners for process signals like `SIGINT` (Ctrl+C) and `SIGTERM`.\n4.  In the signal handler, call `Fiber.interrupt` on your application's fiber.\n\n---\n\n## Rationale\n\nWhen a server process is terminated, you need to ensure that it cleans up properly. This includes closing database connections, finishing in-flight requests, and releasing file handles. Failing to do so can lead to resource leaks or data corruption.\n\nEffect's structured concurrency makes this robust and easy. When a fiber is interrupted, Effect guarantees that it will run all finalizers registered within that fiber's scope, in the reverse order they were acquired.\n\nBy launching your app with `runFork`, you get a `Fiber` that represents the entire application. Triggering `Fiber.interrupt` on this top-level fiber initiates a clean, orderly shutdown sequence for all its resources.\n\n---\n\n## Good Example\n\nThis example creates a server with a \"scoped\" database connection. It uses `runFork` to start the server and sets up a `SIGINT` handler to interrupt the server fiber, which in turn guarantees the database finalizer is called.\n\n```typescript\nimport { Effect, Layer, Fiber, Context, Scope } from \"effect\";\nimport * as http from \"http\";\n\n// 1. A service with a finalizer for cleanup\nclass Database extends Effect.Service<Database>()(\"Database\", {\n  effect: Effect.gen(function* () {\n    yield* Effect.log(\"Acquiring DB connection\");\n    return {\n      query: () => Effect.succeed(\"data\"),\n    };\n  }),\n}) {}\n\n// 2. The main server logic\nconst server = Effect.gen(function* () {\n  const db = yield* Database;\n\n  // Create server with proper error handling\n  const httpServer = yield* Effect.sync(() => {\n    const server = http.createServer((_req, res) => {\n      Effect.runFork(\n        Effect.provide(\n          db.query().pipe(Effect.map((data) => res.end(data))),\n          Database.Default\n        )\n      );\n    });\n    return server;\n  });\n\n  // Add a finalizer to close the server\n  yield* Effect.addFinalizer(() =>\n    Effect.gen(function* () {\n      httpServer.close();\n      yield* Effect.log(\"Server closed\");\n    })\n  );\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    httpServer.once('error', (err: Error) => {\n      resume(Effect.fail(new Error(`Failed to start server: ${err.message}`)));\n    });\n\n    httpServer.listen(3456, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.log(\"Server started on port 3456. Press Ctrl+C to exit.\");\n\n  // For testing purposes, we'll run for a short time instead of forever\n  yield* Effect.sleep(\"2 seconds\");\n  yield* Effect.log(\"Shutting down gracefully...\");\n});\n\n// 3. Provide the layer and launch with runFork\nconst app = Effect.provide(server.pipe(Effect.scoped), Database.Default);\n\n// 4. Run the app and handle shutdown\nEffect.runPromise(app).catch((error) => {\n  Effect.runSync(Effect.logError(\"Application error: \" + error));\n  process.exit(1);\n});\n\n```\n\n---\n\n## Anti-Pattern\n\nLetting the Node.js process exit without proper cleanup. If you run a long-running effect with `Effect.runPromise` or don't handle OS signals, pressing Ctrl+C will terminate the process abruptly, and none of your `Effect` finalizers will have a chance to run.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { app } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This will run the server, but Ctrl+C will kill it instantly.\n// The database connection finalizer will NOT be called.\nEffect.runPromise(app);\n```"
  },
  {
    "id": "observability-effect-fn",
    "title": "Instrument and Observe Function Calls with Effect.fn",
    "description": "Use Effect.fn to wrap functions with effectful instrumentation, such as logging, metrics, or tracing, in a composable and type-safe way.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// A simple function to instrument\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Wrap the function with Effect.fn to add logging and tracking\nconst addWithLogging = (a: number, b: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Calling add with ${a} and ${b}`);\n    const result = add(a, b);\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Use the instrumented function in an Effect workflow\nconst program = addWithLogging(2, 3).pipe(\n  Effect.tap((sum) => Effect.logInfo(`Sum is ${sum}`))\n);\n\n// Run the program (commented to avoid runtime issues)\n// Effect.runPromise(program);\n\n```\n\n**Explanation:**  \n- `Effect.fn` wraps a function, returning a new function that produces an Effect.\n- You can add logging, metrics, tracing, or any effectful logic before/after the call.\n- Keeps instrumentation separate from business logic and fully composable.",
    "antiPattern": "Scattering logging, metrics, or tracing logic directly inside business functions, making code harder to test, maintain, and compose.",
    "explanation": "Instrumenting function calls is essential for observability, especially in complex or critical code paths.  \n`Effect.fn` lets you add effectful logic (logging, metrics, tracing, etc.) before, after, or around any function call, without changing the function‚Äôs core logic.",
    "content": "# Instrument and Observe Function Calls with `Effect.fn`\n\n## Guideline\n\nUse `Effect.fn` to wrap and instrument function calls with effectful logic, such as logging, metrics, or tracing.  \nThis enables you to observe, monitor, and debug function boundaries in a composable, type-safe way.\n\n## Rationale\n\nInstrumenting function calls is essential for observability, especially in complex or critical code paths.  \n`Effect.fn` lets you add effectful logic (logging, metrics, tracing, etc.) before, after, or around any function call, without changing the function‚Äôs core logic.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// A simple function to instrument\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Wrap the function with Effect.fn to add logging and tracking\nconst addWithLogging = (a: number, b: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Calling add with ${a} and ${b}`);\n    const result = add(a, b);\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Use the instrumented function in an Effect workflow\nconst program = addWithLogging(2, 3).pipe(\n  Effect.tap((sum) => Effect.logInfo(`Sum is ${sum}`))\n);\n\n// Run the program (commented to avoid runtime issues)\n// Effect.runPromise(program);\n\n```\n\n**Explanation:**  \n- `Effect.fn` wraps a function, returning a new function that produces an Effect.\n- You can add logging, metrics, tracing, or any effectful logic before/after the call.\n- Keeps instrumentation separate from business logic and fully composable.\n\n## Anti-Pattern\n\nScattering logging, metrics, or tracing logic directly inside business functions, making code harder to test, maintain, and compose."
  },
  {
    "id": "observability-opentelemetry",
    "title": "Integrate Effect Tracing with OpenTelemetry",
    "description": "Integrate Effect.withSpan with OpenTelemetry to export traces and visualize request flows across services.",
    "skillLevel": "advanced",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n// Pseudocode: Replace with actual OpenTelemetry integration for your stack\nimport { trace, context, SpanStatusCode } from \"@opentelemetry/api\";\n\n// Wrap an Effect.withSpan to export to OpenTelemetry\nfunction withOtelSpan<T>(name: string, effect: Effect.Effect<unknown, T, unknown>) {\n  return Effect.gen(function* () {\n    const otelSpan = trace.getTracer(\"default\").startSpan(name);\n    try {\n      const result = yield* effect;\n      otelSpan.setStatus({ code: SpanStatusCode.OK });\n      return result;\n    } catch (err) {\n      otelSpan.setStatus({ code: SpanStatusCode.ERROR, message: String(err) });\n      throw err;\n    } finally {\n      otelSpan.end();\n    }\n  });\n}\n\n// Usage\nconst program = withOtelSpan(\"fetchUser\", Effect.sync(() => {\n  // ...fetch user logic\n  return { id: 1, name: \"Alice\" };\n}));\n```\n\n**Explanation:**  \n- Start an OpenTelemetry span when entering an Effectful operation.\n- Set status and attributes as needed.\n- End the span when the operation completes or fails.\n- This enables full distributed tracing and visualization in your observability platform.",
    "antiPattern": "Using Effect.withSpan without exporting to OpenTelemetry, or lacking distributed tracing, which limits your ability to diagnose and visualize complex request flows.",
    "explanation": "OpenTelemetry is the industry standard for distributed tracing.  \nBy integrating Effect's spans with OpenTelemetry, you gain deep visibility into request flows, performance bottlenecks, and dependencies‚Äîacross all your services and infrastructure.",
    "content": "# Integrate Effect Tracing with OpenTelemetry\n\n## Guideline\n\nConnect Effect's tracing spans to OpenTelemetry to enable distributed tracing, visualization, and correlation across your entire stack.\n\n## Rationale\n\nOpenTelemetry is the industry standard for distributed tracing.  \nBy integrating Effect's spans with OpenTelemetry, you gain deep visibility into request flows, performance bottlenecks, and dependencies‚Äîacross all your services and infrastructure.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n// Pseudocode: Replace with actual OpenTelemetry integration for your stack\nimport { trace, context, SpanStatusCode } from \"@opentelemetry/api\";\n\n// Wrap an Effect.withSpan to export to OpenTelemetry\nfunction withOtelSpan<T>(name: string, effect: Effect.Effect<unknown, T, unknown>) {\n  return Effect.gen(function* () {\n    const otelSpan = trace.getTracer(\"default\").startSpan(name);\n    try {\n      const result = yield* effect;\n      otelSpan.setStatus({ code: SpanStatusCode.OK });\n      return result;\n    } catch (err) {\n      otelSpan.setStatus({ code: SpanStatusCode.ERROR, message: String(err) });\n      throw err;\n    } finally {\n      otelSpan.end();\n    }\n  });\n}\n\n// Usage\nconst program = withOtelSpan(\"fetchUser\", Effect.sync(() => {\n  // ...fetch user logic\n  return { id: 1, name: \"Alice\" };\n}));\n```\n\n**Explanation:**  \n- Start an OpenTelemetry span when entering an Effectful operation.\n- Set status and attributes as needed.\n- End the span when the operation completes or fails.\n- This enables full distributed tracing and visualization in your observability platform.\n\n## Anti-Pattern\n\nUsing Effect.withSpan without exporting to OpenTelemetry, or lacking distributed tracing, which limits your ability to diagnose and visualize complex request flows."
  },
  {
    "id": "leverage-structured-logging",
    "title": "Leverage Effect's Built-in Structured Logging",
    "description": "Leverage Effect's built-in structured logging.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.logDebug(\"Processing user\", { userId: 123 });\n\n// Run the program with debug logging enabled\nEffect.runSync(\n  program.pipe(\n    Effect.tap(() => Effect.log(\"Debug logging enabled\"))\n  )\n);\n```\n\n**Explanation:**  \nUsing Effect's logging system ensures your logs are structured, filterable,\nand context-aware.",
    "antiPattern": "Calling `console.log` directly within an Effect composition. This is an\nunmanaged side-effect that bypasses all the benefits of Effect's logging system.",
    "explanation": "Effect's logger is structured, context-aware (with trace IDs), configurable\nvia `Layer`, and testable. It's a first-class citizen, not an unmanaged\nside-effect.",
    "content": "# Leverage Effect's Built-in Structured Logging\n\n## Guideline\n\nUse the built-in `Effect.log*` family of functions for all application logging\ninstead of using `console.log`.\n\n## Rationale\n\nEffect's logger is structured, context-aware (with trace IDs), configurable\nvia `Layer`, and testable. It's a first-class citizen, not an unmanaged\nside-effect.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.logDebug(\"Processing user\", { userId: 123 });\n\n// Run the program with debug logging enabled\nEffect.runSync(\n  program.pipe(\n    Effect.tap(() => Effect.log(\"Debug logging enabled\"))\n  )\n);\n```\n\n**Explanation:**  \nUsing Effect's logging system ensures your logs are structured, filterable,\nand context-aware.\n\n## Anti-Pattern\n\nCalling `console.log` directly within an Effect composition. This is an\nunmanaged side-effect that bypasses all the benefits of Effect's logging system."
  },
  {
    "id": "observability-structured-logging",
    "title": "Leverage Effect's Built-in Structured Logging",
    "description": "Use Effect.log, Effect.logInfo, and Effect.logError to add structured, context-aware logging to your Effect code.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Log a simple message\nconst program = Effect.log(\"Starting the application\");\n\n// Log at different levels\nconst info = Effect.logInfo(\"User signed in\");\nconst error = Effect.logError(\"Failed to connect to database\");\n\n// Log with dynamic values\nconst userId = 42;\nconst logUser = Effect.logInfo(`Processing user: ${userId}`);\n\n// Use logging in a workflow\nconst workflow = Effect.gen(function* () {\n  yield* Effect.log(\"Beginning workflow\");\n  // ... do some work\n  yield* Effect.logInfo(\"Workflow step completed\");\n  // ... handle errors\n  yield* Effect.logError(\"Something went wrong\");\n});\n```\n\n**Explanation:**  \n- `Effect.log` logs a message at the default level.\n- `Effect.logInfo` and `Effect.logError` log at specific levels.\n- Logging is context-aware and can be used anywhere in your Effect workflows.",
    "antiPattern": "Using `console.log` or ad-hoc logging scattered throughout your code, which is not structured, not context-aware, and harder to manage in production.",
    "explanation": "Structured logging makes it easier to search, filter, and analyze logs in production.  \nEffect‚Äôs logging functions are context-aware, meaning they automatically include relevant metadata and can be configured globally.",
    "content": "# Leverage Effect's Built-in Structured Logging\n\n## Guideline\n\nUse `Effect.log`, `Effect.logInfo`, `Effect.logError`, and related functions to add structured, context-aware logging to your Effect code.  \nThis enables you to capture important events, errors, and business information in a consistent and configurable way.\n\n## Rationale\n\nStructured logging makes it easier to search, filter, and analyze logs in production.  \nEffect‚Äôs logging functions are context-aware, meaning they automatically include relevant metadata and can be configured globally.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Log a simple message\nconst program = Effect.log(\"Starting the application\");\n\n// Log at different levels\nconst info = Effect.logInfo(\"User signed in\");\nconst error = Effect.logError(\"Failed to connect to database\");\n\n// Log with dynamic values\nconst userId = 42;\nconst logUser = Effect.logInfo(`Processing user: ${userId}`);\n\n// Use logging in a workflow\nconst workflow = Effect.gen(function* () {\n  yield* Effect.log(\"Beginning workflow\");\n  // ... do some work\n  yield* Effect.logInfo(\"Workflow step completed\");\n  // ... handle errors\n  yield* Effect.logError(\"Something went wrong\");\n});\n```\n\n**Explanation:**  \n- `Effect.log` logs a message at the default level.\n- `Effect.logInfo` and `Effect.logError` log at specific levels.\n- Logging is context-aware and can be used anywhere in your Effect workflows.\n\n## Anti-Pattern\n\nUsing `console.log` or ad-hoc logging scattered throughout your code, which is not structured, not context-aware, and harder to manage in production."
  },
  {
    "id": "constructor-fail-none-left",
    "title": "Lifting Errors and Absence with fail, none, and left",
    "description": "Use fail, none, and left to create Effect, Option, or Either that represent failure or absence.",
    "skillLevel": "beginner",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Represent a failure with an error value\nconst effect = Effect.fail(\"Something went wrong\"); // Effect<string, never, never>\n\n// Option: Represent absence of a value\nconst option = Option.none(); // Option<never>\n\n// Either: Represent a failure with a left value\nconst either = Either.left(\"Invalid input\"); // Either<string, never>\n```\n\n**Explanation:**  \n- `Effect.fail(error)` creates an effect that always fails with `error`.\n- `Option.none()` creates an option that is always absent.\n- `Either.left(error)` creates an either that always represents failure.",
    "antiPattern": "Throwing exceptions, returning `null` or `undefined`, or using error codes outside the Effect, Option, or Either world.  \nThis makes error handling ad hoc, less type-safe, and harder to compose.",
    "explanation": "By lifting errors and absence into these structures, you can handle them declaratively with combinators, rather than relying on exceptions, `null`, or `undefined`.  \nThis leads to more robust and maintainable code.",
    "content": "# Lifting Errors and Absence with `fail`, `none`, and `left`\n\n## Guideline\n\nUse the `fail`, `none`, and `left` constructors to represent errors or absence in the Effect, Option, or Either world.  \nThis makes failures explicit, type-safe, and composable.\n\n## Rationale\n\nBy lifting errors and absence into these structures, you can handle them declaratively with combinators, rather than relying on exceptions, `null`, or `undefined`.  \nThis leads to more robust and maintainable code.\n\n## Good Example\n\n```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Represent a failure with an error value\nconst effect = Effect.fail(\"Something went wrong\"); // Effect<string, never, never>\n\n// Option: Represent absence of a value\nconst option = Option.none(); // Option<never>\n\n// Either: Represent a failure with a left value\nconst either = Either.left(\"Invalid input\"); // Either<string, never>\n```\n\n**Explanation:**  \n- `Effect.fail(error)` creates an effect that always fails with `error`.\n- `Option.none()` creates an option that is always absent.\n- `Either.left(error)` creates an either that always represents failure.\n\n## Anti-Pattern\n\nThrowing exceptions, returning `null` or `undefined`, or using error codes outside the Effect, Option, or Either world.  \nThis makes error handling ad hoc, less type-safe, and harder to compose."
  },
  {
    "id": "constructor-succeed-some-right",
    "title": "Lifting Values with succeed, some, and right",
    "description": "Use succeed, some, and right to create Effect, Option, or Either from plain values.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Lift a value into an Effect that always succeeds\nconst effect = Effect.succeed(42); // Effect<never, number, never>\n\n// Option: Lift a value into an Option that is always Some\nconst option = Option.some(\"hello\"); // Option<string>\n\n// Either: Lift a value into an Either that is always Right\nconst either = Either.right({ id: 1 }); // Either<never, { id: number }>\n```\n\n**Explanation:**  \n- `Effect.succeed(value)` creates an effect that always succeeds with `value`.\n- `Option.some(value)` creates an option that is always present.\n- `Either.right(value)` creates an either that always represents success.",
    "antiPattern": "Passing plain values around outside the Effect, Option, or Either world, or using `null`/`undefined` to represent absence or success.  \nThis leads to less composable, less type-safe code and makes error handling harder.",
    "explanation": "Lifting values into these structures allows you to compose them with other effects, options, or eithers, and to take advantage of all the combinators and error handling that Effect provides.",
    "content": "# Lifting Values with `succeed`, `some`, and `right`\n\n## Guideline\n\nUse the `succeed`, `some`, and `right` constructors to lift plain values into the Effect, Option, or Either world.  \nThis is the foundation for building composable, type-safe programs.\n\n## Rationale\n\nLifting values into these structures allows you to compose them with other effects, options, or eithers, and to take advantage of all the combinators and error handling that Effect provides.\n\n## Good Example\n\n```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Lift a value into an Effect that always succeeds\nconst effect = Effect.succeed(42); // Effect<never, number, never>\n\n// Option: Lift a value into an Option that is always Some\nconst option = Option.some(\"hello\"); // Option<string>\n\n// Either: Lift a value into an Either that is always Right\nconst either = Either.right({ id: 1 }); // Either<never, { id: number }>\n```\n\n**Explanation:**  \n- `Effect.succeed(value)` creates an effect that always succeeds with `value`.\n- `Option.some(value)` creates an option that is always present.\n- `Either.right(value)` creates an either that always represents success.\n\n## Anti-Pattern\n\nPassing plain values around outside the Effect, Option, or Either world, or using `null`/`undefined` to represent absence or success.  \nThis leads to less composable, less type-safe code and makes error handling harder."
  },
  {
    "id": "make-http-client-request",
    "title": "Make an Outgoing HTTP Client Request",
    "description": "Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-apis"
    ],
    "example": "This example creates a proxy endpoint. A request to `/proxy/posts/1` on our server will trigger an outgoing request to the JSONPlaceholder API. The response is then parsed and relayed back to the original client.\n\n```typescript\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport { Console, Data, Duration, Effect, Fiber, Layer } from \"effect\";\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> { }\n\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) { }\n\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\nconst server = NodeHttpServer.layer(() => require(\"node:http\").createServer(), {\n  port: 3457,\n});\n\nconst serverLayer = HttpServer.serve(app);\n\nconst mainLayer = Layer.merge(Database.Default, server);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Server started on http://localhost:3457\");\n  const layer = Layer.provide(serverLayer, mainLayer);\n\n  // Launch server and run for a short duration to demonstrate\n  const serverFiber = yield* Layer.launch(layer).pipe(Effect.fork);\n\n  // Wait a moment for server to start\n  yield* Effect.sleep(Duration.seconds(1));\n\n  // Simulate some server activity\n  yield* Effect.log(\"Server is running and ready to handle requests\");\n  yield* Effect.sleep(Duration.seconds(2));\n\n  // Shutdown gracefully\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.log(\"Server shutdown complete\");\n});\n\nNodeRuntime.runMain(\n  Effect.provide(program, Layer.provide(serverLayer, Layer.merge(Database.Default, server))) as Effect.Effect<void, unknown, never>\n);\n\n```",
    "antiPattern": "The anti-pattern is to use `fetch` inside a route handler, wrapped in `Effect.tryPromise`. This approach requires manual error handling and loses the benefits of the Effect ecosystem.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst proxyRoute = Http.router.get(\n  '/proxy/posts/:id',\n  Effect.flatMap(Http.request.ServerRequest, (req) =>\n    // Manually wrap fetch in an Effect\n    Effect.tryPromise({\n      try: () => fetch(`https://jsonplaceholder.typicode.com/posts/${req.params.id}`),\n      catch: () => 'FetchError', // Untyped error\n    }).pipe(\n      Effect.flatMap((res) =>\n        // Manually check status and parse JSON, each with its own error case\n        res.ok\n          ? Effect.tryPromise({ try: () => res.json(), catch: () => 'JsonError' })\n          : Effect.fail('BadStatusError')\n      ),\n      Effect.map(Http.response.json),\n      // A generic catch-all because we can't easily distinguish error types\n      Effect.catchAll(() => Http.response.text('An unknown error occurred', { status: 500 }))\n    )\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(proxyRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual approach is significantly more complex and less safe. It forces you to reinvent status and parsing logic, uses untyped string-based errors, and most importantly, the `fetch` call will not be automatically interrupted if the parent request is cancelled.",
    "explanation": "An API server often needs to communicate with other services. While you could use the native `fetch` API, this breaks out of the Effect ecosystem and forfeits its most powerful features. Using the built-in `Http.client` is superior for several critical reasons:\n\n1.  **Full Integration**: An `Http.client` request is a first-class `Effect`. This means it seamlessly composes with all other effects. You can add timeouts, retry logic (`Schedule`), or race it with other operations using the standard Effect operators you already know.\n2.  **Structured Concurrency**: This is a key benefit. If the original incoming request to your server is cancelled or times out, Effect will automatically interrupt the outgoing `Http.client` request. A raw `fetch` call would continue running in the background, wasting resources.\n3.  **Typed Errors**: The client provides a rich set of typed errors (e.g., `Http.error.RequestError`, `Http.error.ResponseError`). This allows you to write precise error handling logic to distinguish between a network failure and a non-2xx response from the external API.\n4.  **Testability**: The `Http.client` can be provided via a `Layer`, making it trivial to mock in tests. You can test your route's logic without making actual network calls, leading to faster and more reliable tests.\n\n---",
    "content": "## Guideline\n\nTo call an external API from within your server, use the `Http.client` module. This creates an `Effect` that represents the outgoing request, keeping it fully integrated with the Effect runtime.\n\n---\n\n## Rationale\n\nAn API server often needs to communicate with other services. While you could use the native `fetch` API, this breaks out of the Effect ecosystem and forfeits its most powerful features. Using the built-in `Http.client` is superior for several critical reasons:\n\n1.  **Full Integration**: An `Http.client` request is a first-class `Effect`. This means it seamlessly composes with all other effects. You can add timeouts, retry logic (`Schedule`), or race it with other operations using the standard Effect operators you already know.\n2.  **Structured Concurrency**: This is a key benefit. If the original incoming request to your server is cancelled or times out, Effect will automatically interrupt the outgoing `Http.client` request. A raw `fetch` call would continue running in the background, wasting resources.\n3.  **Typed Errors**: The client provides a rich set of typed errors (e.g., `Http.error.RequestError`, `Http.error.ResponseError`). This allows you to write precise error handling logic to distinguish between a network failure and a non-2xx response from the external API.\n4.  **Testability**: The `Http.client` can be provided via a `Layer`, making it trivial to mock in tests. You can test your route's logic without making actual network calls, leading to faster and more reliable tests.\n\n---\n\n## Good Example\n\nThis example creates a proxy endpoint. A request to `/proxy/posts/1` on our server will trigger an outgoing request to the JSONPlaceholder API. The response is then parsed and relayed back to the original client.\n\n```typescript\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport { Console, Data, Duration, Effect, Fiber, Layer } from \"effect\";\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> { }\n\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) { }\n\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\nconst server = NodeHttpServer.layer(() => require(\"node:http\").createServer(), {\n  port: 3457,\n});\n\nconst serverLayer = HttpServer.serve(app);\n\nconst mainLayer = Layer.merge(Database.Default, server);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Server started on http://localhost:3457\");\n  const layer = Layer.provide(serverLayer, mainLayer);\n\n  // Launch server and run for a short duration to demonstrate\n  const serverFiber = yield* Layer.launch(layer).pipe(Effect.fork);\n\n  // Wait a moment for server to start\n  yield* Effect.sleep(Duration.seconds(1));\n\n  // Simulate some server activity\n  yield* Effect.log(\"Server is running and ready to handle requests\");\n  yield* Effect.sleep(Duration.seconds(2));\n\n  // Shutdown gracefully\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.log(\"Server shutdown complete\");\n});\n\nNodeRuntime.runMain(\n  Effect.provide(program, Layer.provide(serverLayer, Layer.merge(Database.Default, server))) as Effect.Effect<void, unknown, never>\n);\n\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to use `fetch` inside a route handler, wrapped in `Effect.tryPromise`. This approach requires manual error handling and loses the benefits of the Effect ecosystem.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst proxyRoute = Http.router.get(\n  '/proxy/posts/:id',\n  Effect.flatMap(Http.request.ServerRequest, (req) =>\n    // Manually wrap fetch in an Effect\n    Effect.tryPromise({\n      try: () => fetch(`https://jsonplaceholder.typicode.com/posts/${req.params.id}`),\n      catch: () => 'FetchError', // Untyped error\n    }).pipe(\n      Effect.flatMap((res) =>\n        // Manually check status and parse JSON, each with its own error case\n        res.ok\n          ? Effect.tryPromise({ try: () => res.json(), catch: () => 'JsonError' })\n          : Effect.fail('BadStatusError')\n      ),\n      Effect.map(Http.response.json),\n      // A generic catch-all because we can't easily distinguish error types\n      Effect.catchAll(() => Http.response.text('An unknown error occurred', { status: 500 }))\n    )\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(proxyRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual approach is significantly more complex and less safe. It forces you to reinvent status and parsing logic, uses untyped string-based errors, and most importantly, the `fetch` call will not be automatically interrupted if the parent request is cancelled."
  },
  {
    "id": "manage-resource-lifecycles-with-scope",
    "title": "Manage Resource Lifecycles with Scope",
    "description": "Use Scope for fine-grained, manual control over resource lifecycles and cleanup guarantees.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This example shows how to acquire a resource (like a file handle), use it, and have `Scope` guarantee its release.\n\n```typescript\nimport { Effect, Scope } from \"effect\";\n\n// Simulate acquiring and releasing a resource\nconst acquireFile = Effect.log(\"File opened\").pipe(\n  Effect.as({ write: (data: string) => Effect.log(`Wrote: ${data}`) }),\n);\nconst releaseFile = Effect.log(\"File closed.\");\n\n// Create a \"scoped\" effect. This effect, when used, will acquire the\n// resource and register its release action with the current scope.\nconst scopedFile = Effect.acquireRelease(acquireFile, () => releaseFile);\n\n// The main program that uses the scoped resource\nconst program = Effect.gen(function* () {\n  // Effect.scoped \"uses\" the resource. It runs the acquire effect,\n  // provides the resource to the inner effect, and ensures the\n  // release effect is run when this block completes.\n  const file = yield* Effect.scoped(scopedFile);\n\n  yield* file.write(\"hello\");\n  yield* file.write(\"world\");\n\n  // The file will be automatically closed here.\n});\n\nEffect.runPromise(program);\n/*\nOutput:\nFile opened\nWrote: hello\nWrote: world\nFile closed\n*/\n```\n\n---",
    "antiPattern": "Manual resource management without the guarantees of `Scope`. This is brittle because if an error occurs after the resource is acquired but before it's released, the release logic is never executed.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { acquireFile, releaseFile } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This will leak the resource if an error happens.\nconst program = Effect.gen(function* () {\n  const file = yield* acquireFile;\n\n  // If this operation fails...\n  yield* Effect.fail(\"Something went wrong!\");\n\n  // ...this line will never be reached, and the file will never be closed.\n  yield* releaseFile;\n});\n```",
    "explanation": "`Scope` is the fundamental building block for all resource management in Effect. While higher-level APIs like `Layer.scoped` and `Stream` are often sufficient, understanding `Scope` is key to advanced use cases.\n\nA `Scope` guarantees that any finalizers added to it will be executed when the scope is closed, regardless of whether the associated computation succeeds, fails, or is interrupted. This provides a rock-solid guarantee against resource leaks.\n\nThis is especially critical in concurrent applications. When a parent fiber is interrupted, it closes its scope, which in turn automatically interrupts all its child fibers and runs all their finalizers in a structured, predictable order.\n\n---",
    "content": "## Guideline\n\nA `Scope` is a context that collects finalizers (cleanup effects). When you need fine-grained control over resource lifecycles, you can work with `Scope` directly. The most common pattern is to create a resource within a scope using `Effect.acquireRelease` and then use it via `Effect.scoped`.\n\n---\n\n## Rationale\n\n`Scope` is the fundamental building block for all resource management in Effect. While higher-level APIs like `Layer.scoped` and `Stream` are often sufficient, understanding `Scope` is key to advanced use cases.\n\nA `Scope` guarantees that any finalizers added to it will be executed when the scope is closed, regardless of whether the associated computation succeeds, fails, or is interrupted. This provides a rock-solid guarantee against resource leaks.\n\nThis is especially critical in concurrent applications. When a parent fiber is interrupted, it closes its scope, which in turn automatically interrupts all its child fibers and runs all their finalizers in a structured, predictable order.\n\n---\n\n## Good Example\n\nThis example shows how to acquire a resource (like a file handle), use it, and have `Scope` guarantee its release.\n\n```typescript\nimport { Effect, Scope } from \"effect\";\n\n// Simulate acquiring and releasing a resource\nconst acquireFile = Effect.log(\"File opened\").pipe(\n  Effect.as({ write: (data: string) => Effect.log(`Wrote: ${data}`) }),\n);\nconst releaseFile = Effect.log(\"File closed.\");\n\n// Create a \"scoped\" effect. This effect, when used, will acquire the\n// resource and register its release action with the current scope.\nconst scopedFile = Effect.acquireRelease(acquireFile, () => releaseFile);\n\n// The main program that uses the scoped resource\nconst program = Effect.gen(function* () {\n  // Effect.scoped \"uses\" the resource. It runs the acquire effect,\n  // provides the resource to the inner effect, and ensures the\n  // release effect is run when this block completes.\n  const file = yield* Effect.scoped(scopedFile);\n\n  yield* file.write(\"hello\");\n  yield* file.write(\"world\");\n\n  // The file will be automatically closed here.\n});\n\nEffect.runPromise(program);\n/*\nOutput:\nFile opened\nWrote: hello\nWrote: world\nFile closed\n*/\n```\n\n---\n\n## Anti-Pattern\n\nManual resource management without the guarantees of `Scope`. This is brittle because if an error occurs after the resource is acquired but before it's released, the release logic is never executed.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { acquireFile, releaseFile } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This will leak the resource if an error happens.\nconst program = Effect.gen(function* () {\n  const file = yield* acquireFile;\n\n  // If this operation fails...\n  yield* Effect.fail(\"Something went wrong!\");\n\n  // ...this line will never be reached, and the file will never be closed.\n  yield* releaseFile;\n});\n```"
  },
  {
    "id": "stream-manage-resources",
    "title": "Manage Resources Safely in a Pipeline",
    "description": "Use Stream.acquireRelease to safely manage the lifecycle of a resource within a pipeline.",
    "skillLevel": "advanced",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example creates and writes to a temporary file. `Stream.acquireRelease` is used to acquire a readable stream from that file. The pipeline then processes the file but is designed to fail partway through. The logs demonstrate that the `release` effect (which deletes the file) is still executed, preventing any resource leaks.\n\n```typescript\nimport { Effect, Layer } from \"effect\";\nimport { FileSystem } from \"@effect/platform/FileSystem\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\nimport * as path from \"node:path\";\n\ninterface ProcessError {\n  readonly _tag: \"ProcessError\";\n  readonly message: string;\n}\n\nconst ProcessError = (message: string): ProcessError => ({\n  _tag: \"ProcessError\",\n  message,\n});\n\ninterface FileServiceType {\n  readonly createTempFile: () => Effect.Effect<{ filePath: string }, never>;\n  readonly cleanup: (filePath: string) => Effect.Effect<void, never>;\n  readonly readFile: (filePath: string) => Effect.Effect<string, never>;\n}\n\nexport class FileService extends Effect.Service<FileService>()(\"FileService\", {\n  sync: () => {\n    const filePath = path.join(__dirname, \"temp-resource.txt\");\n    return {\n      createTempFile: () => Effect.succeed({ filePath }),\n      cleanup: (filePath: string) =>\n        Effect.log(\"‚úÖ Resource cleaned up successfully\"),\n      readFile: (filePath: string) =>\n        Effect.succeed(\"data 1\\ndata 2\\nFAIL\\ndata 4\"),\n    };\n  },\n}) {}\n\n// Process a single line\nconst processLine = (line: string): Effect.Effect<void, ProcessError> =>\n  line === \"FAIL\"\n    ? Effect.fail(ProcessError(\"Failed to process line\"))\n    : Effect.log(`Processed: ${line}`);\n\n// Create and process the file with proper resource management\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Resource Management Demo ===\");\n  yield* Effect.log(\n    \"This demonstrates proper resource cleanup even when errors occur\"\n  );\n\n  const fileService = yield* FileService;\n  const { filePath } = yield* fileService.createTempFile();\n\n  // Use scoped to ensure cleanup happens even on failure\n  yield* Effect.scoped(\n    Effect.gen(function* () {\n      yield* Effect.addFinalizer(() => fileService.cleanup(filePath));\n\n      const content = yield* fileService.readFile(filePath);\n      const lines = content.split(\"\\n\");\n\n      // Process each line, continuing even if some fail\n      for (const line of lines) {\n        yield* processLine(line).pipe(\n          Effect.catchAll((error) =>\n            Effect.log(`‚ö†Ô∏è  Skipped line due to error: ${error.message}`)\n          )\n        );\n      }\n\n      yield* Effect.log(\"‚úÖ Processing completed with proper resource management\");\n    })\n  );\n});\n\n// Run the program with FileService layer\nEffect.runPromise(Effect.provide(program, FileService.Default)).catch(\n  (error) => {\n    Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n  }\n);\n\n```",
    "antiPattern": "The anti-pattern is to manage resources manually outside the stream's context. This is brittle and almost always leads to resource leaks when errors occur.\n\n```typescript\nimport { Effect, Stream } from 'effect';\nimport { NodeFileSystem } from '@effect/platform-node';\nimport * as path from 'node:path';\n\nconst program = Effect.gen(function* () {\n  const fs = yield* NodeFileSystem;\n  const filePath = path.join(__dirname, 'temp-resource-bad.txt');\n\n  // 1. Resource acquired manually before the stream\n  yield* fs.writeFileString(filePath, 'data 1\\ndata 2');\n  const readable = fs.createReadStream(filePath);\n  yield* Effect.log('Resource acquired manually.');\n\n  const stream = Stream.fromReadable(() => readable).pipe(\n    Stream.decodeText('utf-8'),\n    Stream.splitLines,\n    // This stream will fail, causing the run to reject.\n    Stream.map(() => {\n      throw new Error('Something went wrong!');\n    })\n  );\n\n  // 2. Stream is executed\n  yield* Stream.runDrain(stream);\n\n  // 3. This release logic is NEVER reached if the stream fails.\n  yield* fs.remove(filePath);\n  yield* Effect.log('Resource released manually. (This will not be logged)');\n});\n\nEffect.runPromiseExit(program).then((exit) => {\n  if (exit._tag === 'Failure') {\n    console.log('\\nPipeline failed. The temp file was NOT deleted.');\n  }\n});\n```\n\nIn this anti-pattern, the `fs.remove` call is unreachable because the `Stream.runDrain` effect fails, causing the `gen` block to terminate immediately. The temporary file is leaked onto the disk. `Stream.acquireRelease` solves this problem entirely.",
    "explanation": "What happens if a pipeline processing a file fails halfway through? In a naive implementation, the file handle might be left open, leading to a resource leak. Over time, these leaks can exhaust system resources and crash your application.\n\n`Stream.acquireRelease` is Effect's robust solution to this problem. It's built on `Scope`, Effect's fundamental resource-management tool.\n\n1.  **Guaranteed Cleanup**: You provide an `acquire` effect to open the resource and a `release` effect to close it. Effect guarantees that the `release` effect will be called when the stream terminates, for *any* reason: successful completion, a processing failure, or even external interruption.\n2.  **Declarative and Co-located**: The logic for a resource's entire lifecycle‚Äîacquisition, usage (the stream itself), and release‚Äîis defined in one place. This makes the code easier to understand and reason about compared to manual `try/finally` blocks.\n3.  **Prevents Resource Leaks**: It is the idiomatic way to build truly resilient pipelines that do not leak resources, which is essential for long-running, production-grade applications.\n4.  **Composability**: The resulting stream is just a normal `Stream`, which can be composed with any other stream operators.\n\n---",
    "content": "## Guideline\n\nTo safely manage a resource that has an open/close lifecycle (like a file handle or database connection) for the duration of a stream, use the `Stream.acquireRelease` constructor.\n\n---\n\n## Rationale\n\nWhat happens if a pipeline processing a file fails halfway through? In a naive implementation, the file handle might be left open, leading to a resource leak. Over time, these leaks can exhaust system resources and crash your application.\n\n`Stream.acquireRelease` is Effect's robust solution to this problem. It's built on `Scope`, Effect's fundamental resource-management tool.\n\n1.  **Guaranteed Cleanup**: You provide an `acquire` effect to open the resource and a `release` effect to close it. Effect guarantees that the `release` effect will be called when the stream terminates, for *any* reason: successful completion, a processing failure, or even external interruption.\n2.  **Declarative and Co-located**: The logic for a resource's entire lifecycle‚Äîacquisition, usage (the stream itself), and release‚Äîis defined in one place. This makes the code easier to understand and reason about compared to manual `try/finally` blocks.\n3.  **Prevents Resource Leaks**: It is the idiomatic way to build truly resilient pipelines that do not leak resources, which is essential for long-running, production-grade applications.\n4.  **Composability**: The resulting stream is just a normal `Stream`, which can be composed with any other stream operators.\n\n---\n\n## Good Example\n\nThis example creates and writes to a temporary file. `Stream.acquireRelease` is used to acquire a readable stream from that file. The pipeline then processes the file but is designed to fail partway through. The logs demonstrate that the `release` effect (which deletes the file) is still executed, preventing any resource leaks.\n\n```typescript\nimport { Effect, Layer } from \"effect\";\nimport { FileSystem } from \"@effect/platform/FileSystem\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\nimport * as path from \"node:path\";\n\ninterface ProcessError {\n  readonly _tag: \"ProcessError\";\n  readonly message: string;\n}\n\nconst ProcessError = (message: string): ProcessError => ({\n  _tag: \"ProcessError\",\n  message,\n});\n\ninterface FileServiceType {\n  readonly createTempFile: () => Effect.Effect<{ filePath: string }, never>;\n  readonly cleanup: (filePath: string) => Effect.Effect<void, never>;\n  readonly readFile: (filePath: string) => Effect.Effect<string, never>;\n}\n\nexport class FileService extends Effect.Service<FileService>()(\"FileService\", {\n  sync: () => {\n    const filePath = path.join(__dirname, \"temp-resource.txt\");\n    return {\n      createTempFile: () => Effect.succeed({ filePath }),\n      cleanup: (filePath: string) =>\n        Effect.log(\"‚úÖ Resource cleaned up successfully\"),\n      readFile: (filePath: string) =>\n        Effect.succeed(\"data 1\\ndata 2\\nFAIL\\ndata 4\"),\n    };\n  },\n}) {}\n\n// Process a single line\nconst processLine = (line: string): Effect.Effect<void, ProcessError> =>\n  line === \"FAIL\"\n    ? Effect.fail(ProcessError(\"Failed to process line\"))\n    : Effect.log(`Processed: ${line}`);\n\n// Create and process the file with proper resource management\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Resource Management Demo ===\");\n  yield* Effect.log(\n    \"This demonstrates proper resource cleanup even when errors occur\"\n  );\n\n  const fileService = yield* FileService;\n  const { filePath } = yield* fileService.createTempFile();\n\n  // Use scoped to ensure cleanup happens even on failure\n  yield* Effect.scoped(\n    Effect.gen(function* () {\n      yield* Effect.addFinalizer(() => fileService.cleanup(filePath));\n\n      const content = yield* fileService.readFile(filePath);\n      const lines = content.split(\"\\n\");\n\n      // Process each line, continuing even if some fail\n      for (const line of lines) {\n        yield* processLine(line).pipe(\n          Effect.catchAll((error) =>\n            Effect.log(`‚ö†Ô∏è  Skipped line due to error: ${error.message}`)\n          )\n        );\n      }\n\n      yield* Effect.log(\"‚úÖ Processing completed with proper resource management\");\n    })\n  );\n});\n\n// Run the program with FileService layer\nEffect.runPromise(Effect.provide(program, FileService.Default)).catch(\n  (error) => {\n    Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n  }\n);\n\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to manage resources manually outside the stream's context. This is brittle and almost always leads to resource leaks when errors occur.\n\n```typescript\nimport { Effect, Stream } from 'effect';\nimport { NodeFileSystem } from '@effect/platform-node';\nimport * as path from 'node:path';\n\nconst program = Effect.gen(function* () {\n  const fs = yield* NodeFileSystem;\n  const filePath = path.join(__dirname, 'temp-resource-bad.txt');\n\n  // 1. Resource acquired manually before the stream\n  yield* fs.writeFileString(filePath, 'data 1\\ndata 2');\n  const readable = fs.createReadStream(filePath);\n  yield* Effect.log('Resource acquired manually.');\n\n  const stream = Stream.fromReadable(() => readable).pipe(\n    Stream.decodeText('utf-8'),\n    Stream.splitLines,\n    // This stream will fail, causing the run to reject.\n    Stream.map(() => {\n      throw new Error('Something went wrong!');\n    })\n  );\n\n  // 2. Stream is executed\n  yield* Stream.runDrain(stream);\n\n  // 3. This release logic is NEVER reached if the stream fails.\n  yield* fs.remove(filePath);\n  yield* Effect.log('Resource released manually. (This will not be logged)');\n});\n\nEffect.runPromiseExit(program).then((exit) => {\n  if (exit._tag === 'Failure') {\n    console.log('\\nPipeline failed. The temp file was NOT deleted.');\n  }\n});\n```\n\nIn this anti-pattern, the `fs.remove` call is unreachable because the `Stream.runDrain` effect fails, causing the `gen` block to terminate immediately. The temporary file is leaked onto the disk. `Stream.acquireRelease` solves this problem entirely."
  },
  {
    "id": "manage-shared-state-with-ref",
    "title": "Manage Shared State Safely with Ref",
    "description": "Use Ref to manage shared, mutable state concurrently, ensuring atomicity.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "This program simulates 1,000 concurrent fibers all trying to increment a shared counter. Because we use `Ref.update`, every single increment is applied atomically, and the final result is always correct.\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Create a new Ref with an initial value of 0\n  const ref = yield* Ref.make(0);\n\n  // Define an effect that increments the counter by 1\n  const increment = Ref.update(ref, (n) => n + 1);\n\n  // Create an array of 1,000 increment effects\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  // Run all 1,000 effects concurrently\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  // Get the final value of the counter\n  return yield* Ref.get(ref);\n});\n\n// The result will always be 1000\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final counter value: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n\n```\n\n---",
    "antiPattern": "The anti-pattern is using a standard JavaScript variable for shared state. The following example is not guaranteed to produce the correct result.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This is a classic race condition.\nconst programWithRaceCondition = Effect.gen(function* () {\n  let count = 0; // A plain, mutable variable\n\n  // An effect that reads, increments, and writes the variable\n  const increment = Effect.sync(() => {\n    const current = count;\n    // Another fiber could run between this read and the write below!\n    count = current + 1;\n  });\n\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  return count;\n});\n\n// The result is unpredictable and will likely be less than 1000.\nEffect.runPromise(programWithRaceCondition).then(console.log);\n```",
    "explanation": "Directly using a mutable variable (e.g., `let myState = ...`) in a concurrent system is dangerous. Multiple fibers could try to read and write to it at the same time, leading to race conditions and unpredictable results.\n\n`Ref` solves this by wrapping the state in a fiber-safe container. It's like a synchronized, in-memory cell. All operations on a `Ref` are atomic effects, guaranteeing that updates are applied correctly without being interrupted or interleaved with other updates. This eliminates race conditions and ensures data integrity.\n\n---",
    "content": "## Guideline\n\nWhen you need to share mutable state between different concurrent fibers, create a `Ref<A>`. Use `Ref.get` to read the value and `Ref.update` or `Ref.set` to modify it. All operations on a `Ref` are atomic.\n\n---\n\n## Rationale\n\nDirectly using a mutable variable (e.g., `let myState = ...`) in a concurrent system is dangerous. Multiple fibers could try to read and write to it at the same time, leading to race conditions and unpredictable results.\n\n`Ref` solves this by wrapping the state in a fiber-safe container. It's like a synchronized, in-memory cell. All operations on a `Ref` are atomic effects, guaranteeing that updates are applied correctly without being interrupted or interleaved with other updates. This eliminates race conditions and ensures data integrity.\n\n---\n\n## Good Example\n\nThis program simulates 1,000 concurrent fibers all trying to increment a shared counter. Because we use `Ref.update`, every single increment is applied atomically, and the final result is always correct.\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Create a new Ref with an initial value of 0\n  const ref = yield* Ref.make(0);\n\n  // Define an effect that increments the counter by 1\n  const increment = Ref.update(ref, (n) => n + 1);\n\n  // Create an array of 1,000 increment effects\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  // Run all 1,000 effects concurrently\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  // Get the final value of the counter\n  return yield* Ref.get(ref);\n});\n\n// The result will always be 1000\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final counter value: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n\n```\n\n---\n\n## Anti-Pattern\n\nThe anti-pattern is using a standard JavaScript variable for shared state. The following example is not guaranteed to produce the correct result.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This is a classic race condition.\nconst programWithRaceCondition = Effect.gen(function* () {\n  let count = 0; // A plain, mutable variable\n\n  // An effect that reads, increments, and writes the variable\n  const increment = Effect.sync(() => {\n    const current = count;\n    // Another fiber could run between this read and the write below!\n    count = current + 1;\n  });\n\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  return count;\n});\n\n// The result is unpredictable and will likely be less than 1000.\nEffect.runPromise(programWithRaceCondition).then(console.log);\n```"
  },
  {
    "id": "data-ref",
    "title": "Manage Shared State Safely with Ref",
    "description": "Use Ref to safely manage shared, mutable state in concurrent and effectful programs.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "```typescript\nimport { Effect, Ref } from \"effect\";\n\n// Create a Ref with an initial value\nconst makeCounter = Ref.make(0);\n\n// Increment the counter atomically\nconst increment = makeCounter.pipe(\n  Effect.flatMap((counter) =>\n    Ref.update(counter, (n) => n + 1)\n  )\n);\n\n// Read the current value\nconst getValue = makeCounter.pipe(\n  Effect.flatMap((counter) => Ref.get(counter))\n);\n\n// Use Ref in a workflow\nconst program = Effect.gen(function* () {\n  const counter = yield* Ref.make(0);\n  yield* Ref.update(counter, (n) => n + 1);\n  const value = yield* Ref.get(counter);\n  yield* Effect.log(`Counter value: ${value}`);\n});\n```\n\n**Explanation:**  \n- `Ref` is an atomic, mutable reference for effectful and concurrent code.\n- All operations are safe, composable, and free of race conditions.\n- Use `Ref` for counters, caches, or any shared mutable state.",
    "antiPattern": "Using plain variables or objects for shared state in concurrent or async code, which can lead to race conditions, bugs, and unpredictable behavior.",
    "explanation": "Managing shared state with plain variables or objects is unsafe in concurrent or asynchronous code.  \n`Ref` ensures all updates are atomic and free of race conditions, making your code robust and predictable.",
    "content": "# Manage Shared State Safely with `Ref`\n\n## Guideline\n\nUse the `Ref<A>` data type to model shared, mutable state in a concurrent environment.  \n`Ref` provides atomic, thread-safe operations for reading and updating state in effectful programs.\n\n## Rationale\n\nManaging shared state with plain variables or objects is unsafe in concurrent or asynchronous code.  \n`Ref` ensures all updates are atomic and free of race conditions, making your code robust and predictable.\n\n## Good Example\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\n// Create a Ref with an initial value\nconst makeCounter = Ref.make(0);\n\n// Increment the counter atomically\nconst increment = makeCounter.pipe(\n  Effect.flatMap((counter) =>\n    Ref.update(counter, (n) => n + 1)\n  )\n);\n\n// Read the current value\nconst getValue = makeCounter.pipe(\n  Effect.flatMap((counter) => Ref.get(counter))\n);\n\n// Use Ref in a workflow\nconst program = Effect.gen(function* () {\n  const counter = yield* Ref.make(0);\n  yield* Ref.update(counter, (n) => n + 1);\n  const value = yield* Ref.get(counter);\n  yield* Effect.log(`Counter value: ${value}`);\n});\n```\n\n**Explanation:**  \n- `Ref` is an atomic, mutable reference for effectful and concurrent code.\n- All operations are safe, composable, and free of race conditions.\n- Use `Ref` for counters, caches, or any shared mutable state.\n\n## Anti-Pattern\n\nUsing plain variables or objects for shared state in concurrent or async code, which can lead to race conditions, bugs, and unpredictable behavior."
  },
  {
    "id": "manual-scope-management",
    "title": "Manually Manage Lifecycles with `Scope`",
    "description": "Use `Effect.scope` and `Scope.addFinalizer` for fine-grained control over resource cleanup.",
    "skillLevel": "advanced",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Effect, Console } from \"effect\";\n\n// Mocking a complex file operation\nconst openFile = (path: string) =>\n  Effect.succeed({ path, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Opened ${f.path}`)),\n  );\nconst createTempFile = (path: string) =>\n  Effect.succeed({ path: `${path}.tmp`, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Created temp file ${f.path}`)),\n  );\nconst closeFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Closed ${file.path}`));\nconst deleteFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Deleted ${file.path}`));\n\n// This program acquires two resources (a file and a temp file)\n// and ensures both are cleaned up correctly using acquireRelease.\nconst program = Effect.gen(function* () {\n  const file = yield* Effect.acquireRelease(\n    openFile(\"data.csv\"),\n    (f) => closeFile(f)\n  );\n\n  const tempFile = yield* Effect.acquireRelease(\n    createTempFile(\"data.csv\"),\n    (f) => deleteFile(f)\n  );\n\n  yield* Effect.log(\"...writing data from temp file to main file...\");\n});\n\n// Run the program with a scope\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput (note the LIFO cleanup order):\nOpened data.csv\nCreated temp file data.csv.tmp\n...writing data from temp file to main file...\nDeleted data.csv.tmp\nClosed data.csv\n*/\n```\n\n**Explanation:**\n`Effect.scope` creates a new `Scope` and provides it to the `program`. Inside `program`, we access this `Scope` and use `addFinalizer` to register cleanup actions immediately after acquiring each resource. When `Effect.scope` finishes executing `program`, it closes the scope, which in turn executes all registered finalizers in the reverse order of their addition.",
    "antiPattern": "Attempting to manage multiple, interdependent resource cleanups using nested `try...finally` blocks. This leads to a \"pyramid of doom,\" is difficult to read, and remains unsafe in the face of interruptions.\n\n```typescript\n// ANTI-PATTERN: Nested, unsafe, and hard to read\nasync function complexOperation() {\n  const file = await openFilePromise(); // acquire 1\n  try {\n    const tempFile = await createTempFilePromise(); // acquire 2\n    try {\n      await doWorkPromise(file, tempFile); // use\n    } finally {\n      // This block may not run on interruption!\n      await deleteFilePromise(tempFile); // release 2\n    }\n  } finally {\n    // This block may also not run on interruption!\n    await closeFilePromise(file); // release 1\n  }\n}\n```",
    "explanation": "While `Effect.acquireRelease` and `Layer.scoped` are sufficient for most use cases, sometimes you need more control. This pattern is essential when:\n1.  A single logical operation acquires multiple resources that need independent cleanup.\n2.  You are building a custom, complex `Layer` that orchestrates several dependent resources.\n3.  You need to understand the fundamental mechanism that powers all of Effect's resource management.\n\nBy interacting with `Scope` directly, you gain precise, imperative-style control over resource cleanup within Effect's declarative, functional framework. Finalizers added to a scope are guaranteed to run in Last-In-First-Out (LIFO) order when the scope is closed.",
    "content": "# Manually Manage Lifecycles with `Scope`\n\n## Guideline\n\nFor complex scenarios where a resource's lifecycle doesn't fit a simple `acquireRelease` pattern, use `Effect.scope` to create a boundary for finalizers. Inside this boundary, you can access the `Scope` service and manually register cleanup actions using `Scope.addFinalizer`.\n\n## Rationale\n\nWhile `Effect.acquireRelease` and `Layer.scoped` are sufficient for most use cases, sometimes you need more control. This pattern is essential when:\n1.  A single logical operation acquires multiple resources that need independent cleanup.\n2.  You are building a custom, complex `Layer` that orchestrates several dependent resources.\n3.  You need to understand the fundamental mechanism that powers all of Effect's resource management.\n\nBy interacting with `Scope` directly, you gain precise, imperative-style control over resource cleanup within Effect's declarative, functional framework. Finalizers added to a scope are guaranteed to run in Last-In-First-Out (LIFO) order when the scope is closed.\n\n## Good Example\n\n```typescript\nimport { Effect, Console } from \"effect\";\n\n// Mocking a complex file operation\nconst openFile = (path: string) =>\n  Effect.succeed({ path, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Opened ${f.path}`)),\n  );\nconst createTempFile = (path: string) =>\n  Effect.succeed({ path: `${path}.tmp`, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Created temp file ${f.path}`)),\n  );\nconst closeFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Closed ${file.path}`));\nconst deleteFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Deleted ${file.path}`));\n\n// This program acquires two resources (a file and a temp file)\n// and ensures both are cleaned up correctly using acquireRelease.\nconst program = Effect.gen(function* () {\n  const file = yield* Effect.acquireRelease(\n    openFile(\"data.csv\"),\n    (f) => closeFile(f)\n  );\n\n  const tempFile = yield* Effect.acquireRelease(\n    createTempFile(\"data.csv\"),\n    (f) => deleteFile(f)\n  );\n\n  yield* Effect.log(\"...writing data from temp file to main file...\");\n});\n\n// Run the program with a scope\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput (note the LIFO cleanup order):\nOpened data.csv\nCreated temp file data.csv.tmp\n...writing data from temp file to main file...\nDeleted data.csv.tmp\nClosed data.csv\n*/\n```\n\n**Explanation:**\n`Effect.scope` creates a new `Scope` and provides it to the `program`. Inside `program`, we access this `Scope` and use `addFinalizer` to register cleanup actions immediately after acquiring each resource. When `Effect.scope` finishes executing `program`, it closes the scope, which in turn executes all registered finalizers in the reverse order of their addition.\n\n## Anti-Pattern\n\nAttempting to manage multiple, interdependent resource cleanups using nested `try...finally` blocks. This leads to a \"pyramid of doom,\" is difficult to read, and remains unsafe in the face of interruptions.\n\n```typescript\n// ANTI-PATTERN: Nested, unsafe, and hard to read\nasync function complexOperation() {\n  const file = await openFilePromise(); // acquire 1\n  try {\n    const tempFile = await createTempFilePromise(); // acquire 2\n    try {\n      await doWorkPromise(file, tempFile); // use\n    } finally {\n      // This block may not run on interruption!\n      await deleteFilePromise(tempFile); // release 2\n    }\n  } finally {\n    // This block may also not run on interruption!\n    await closeFilePromise(file); // release 1\n  }\n}\n```"
  },
  {
    "id": "combinator-foreach-all",
    "title": "Mapping and Chaining over Collections with forEach and all",
    "description": "Use forEach and all to process collections of values with effectful functions, collecting results in a type-safe and composable way.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "```typescript\nimport { Effect, Either, Option, Stream } from \"effect\";\n\n// Effect: Apply an effectful function to each item in an array\nconst numbers = [1, 2, 3];\nconst effect = Effect.forEach(numbers, (n) => Effect.succeed(n * 2));\n// Effect<number[]>\n\n// Effect: Run multiple effects in parallel and collect results\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst allEffect = Effect.all(effects, { concurrency: \"unbounded\" }); // Effect<[1, 2]>\n\n// Option: Map over a collection of options and collect only the Some values\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst filtered = options.filter(Option.isSome).map((o) => o.value); // [1, 3]\n\n// Either: Collect all Right values from a collection of Eithers\nconst eithers = [Either.right(1), Either.left(\"fail\"), Either.right(3)];\nconst rights = eithers.filter(Either.isRight); // [Either.Right(1), Either.Right(3)]\n\n// Stream: Map and flatten a stream of arrays\nconst stream = Stream.fromIterable([\n  [1, 2],\n  [3, 4],\n]).pipe(Stream.flatMap((arr) => Stream.fromIterable(arr))); // Stream<number>\n\n```\n\n**Explanation:**  \n`forEach` and `all` let you process collections in a way that is composable, type-safe, and often parallel.  \nThey handle errors and context automatically, and can be used for batch jobs, parallel requests, or data transformations.",
    "antiPattern": "Using manual loops (`for`, `forEach`, etc.) with side effects, or collecting results imperatively, which breaks composability and loses error/context handling.",
    "explanation": "Batch and parallel processing are common in real-world applications.  \nThese combinators let you express \"do this for every item\" declaratively, without manual loops or imperative control flow, and they preserve error handling and context propagation.",
    "content": "# Mapping and Chaining over Collections with `forEach` and `all`\n\n## Guideline\n\nUse the `forEach` and `all` combinators to apply an effectful function to every item in a collection and combine the results.  \nThis enables you to process lists, arrays, or other collections in a type-safe, composable, and often parallel way.\n\n## Rationale\n\nBatch and parallel processing are common in real-world applications.  \nThese combinators let you express \"do this for every item\" declaratively, without manual loops or imperative control flow, and they preserve error handling and context propagation.\n\n## Good Example\n\n```typescript\nimport { Effect, Either, Option, Stream } from \"effect\";\n\n// Effect: Apply an effectful function to each item in an array\nconst numbers = [1, 2, 3];\nconst effect = Effect.forEach(numbers, (n) => Effect.succeed(n * 2));\n// Effect<number[]>\n\n// Effect: Run multiple effects in parallel and collect results\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst allEffect = Effect.all(effects, { concurrency: \"unbounded\" }); // Effect<[1, 2]>\n\n// Option: Map over a collection of options and collect only the Some values\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst filtered = options.filter(Option.isSome).map((o) => o.value); // [1, 3]\n\n// Either: Collect all Right values from a collection of Eithers\nconst eithers = [Either.right(1), Either.left(\"fail\"), Either.right(3)];\nconst rights = eithers.filter(Either.isRight); // [Either.Right(1), Either.Right(3)]\n\n// Stream: Map and flatten a stream of arrays\nconst stream = Stream.fromIterable([\n  [1, 2],\n  [3, 4],\n]).pipe(Stream.flatMap((arr) => Stream.fromIterable(arr))); // Stream<number>\n\n```\n\n**Explanation:**  \n`forEach` and `all` let you process collections in a way that is composable, type-safe, and often parallel.  \nThey handle errors and context automatically, and can be used for batch jobs, parallel requests, or data transformations.\n\n## Anti-Pattern\n\nUsing manual loops (`for`, `forEach`, etc.) with side effects, or collecting results imperatively, which breaks composability and loses error/context handling."
  },
  {
    "id": "mapping-errors-to-fit-your-domain",
    "title": "Mapping Errors to Fit Your Domain",
    "description": "Use Effect.mapError to transform errors and create clean architectural boundaries between layers.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "A `UserRepository` uses a `Database` service. The `Database` can fail with specific errors, but the `UserRepository` maps them to a single, generic `RepositoryError` before they are exposed to the rest of the application.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Low-level, specific errors from the database layer\nclass ConnectionError extends Data.TaggedError(\"ConnectionError\") {}\nclass QueryError extends Data.TaggedError(\"QueryError\") {}\n\n// A generic error for the repository layer\nclass RepositoryError extends Data.TaggedError(\"RepositoryError\")<{\n  readonly cause: unknown;\n}> {}\n\n// The inner service\nconst dbQuery = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError\n> => Effect.fail(new ConnectionError());\n\n// The outer service uses `mapError` to create a clean boundary.\n// Its public signature only exposes `RepositoryError`.\nconst findUser = (): Effect.Effect<{ name: string }, RepositoryError> =>\n  dbQuery().pipe(\n    Effect.mapError((error) => new RepositoryError({ cause: error }))\n  );\n\n// Demonstrate the error mapping\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Attempting to find user...\");\n\n  try {\n    const user = yield* findUser();\n    yield* Effect.logInfo(`Found user: ${user.name}`);\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof RepositoryError) {\n        yield* Effect.logInfo(`Repository error occurred: ${error._tag}`);\n        if (error.cause instanceof ConnectionError || error.cause instanceof QueryError) {\n          yield* Effect.logInfo(`Original cause: ${error.cause._tag}`);\n        }\n      } else {\n        yield* Effect.logInfo(`Unexpected error: ${error}`);\n      }\n    })\n  )\n);\n\nEffect.runPromise(program);\n\n```\n\n---",
    "antiPattern": "Allowing low-level, implementation-specific errors to \"leak\" out of a service's public API. This creates tight coupling between layers.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { ConnectionError, QueryError } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This function's error channel is \"leaky\".\n// It exposes the internal implementation details of the database.\nconst findUserUnsafely = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError // <-- Leaky abstraction\n> => {\n  // ... logic that calls the database\n  return Effect.fail(new ConnectionError());\n};\n\n// Now, any code that calls `findUserUnsafely` has to know about and handle\n// both `ConnectionError` and `QueryError`. If we change the database,\n// all of that calling code might have to change too.\n```",
    "explanation": "This pattern is essential for creating clean architectural boundaries and preventing \"leaky abstractions.\" An outer layer of your application (e.g., a `UserService`) should not expose the internal failure details of the layers it depends on (e.g., a `Database` that can fail with `ConnectionError` or `QueryError`).\n\nBy using `Effect.mapError`, the outer layer can define its own, more abstract error type (like `RepositoryError`) and map all the specific, low-level errors into it. This decouples the layers. If you later swap your database implementation, you only need to update the mapping logic within the repository layer; none of the code that *uses* the repository needs to change.\n\n---",
    "content": "## Guideline\n\nWhen an inner service can fail with specific errors, use `Effect.mapError` in the outer service to catch those specific errors and transform them into a more general error suitable for its own domain.\n\n---\n\n## Rationale\n\nThis pattern is essential for creating clean architectural boundaries and preventing \"leaky abstractions.\" An outer layer of your application (e.g., a `UserService`) should not expose the internal failure details of the layers it depends on (e.g., a `Database` that can fail with `ConnectionError` or `QueryError`).\n\nBy using `Effect.mapError`, the outer layer can define its own, more abstract error type (like `RepositoryError`) and map all the specific, low-level errors into it. This decouples the layers. If you later swap your database implementation, you only need to update the mapping logic within the repository layer; none of the code that *uses* the repository needs to change.\n\n---\n\n## Good Example\n\nA `UserRepository` uses a `Database` service. The `Database` can fail with specific errors, but the `UserRepository` maps them to a single, generic `RepositoryError` before they are exposed to the rest of the application.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Low-level, specific errors from the database layer\nclass ConnectionError extends Data.TaggedError(\"ConnectionError\") {}\nclass QueryError extends Data.TaggedError(\"QueryError\") {}\n\n// A generic error for the repository layer\nclass RepositoryError extends Data.TaggedError(\"RepositoryError\")<{\n  readonly cause: unknown;\n}> {}\n\n// The inner service\nconst dbQuery = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError\n> => Effect.fail(new ConnectionError());\n\n// The outer service uses `mapError` to create a clean boundary.\n// Its public signature only exposes `RepositoryError`.\nconst findUser = (): Effect.Effect<{ name: string }, RepositoryError> =>\n  dbQuery().pipe(\n    Effect.mapError((error) => new RepositoryError({ cause: error }))\n  );\n\n// Demonstrate the error mapping\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Attempting to find user...\");\n\n  try {\n    const user = yield* findUser();\n    yield* Effect.logInfo(`Found user: ${user.name}`);\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof RepositoryError) {\n        yield* Effect.logInfo(`Repository error occurred: ${error._tag}`);\n        if (error.cause instanceof ConnectionError || error.cause instanceof QueryError) {\n          yield* Effect.logInfo(`Original cause: ${error.cause._tag}`);\n        }\n      } else {\n        yield* Effect.logInfo(`Unexpected error: ${error}`);\n      }\n    })\n  )\n);\n\nEffect.runPromise(program);\n\n```\n\n---\n\n## Anti-Pattern\n\nAllowing low-level, implementation-specific errors to \"leak\" out of a service's public API. This creates tight coupling between layers.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { ConnectionError, QueryError } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This function's error channel is \"leaky\".\n// It exposes the internal implementation details of the database.\nconst findUserUnsafely = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError // <-- Leaky abstraction\n> => {\n  // ... logic that calls the database\n  return Effect.fail(new ConnectionError());\n};\n\n// Now, any code that calls `findUserUnsafely` has to know about and handle\n// both `ConnectionError` and `QueryError`. If we change the database,\n// all of that calling code might have to change too.\n```"
  },
  {
    "id": "pattern-match",
    "title": "Matching on Success and Failure with match",
    "description": "Use match to pattern match on the result of an Effect, Option, or Either, handling both success and failure cases declaratively.",
    "skillLevel": "beginner",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Handle both success and failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>\n\n// Option: Handle Some and None cases\nconst option = Option.some(42).pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Either: Handle Left and Right cases\nconst either = Either.left(\"fail\").pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string\n```\n\n**Explanation:**  \n- `Effect.match` lets you handle both the error and success channels in one place.\n- `Option.match` and `Either.match` let you handle all possible cases for these types, making your code exhaustive and safe.",
    "antiPattern": "Using nested if/else or switch statements to check for success/failure, or ignoring possible error/none/left cases, which leads to brittle and less readable code.",
    "explanation": "Pattern matching with `match` keeps your code clear and type-safe, ensuring you handle all possible outcomes.  \nIt avoids scattered if/else or switch statements and makes your intent explicit.",
    "content": "# Matching on Success and Failure with `match`\n\n## Guideline\n\nUse the `match` combinator to handle both success and failure cases in a single, declarative place.  \nThis works for `Effect`, `Option`, and `Either`, and is the foundation for robust, readable error handling and branching.\n\n## Rationale\n\nPattern matching with `match` keeps your code clear and type-safe, ensuring you handle all possible outcomes.  \nIt avoids scattered if/else or switch statements and makes your intent explicit.\n\n## Good Example\n\n```typescript\nimport { Effect, Option, Either } from \"effect\";\n\n// Effect: Handle both success and failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>\n\n// Option: Handle Some and None cases\nconst option = Option.some(42).pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Either: Handle Left and Right cases\nconst either = Either.left(\"fail\").pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string\n```\n\n**Explanation:**  \n- `Effect.match` lets you handle both the error and success channels in one place.\n- `Option.match` and `Either.match` let you handle all possible cases for these types, making your code exhaustive and safe.\n\n## Anti-Pattern\n\nUsing nested if/else or switch statements to check for success/failure, or ignoring possible error/none/left cases, which leads to brittle and less readable code."
  },
  {
    "id": "pattern-matchtag",
    "title": "Matching Tagged Unions with matchTag and matchTags",
    "description": "Use matchTag and matchTags to handle specific cases of tagged unions or custom error types in a declarative, type-safe way.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data, Effect } from \"effect\";\n\n// Define a tagged error type\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  message: string;\n}> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Match on specific error tags\nconst effect: Effect.Effect<string, never, never> = Effect.fail(\n  new ValidationError({ message: \"Invalid input\" }) as MyError\n).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Not found!\"),\n    ValidationError: (err) =>\n      Effect.succeed(`Validation failed: ${err.message}`),\n  })\n); // Effect<string>\n\n```\n\n**Explanation:**  \n- `matchTag` lets you branch on the specific tag of a tagged union or custom error type.\n- This is safer and more maintainable than using `instanceof` or manual property checks.",
    "antiPattern": "Using `instanceof`, manual property checks, or switch statements to distinguish between cases, which is error-prone and less type-safe than declarative pattern matching.",
    "explanation": "Tagged unions (a.k.a. algebraic data types or ADTs) are a powerful way to model domain logic.  \nPattern matching on tags lets you handle each case explicitly, making your code robust, maintainable, and exhaustive.",
    "content": "# Matching Tagged Unions with `matchTag` and `matchTags`\n\n## Guideline\n\nUse the `matchTag` and `matchTags` combinators to pattern match on specific cases of tagged unions or custom error types.  \nThis enables precise, type-safe branching and is especially useful for handling domain-specific errors or ADTs.\n\n## Rationale\n\nTagged unions (a.k.a. algebraic data types or ADTs) are a powerful way to model domain logic.  \nPattern matching on tags lets you handle each case explicitly, making your code robust, maintainable, and exhaustive.\n\n## Good Example\n\n```typescript\nimport { Data, Effect } from \"effect\";\n\n// Define a tagged error type\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  message: string;\n}> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Match on specific error tags\nconst effect: Effect.Effect<string, never, never> = Effect.fail(\n  new ValidationError({ message: \"Invalid input\" }) as MyError\n).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Not found!\"),\n    ValidationError: (err) =>\n      Effect.succeed(`Validation failed: ${err.message}`),\n  })\n); // Effect<string>\n\n```\n\n**Explanation:**  \n- `matchTag` lets you branch on the specific tag of a tagged union or custom error type.\n- This is safer and more maintainable than using `instanceof` or manual property checks.\n\n## Anti-Pattern\n\nUsing `instanceof`, manual property checks, or switch statements to distinguish between cases, which is error-prone and less type-safe than declarative pattern matching."
  },
  {
    "id": "mocking-dependencies-in-tests",
    "title": "Mocking Dependencies in Tests",
    "description": "Provide mock service implementations via a test-specific Layer to isolate the unit under test.",
    "skillLevel": "intermediate",
    "useCases": [
      "testing"
    ],
    "example": "We want to test a `Notifier` service that uses an `EmailClient` to send emails. In our test, we provide a mock `EmailClient` that doesn't actually send emails but just returns a success value.\n\n```typescript\nimport { Effect, Layer } from \"effect\";\n\n// --- The Services ---\ninterface EmailClientService {\n  send: (address: string, body: string) => Effect.Effect<void>\n}\n\nclass EmailClient extends Effect.Service<EmailClientService>()(\n  \"EmailClient\",\n  {\n    sync: () => ({\n      send: (address: string, body: string) => \n        Effect.sync(() => Effect.log(`Sending email to ${address}: ${body}`))\n    })\n  }\n) {}\n\ninterface NotifierService {\n  notifyUser: (userId: number, message: string) => Effect.Effect<void>\n}\n\nclass Notifier extends Effect.Service<NotifierService>()(\n  \"Notifier\",\n  {\n    effect: Effect.gen(function* () {\n      const emailClient = yield* EmailClient;\n      return {\n        notifyUser: (userId: number, message: string) =>\n          emailClient.send(`user-${userId}@example.com`, message)\n      };\n    }),\n    dependencies: [EmailClient.Default]\n  }\n) {}\n\n// Create a program that uses the Notifier service\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Using default EmailClient implementation...\");\n  const notifier = yield* Notifier;\n  yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n\n  // Create mock EmailClient that logs differently\n  yield* Effect.log(\"\\nUsing mock EmailClient implementation...\");\n  const mockEmailClient = Layer.succeed(\n    EmailClient,\n    {\n      send: (address: string, body: string) =>\n        // Directly return the Effect.log without nesting it in Effect.sync\n        Effect.log(`MOCK: Would send to ${address} with body: ${body}`)\n    } as EmailClientService\n  );\n\n  // Run the same notification with mock client\n  yield* Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n  }).pipe(\n    Effect.provide(mockEmailClient)\n  );\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Notifier.Default)\n);\n```\n\n---",
    "antiPattern": "Testing your business logic using the \"live\" implementation of its dependencies. This creates an integration test, not a unit test. It will be slow, unreliable, and may have real-world side effects (like actually sending an email).\n\n```typescript\nimport { Effect } from \"effect\";\nimport { NotifierLive } from \"./somewhere\";\nimport { EmailClientLive } from \"./somewhere\"; // The REAL email client\n\n// ‚ùå WRONG: This test will try to send a real email.\nit(\"sends a real email\", () =>\n  Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"This is a test email!\");\n  }).pipe(\n    Effect.provide(NotifierLive),\n    Effect.provide(EmailClientLive), // Using the live layer makes this an integration test\n    Effect.runPromise,\n  ));\n```",
    "explanation": "The primary goal of a unit test is to verify the logic of a single unit of code, independent of its external dependencies. Effect's dependency injection system is designed to make this easy and type-safe.\n\nBy providing a mock `Layer` in your test, you replace a real dependency (like an `HttpClient` that makes network calls) with a fake one that returns predictable data. This provides several key benefits:\n-   **Determinism:** Your tests always produce the same result, free from the flakiness of network or database connections.\n-   **Speed:** Tests run instantly without waiting for slow I/O operations.\n-   **Type Safety:** The TypeScript compiler ensures your mock implementation perfectly matches the real service's interface, preventing your tests from becoming outdated.\n-   **Explicitness:** The test setup clearly documents all the dependencies required for the code to run.\n\n---",
    "content": "## Guideline\n\nTo test a piece of code in isolation, identify its service dependencies and provide mock implementations for them using a test-specific `Layer`. The most common way to create a mock layer is with `Layer.succeed(ServiceTag, mockImplementation)`.\n\n---\n\n## Rationale\n\nThe primary goal of a unit test is to verify the logic of a single unit of code, independent of its external dependencies. Effect's dependency injection system is designed to make this easy and type-safe.\n\nBy providing a mock `Layer` in your test, you replace a real dependency (like an `HttpClient` that makes network calls) with a fake one that returns predictable data. This provides several key benefits:\n-   **Determinism:** Your tests always produce the same result, free from the flakiness of network or database connections.\n-   **Speed:** Tests run instantly without waiting for slow I/O operations.\n-   **Type Safety:** The TypeScript compiler ensures your mock implementation perfectly matches the real service's interface, preventing your tests from becoming outdated.\n-   **Explicitness:** The test setup clearly documents all the dependencies required for the code to run.\n\n---\n\n## Good Example\n\nWe want to test a `Notifier` service that uses an `EmailClient` to send emails. In our test, we provide a mock `EmailClient` that doesn't actually send emails but just returns a success value.\n\n```typescript\nimport { Effect, Layer } from \"effect\";\n\n// --- The Services ---\ninterface EmailClientService {\n  send: (address: string, body: string) => Effect.Effect<void>\n}\n\nclass EmailClient extends Effect.Service<EmailClientService>()(\n  \"EmailClient\",\n  {\n    sync: () => ({\n      send: (address: string, body: string) => \n        Effect.sync(() => Effect.log(`Sending email to ${address}: ${body}`))\n    })\n  }\n) {}\n\ninterface NotifierService {\n  notifyUser: (userId: number, message: string) => Effect.Effect<void>\n}\n\nclass Notifier extends Effect.Service<NotifierService>()(\n  \"Notifier\",\n  {\n    effect: Effect.gen(function* () {\n      const emailClient = yield* EmailClient;\n      return {\n        notifyUser: (userId: number, message: string) =>\n          emailClient.send(`user-${userId}@example.com`, message)\n      };\n    }),\n    dependencies: [EmailClient.Default]\n  }\n) {}\n\n// Create a program that uses the Notifier service\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Using default EmailClient implementation...\");\n  const notifier = yield* Notifier;\n  yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n\n  // Create mock EmailClient that logs differently\n  yield* Effect.log(\"\\nUsing mock EmailClient implementation...\");\n  const mockEmailClient = Layer.succeed(\n    EmailClient,\n    {\n      send: (address: string, body: string) =>\n        // Directly return the Effect.log without nesting it in Effect.sync\n        Effect.log(`MOCK: Would send to ${address} with body: ${body}`)\n    } as EmailClientService\n  );\n\n  // Run the same notification with mock client\n  yield* Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n  }).pipe(\n    Effect.provide(mockEmailClient)\n  );\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Notifier.Default)\n);\n```\n\n---\n\n## Anti-Pattern\n\nTesting your business logic using the \"live\" implementation of its dependencies. This creates an integration test, not a unit test. It will be slow, unreliable, and may have real-world side effects (like actually sending an email).\n\n```typescript\nimport { Effect } from \"effect\";\nimport { NotifierLive } from \"./somewhere\";\nimport { EmailClientLive } from \"./somewhere\"; // The REAL email client\n\n// ‚ùå WRONG: This test will try to send a real email.\nit(\"sends a real email\", () =>\n  Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"This is a test email!\");\n  }).pipe(\n    Effect.provide(NotifierLive),\n    Effect.provide(EmailClientLive), // Using the live layer makes this an integration test\n    Effect.runPromise,\n  ));\n```"
  },
  {
    "id": "model-dependencies-as-services",
    "title": "Model Dependencies as Services",
    "description": "Model dependencies as services.",
    "skillLevel": "intermediate",
    "useCases": [
      "making-http-requests"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Define Random service with production implementation as default\nexport class Random extends Effect.Service<Random>()(\n  \"Random\",\n  {\n    // Default production implementation\n    sync: () => ({\n      next: Effect.sync(() => Math.random())\n    })\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const random = yield* Random;\n  const value = yield* random.next;\n  return value;\n});\n\n// Run with default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const value = yield* Effect.provide(program, Random.Default);\n  yield* Effect.log(`Random value: ${value}`);\n  return value;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \nBy modeling dependencies as services, you can easily substitute mocked or deterministic implementations for testing, leading to more reliable and predictable tests.",
    "antiPattern": "Directly calling external APIs like `fetch` or using impure functions like `Math.random()` within your business logic. This tightly couples your logic to a specific implementation and makes it difficult to test.",
    "explanation": "This pattern is the key to testability. It allows you to provide a `Live` implementation in production and a `Test` implementation (returning mock data) in your tests, making your code decoupled and reliable.",
    "content": "# Model Dependencies as Services\n\n## Guideline\n\nRepresent any external dependency or distinct capability‚Äîfrom a database client to a simple UUID generator‚Äîas a service.\n\n## Rationale\n\nThis pattern is the key to testability. It allows you to provide a `Live` implementation in production and a `Test` implementation (returning mock data) in your tests, making your code decoupled and reliable.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define Random service with production implementation as default\nexport class Random extends Effect.Service<Random>()(\n  \"Random\",\n  {\n    // Default production implementation\n    sync: () => ({\n      next: Effect.sync(() => Math.random())\n    })\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const random = yield* Random;\n  const value = yield* random.next;\n  return value;\n});\n\n// Run with default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const value = yield* Effect.provide(program, Random.Default);\n  yield* Effect.log(`Random value: ${value}`);\n  return value;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n**Explanation:**  \nBy modeling dependencies as services, you can easily substitute mocked or deterministic implementations for testing, leading to more reliable and predictable tests.\n\n## Anti-Pattern\n\nDirectly calling external APIs like `fetch` or using impure functions like `Math.random()` within your business logic. This tightly couples your logic to a specific implementation and makes it difficult to test."
  },
  {
    "id": "model-optional-values-with-option",
    "title": "Model Optional Values Safely with Option",
    "description": "Use Option<A> to explicitly model values that may be absent, avoiding null or undefined.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "A function that looks for a user in a database is a classic use case. It might find a user, or it might not. Returning an `Option<User>` makes this contract explicit and safe.\n\n```typescript\nimport { Effect, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst users: User[] = [\n  { id: 1, name: \"Paul\" },\n  { id: 2, name: \"Alex\" },\n];\n\n// This function safely returns an Option, not a User or null.\nconst findUserById = (id: number): Option.Option<User> => {\n  const user = users.find((u) => u.id === id);\n  return Option.fromNullable(user); // A useful helper for existing APIs\n};\n\n// The caller MUST handle both cases.\nconst greeting = (id: number): string =>\n  findUserById(id).pipe(\n    Option.match({\n      onNone: () => \"User not found.\",\n      onSome: (user) => `Welcome, ${user.name}!`,\n    }),\n  );\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(greeting(1)); // \"Welcome, Paul!\"\n  yield* Effect.log(greeting(3)); // \"User not found.\"\n});\n\nEffect.runPromise(program);\n```",
    "antiPattern": "The anti-pattern is returning a nullable type (e.g., User | null or User | undefined). This relies on the discipline of every single caller to perform a null check. Forgetting even one check can introduce a runtime error.\n\n```typescript\ninterface User {\n\tid: number;\n\tname: string;\n}\nconst users: User[] = [{ id: 1, name: \"Paul\" }];\n\t\n\t// ‚ùå WRONG: This function's return type is less safe.\n\tconst findUserUnsafely = (id: number): User | undefined => {\n\t  return users.find((u) => u.id === id);\n\t};\n\t\n\tconst user = findUserUnsafely(3);\n\t\n\t// This will throw \"TypeError: Cannot read properties of undefined (reading 'name')\"\n\t// because the caller forgot to check if the user exists.\n\tconsole.log(`User's name is ${user.name}`)\n```",
    "explanation": "Functions that can return a value or `null`/`undefined` are a primary source of runtime errors in TypeScript (`Cannot read properties of null`).\n\nThe `Option` type solves this by making the possibility of an absent value explicit in the type system. A function that returns `Option<User>` cannot be mistaken for a function that returns `User`. The compiler forces you to handle the `None` case before you can access the value inside a `Some`, eliminating an entire class of bugs.\n\n---",
    "content": "## Guideline\n\nRepresent values that may be absent with `Option<A>`. Use `Option.some(value)` to represent a present value and `Option.none()` for an absent one. This creates a container that forces you to handle both possibilities.\n\n---\n\n## Rationale\n\nFunctions that can return a value or `null`/`undefined` are a primary source of runtime errors in TypeScript (`Cannot read properties of null`).\n\nThe `Option` type solves this by making the possibility of an absent value explicit in the type system. A function that returns `Option<User>` cannot be mistaken for a function that returns `User`. The compiler forces you to handle the `None` case before you can access the value inside a `Some`, eliminating an entire class of bugs.\n\n---\n\n## Good Example\n\nA function that looks for a user in a database is a classic use case. It might find a user, or it might not. Returning an `Option<User>` makes this contract explicit and safe.\n\n```typescript\nimport { Effect, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst users: User[] = [\n  { id: 1, name: \"Paul\" },\n  { id: 2, name: \"Alex\" },\n];\n\n// This function safely returns an Option, not a User or null.\nconst findUserById = (id: number): Option.Option<User> => {\n  const user = users.find((u) => u.id === id);\n  return Option.fromNullable(user); // A useful helper for existing APIs\n};\n\n// The caller MUST handle both cases.\nconst greeting = (id: number): string =>\n  findUserById(id).pipe(\n    Option.match({\n      onNone: () => \"User not found.\",\n      onSome: (user) => `Welcome, ${user.name}!`,\n    }),\n  );\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(greeting(1)); // \"Welcome, Paul!\"\n  yield* Effect.log(greeting(3)); // \"User not found.\"\n});\n\nEffect.runPromise(program);\n```\n\n## Anti-Pattern\n\nThe anti-pattern is returning a nullable type (e.g., User | null or User | undefined). This relies on the discipline of every single caller to perform a null check. Forgetting even one check can introduce a runtime error.\n\n```typescript\ninterface User {\n\tid: number;\n\tname: string;\n}\nconst users: User[] = [{ id: 1, name: \"Paul\" }];\n\t\n\t// ‚ùå WRONG: This function's return type is less safe.\n\tconst findUserUnsafely = (id: number): User | undefined => {\n\t  return users.find((u) => u.id === id);\n\t};\n\t\n\tconst user = findUserUnsafely(3);\n\t\n\t// This will throw \"TypeError: Cannot read properties of undefined (reading 'name')\"\n\t// because the caller forgot to check if the user exists.\n\tconsole.log(`User's name is ${user.name}`)\n```"
  },
  {
    "id": "data-option",
    "title": "Model Optional Values Safely with Option",
    "description": "Use Option to model values that may be present or absent, making absence explicit and type-safe.",
    "skillLevel": "beginner",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Option } from \"effect\";\n\n// Create an Option from a value\nconst someValue = Option.some(42); // Option<number>\nconst noValue = Option.none(); // Option<never>\n\n// Safely convert a nullable value to Option\nconst fromNullable = Option.fromNullable(Math.random() > 0.5 ? \"hello\" : null); // Option<string>\n\n// Pattern match on Option\nconst result = someValue.pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Use Option in a workflow\nfunction findUser(id: number): Option.Option<{ id: number; name: string }> {\n  return id === 1 ? Option.some({ id, name: \"Alice\" }) : Option.none();\n}\n\n```\n\n**Explanation:**  \n- `Option.some(value)` represents a present value.\n- `Option.none()` represents absence.\n- `Option.fromNullable` safely lifts nullable values into Option.\n- Pattern matching ensures all cases are handled.",
    "antiPattern": "Using `null` or `undefined` to represent absence, or forgetting to handle the \"no value\" case, which leads to runtime errors and less maintainable code.",
    "explanation": "`Option` makes it impossible to forget to handle the \"no value\" case.  \nIt improves code safety, readability, and composability, and is a foundation for robust domain modeling.",
    "content": "# Model Optional Values Safely with `Option`\n\n## Guideline\n\nUse the `Option<A>` data type to represent values that may or may not exist.  \nThis eliminates the need for `null` or `undefined`, making absence explicit and type-safe.\n\n## Rationale\n\n`Option` makes it impossible to forget to handle the \"no value\" case.  \nIt improves code safety, readability, and composability, and is a foundation for robust domain modeling.\n\n## Good Example\n\n```typescript\nimport { Option } from \"effect\";\n\n// Create an Option from a value\nconst someValue = Option.some(42); // Option<number>\nconst noValue = Option.none(); // Option<never>\n\n// Safely convert a nullable value to Option\nconst fromNullable = Option.fromNullable(Math.random() > 0.5 ? \"hello\" : null); // Option<string>\n\n// Pattern match on Option\nconst result = someValue.pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Use Option in a workflow\nfunction findUser(id: number): Option.Option<{ id: number; name: string }> {\n  return id === 1 ? Option.some({ id, name: \"Alice\" }) : Option.none();\n}\n\n```\n\n**Explanation:**  \n- `Option.some(value)` represents a present value.\n- `Option.none()` represents absence.\n- `Option.fromNullable` safely lifts nullable values into Option.\n- Pattern matching ensures all cases are handled.\n\n## Anti-Pattern\n\nUsing `null` or `undefined` to represent absence, or forgetting to handle the \"no value\" case, which leads to runtime errors and less maintainable code."
  },
  {
    "id": "model-validated-domain-types-with-brand",
    "title": "Model Validated Domain Types with Brand",
    "description": "Model validated domain types with Brand.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Brand, Option } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\n\nconst makeEmail = (s: string): Option.Option<Email> =>\n  s.includes(\"@\") ? Option.some(s as Email) : Option.none();\n\n// A function can now trust that its input is a valid email.\nconst sendEmail = (email: Email, body: string) => { /* ... */ };\n```\n\n**Explanation:**  \nBranding ensures that only validated values are used, reducing bugs and\nrepetitive checks.",
    "antiPattern": "\"Primitive obsession\"‚Äîusing raw primitives (`string`, `number`) and performing\nvalidation inside every function that uses them. This is repetitive and\nerror-prone.",
    "explanation": "This pattern moves validation to the boundaries of your system. Once a value\nhas been branded, the rest of your application can trust that it is valid,\neliminating repetitive checks.",
    "content": "# Model Validated Domain Types with Brand\n\n## Guideline\n\nFor domain primitives that have specific rules (e.g., a valid email), create a\nBranded Type. This ensures a value can only be created after passing a\nvalidation check.\n\n## Rationale\n\nThis pattern moves validation to the boundaries of your system. Once a value\nhas been branded, the rest of your application can trust that it is valid,\neliminating repetitive checks.\n\n## Good Example\n\n```typescript\nimport { Brand, Option } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\n\nconst makeEmail = (s: string): Option.Option<Email> =>\n  s.includes(\"@\") ? Option.some(s as Email) : Option.none();\n\n// A function can now trust that its input is a valid email.\nconst sendEmail = (email: Email, body: string) => { /* ... */ };\n```\n\n**Explanation:**  \nBranding ensures that only validated values are used, reducing bugs and\nrepetitive checks.\n\n## Anti-Pattern\n\n\"Primitive obsession\"‚Äîusing raw primitives (`string`, `number`) and performing\nvalidation inside every function that uses them. This is repetitive and\nerror-prone."
  },
  {
    "id": "data-exit",
    "title": "Modeling Effect Results with Exit",
    "description": "Use Exit to capture the outcome of an Effect, including success, failure, and defects, for robust error handling and coordination.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect, Exit } from \"effect\";\n\n// Run an Effect and capture its Exit value\nconst program = Effect.succeed(42);\n\nconst runAndCapture = Effect.runPromiseExit(program); // Promise<Exit<never, number>>\n\n// Pattern match on Exit\nrunAndCapture.then((exit) => {\n  if (Exit.isSuccess(exit)) {\n    console.log(\"Success:\", exit.value);\n  } else if (Exit.isFailure(exit)) {\n    console.error(\"Failure:\", exit.cause);\n  }\n});\n```\n\n**Explanation:**  \n- `Exit` captures both success (`Exit.success(value)`) and failure (`Exit.failure(cause)`).\n- Use `Exit` for robust error handling, supervision, and coordination of concurrent effects.\n- Pattern matching on `Exit` lets you handle all possible outcomes.",
    "antiPattern": "Ignoring the outcome of an effect, or only handling success/failure without distinguishing between error types or defects, which can lead to missed errors and less robust code.",
    "explanation": "When running or supervising effects, you often need to know not just if they succeeded or failed, but *how* they failed (e.g., error vs. defect).  \n`Exit` provides a complete, type-safe summary of an effect's outcome.",
    "content": "# Modeling Effect Results with `Exit`\n\n## Guideline\n\nUse the `Exit<E, A>` data type to represent the result of running an `Effect`, capturing both success and failure (including defects) in a type-safe way.  \n`Exit` is especially useful for coordinating concurrent workflows and robust error handling.\n\n## Rationale\n\nWhen running or supervising effects, you often need to know not just if they succeeded or failed, but *how* they failed (e.g., error vs. defect).  \n`Exit` provides a complete, type-safe summary of an effect's outcome.\n\n## Good Example\n\n```typescript\nimport { Effect, Exit } from \"effect\";\n\n// Run an Effect and capture its Exit value\nconst program = Effect.succeed(42);\n\nconst runAndCapture = Effect.runPromiseExit(program); // Promise<Exit<never, number>>\n\n// Pattern match on Exit\nrunAndCapture.then((exit) => {\n  if (Exit.isSuccess(exit)) {\n    console.log(\"Success:\", exit.value);\n  } else if (Exit.isFailure(exit)) {\n    console.error(\"Failure:\", exit.cause);\n  }\n});\n```\n\n**Explanation:**  \n- `Exit` captures both success (`Exit.success(value)`) and failure (`Exit.failure(cause)`).\n- Use `Exit` for robust error handling, supervision, and coordination of concurrent effects.\n- Pattern matching on `Exit` lets you handle all possible outcomes.\n\n## Anti-Pattern\n\nIgnoring the outcome of an effect, or only handling success/failure without distinguishing between error types or defects, which can lead to missed errors and less robust code."
  },
  {
    "id": "data-case",
    "title": "Modeling Tagged Unions with Data.case",
    "description": "Use Data.case to define tagged unions (ADTs) for modeling domain-specific states and enabling exhaustive pattern matching.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data } from \"effect\";\n\n// Define a tagged union for a simple state machine\ntype State = Data.TaggedEnum<{\n  Loading: {}\n  Success: { data: string }\n  Failure: { error: string }\n}>\nconst { Loading, Success, Failure } = Data.taggedEnum<State>()\n\n// Create instances\nconst state1: State = Loading()\nconst state2: State = Success({ data: \"Hello\" })\nconst state3: State = Failure({ error: \"Oops\" })\n\n// Pattern match on the state\nfunction handleState(state: State): string {\n  switch (state._tag) {\n    case \"Loading\":\n      return \"Loading...\";\n    case \"Success\":\n      return `Data: ${state.data}`;\n    case \"Failure\":\n      return `Error: ${state.error}`;\n  }\n}\n```\n\n**Explanation:**  \n- `Data.case` creates tagged constructors for each state.\n- The `_tag` property enables exhaustive pattern matching.\n- Use for domain modeling, state machines, and error types.",
    "antiPattern": "Using plain objects or enums for domain states, which can lead to illegal states, missed cases, and less type-safe pattern matching.",
    "explanation": "Modeling domain logic with tagged unions ensures that all cases are handled, prevents illegal states, and enables safe, exhaustive pattern matching.  \n`Data.case` provides a concise, type-safe way to define and use ADTs in your application.",
    "content": "# Modeling Tagged Unions with `Data.case`\n\n## Guideline\n\nUse `Data.case` to create tagged unions (algebraic data types, or ADTs) for robust, type-safe domain modeling.  \nTagged unions make it easy to represent and exhaustively handle all possible states of your domain entities.\n\n## Rationale\n\nModeling domain logic with tagged unions ensures that all cases are handled, prevents illegal states, and enables safe, exhaustive pattern matching.  \n`Data.case` provides a concise, type-safe way to define and use ADTs in your application.\n\n## Good Example\n\n```typescript\nimport { Data } from \"effect\";\n\n// Define a tagged union for a simple state machine\ntype State = Data.TaggedEnum<{\n  Loading: {}\n  Success: { data: string }\n  Failure: { error: string }\n}>\nconst { Loading, Success, Failure } = Data.taggedEnum<State>()\n\n// Create instances\nconst state1: State = Loading()\nconst state2: State = Success({ data: \"Hello\" })\nconst state3: State = Failure({ error: \"Oops\" })\n\n// Pattern match on the state\nfunction handleState(state: State): string {\n  switch (state._tag) {\n    case \"Loading\":\n      return \"Loading...\";\n    case \"Success\":\n      return `Data: ${state.data}`;\n    case \"Failure\":\n      return `Error: ${state.error}`;\n  }\n}\n```\n\n**Explanation:**  \n- `Data.case` creates tagged constructors for each state.\n- The `_tag` property enables exhaustive pattern matching.\n- Use for domain modeling, state machines, and error types.\n\n## Anti-Pattern\n\nUsing plain objects or enums for domain states, which can lead to illegal states, missed cases, and less type-safe pattern matching."
  },
  {
    "id": "brand-model-domain-type",
    "title": "Modeling Validated Domain Types with Brand",
    "description": "Use Brand to define types like Email, UserId, or PositiveInt, ensuring only valid values can be constructed and used.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Brand } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Function that only accepts Email, not any string\nfunction sendWelcome(email: Email) {\n  // ...\n}\n\n// Constructing an Email value (unsafe, see next pattern for validation)\nconst email = \"user@example.com\" as Email;\n\nsendWelcome(email); // OK\n// sendWelcome(\"not-an-email\"); // Type error! (commented to allow compilation)\n\n```\n\n**Explanation:**  \n- `Brand.Branded<T, Name>` creates a new type that is distinct from its base type.\n- Only values explicitly branded as `Email` can be used where an `Email` is required.\n- This prevents accidental mixing of domain types.",
    "antiPattern": "Using plain strings or numbers for domain-specific values (like emails, user IDs, or currency codes), which can lead to accidental misuse and bugs that are hard to catch.",
    "explanation": "Branded types add a layer of type safety, ensuring that values like `Email`, `UserId`, or `PositiveInt` are not confused with plain strings or numbers.  \nThey help you catch bugs at compile time and make your code more self-documenting.",
    "content": "# Modeling Validated Domain Types with `Brand`\n\n## Guideline\n\nUse the `Brand` utility to create domain-specific types from primitives like `string` or `number`.  \nThis prevents accidental misuse and makes illegal states unrepresentable in your codebase.\n\n## Rationale\n\nBranded types add a layer of type safety, ensuring that values like `Email`, `UserId`, or `PositiveInt` are not confused with plain strings or numbers.  \nThey help you catch bugs at compile time and make your code more self-documenting.\n\n## Good Example\n\n```typescript\nimport { Brand } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Function that only accepts Email, not any string\nfunction sendWelcome(email: Email) {\n  // ...\n}\n\n// Constructing an Email value (unsafe, see next pattern for validation)\nconst email = \"user@example.com\" as Email;\n\nsendWelcome(email); // OK\n// sendWelcome(\"not-an-email\"); // Type error! (commented to allow compilation)\n\n```\n\n**Explanation:**  \n- `Brand.Branded<T, Name>` creates a new type that is distinct from its base type.\n- Only values explicitly branded as `Email` can be used where an `Email` is required.\n- This prevents accidental mixing of domain types.\n\n## Anti-Pattern\n\nUsing plain strings or numbers for domain-specific values (like emails, user IDs, or currency codes), which can lead to accidental misuse and bugs that are hard to catch."
  },
  {
    "id": "organize-layers-into-composable-modules",
    "title": "Organize Layers into Composable Modules",
    "description": "Organize services into modular Layers that are composed hierarchically to manage complexity in large applications.",
    "skillLevel": "advanced",
    "useCases": [
      "testing"
    ],
    "example": "This example shows a `BaseLayer` with a `Logger`, a `UserModule` that uses the `Logger`, and a final `AppLayer` that wires them together.\n\n### 1. The Base Infrastructure Layer\n\n```typescript\n// src/core/Logger.ts\nimport { Effect } from \"effect\";\n\nexport class Logger extends Effect.Service<Logger>()(\n  \"App/Core/Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.log(`[LOG] ${msg}`)\n    })\n  }\n) {}\n\n// src/features/User/UserRepository.ts\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"App/User/UserRepository\",\n  {\n    // Define implementation that uses Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        findById: (id: number) =>\n          Effect.gen(function* () {\n            yield* logger.log(`Finding user ${id}`);\n            return { id, name: `User ${id}` };\n          })\n      };\n    }),\n    // Declare Logger dependency\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const user = yield* repo.findById(1);\n  return user;\n});\n\n// Run with default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    UserRepository.Default\n  )\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(Effect.provide(programWithLogging, UserRepository.Default));\n```\n\n### 2. The Feature Module Layer\n\n```typescript\n// src/core/Logger.ts\nimport { Effect } from \"effect\";\n\nexport class Logger extends Effect.Service<Logger>()(\n  \"App/Core/Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.sync(() => console.log(`[LOG] ${msg}`))\n    })\n  }\n) {}\n\n// src/features/User/UserRepository.ts\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"App/User/UserRepository\",\n  {\n    // Define implementation that uses Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        findById: (id: number) =>\n          Effect.gen(function* () {\n            yield* logger.log(`Finding user ${id}`);\n            return { id, name: `User ${id}` };\n          })\n      };\n    }),\n    // Declare Logger dependency\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const user = yield* repo.findById(1);\n  return user;\n});\n\n// Run with default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    UserRepository.Default\n  )\n).then(console.log);\n```\n\n### 3. The Final Application Composition\n\n```typescript\n// src/layers.ts\nimport { Layer } from \"effect\";\nimport { BaseLayer } from \"./core\";\nimport { UserModuleLive } from \"./features/User\";\n// import { ProductModuleLive } from \"./features/Product\";\n\nconst AllModules = Layer.mergeAll(UserModuleLive /*, ProductModuleLive */);\n\n// Provide the BaseLayer to all modules at once, creating a self-contained AppLayer.\nexport const AppLayer = Layer.provide(AllModules, BaseLayer);\n```\n\n---",
    "antiPattern": "A flat composition strategy for a large application. While simple at first, it quickly becomes difficult to manage.\n\n```typescript\n// ‚ùå This file becomes huge and hard to navigate in a large project.\nconst AppLayer = Layer.mergeAll(\n  LoggerLive,\n  ConfigLive,\n  DatabaseLive,\n  TracerLive,\n  UserServiceLive,\n  UserRepositoryLive,\n  ProductServiceLive,\n  ProductRepositoryLive,\n  BillingServiceLive,\n  // ...and 50 other services\n);\n```",
    "explanation": "As an application grows, a flat composition strategy where all services are merged into one giant layer becomes unwieldy and hard to reason about. The Composable Modules pattern solves this by introducing structure.\n\nThis approach creates a clean, scalable, and highly testable architecture where complexity is contained within each module. The top-level composition becomes a clear, high-level diagram of your application's architecture, and feature modules can be tested in isolation by providing them with a mocked `BaseLayer`.\n\n---",
    "content": "## Guideline\n\nFor large applications, avoid a single, flat list of services. Instead, structure your application by creating hierarchical layers:\n1.  **`BaseLayer`**: Provides application-wide infrastructure (Logger, Config, Database).\n2.  **`FeatureModule` Layers**: Provide the services for a specific business domain (e.g., `UserModule`, `ProductModule`). These depend on the `BaseLayer`.\n3.  **`AppLayer`**: The top-level layer that composes the feature modules by providing them with the `BaseLayer`.\n\n---\n\n## Rationale\n\nAs an application grows, a flat composition strategy where all services are merged into one giant layer becomes unwieldy and hard to reason about. The Composable Modules pattern solves this by introducing structure.\n\nThis approach creates a clean, scalable, and highly testable architecture where complexity is contained within each module. The top-level composition becomes a clear, high-level diagram of your application's architecture, and feature modules can be tested in isolation by providing them with a mocked `BaseLayer`.\n\n---\n\n## Good Example\n\nThis example shows a `BaseLayer` with a `Logger`, a `UserModule` that uses the `Logger`, and a final `AppLayer` that wires them together.\n\n### 1. The Base Infrastructure Layer\n\n```typescript\n// src/core/Logger.ts\nimport { Effect } from \"effect\";\n\nexport class Logger extends Effect.Service<Logger>()(\n  \"App/Core/Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.log(`[LOG] ${msg}`)\n    })\n  }\n) {}\n\n// src/features/User/UserRepository.ts\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"App/User/UserRepository\",\n  {\n    // Define implementation that uses Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        findById: (id: number) =>\n          Effect.gen(function* () {\n            yield* logger.log(`Finding user ${id}`);\n            return { id, name: `User ${id}` };\n          })\n      };\n    }),\n    // Declare Logger dependency\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const user = yield* repo.findById(1);\n  return user;\n});\n\n// Run with default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    UserRepository.Default\n  )\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(Effect.provide(programWithLogging, UserRepository.Default));\n```\n\n### 2. The Feature Module Layer\n\n```typescript\n// src/core/Logger.ts\nimport { Effect } from \"effect\";\n\nexport class Logger extends Effect.Service<Logger>()(\n  \"App/Core/Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.sync(() => console.log(`[LOG] ${msg}`))\n    })\n  }\n) {}\n\n// src/features/User/UserRepository.ts\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"App/User/UserRepository\",\n  {\n    // Define implementation that uses Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        findById: (id: number) =>\n          Effect.gen(function* () {\n            yield* logger.log(`Finding user ${id}`);\n            return { id, name: `User ${id}` };\n          })\n      };\n    }),\n    // Declare Logger dependency\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const user = yield* repo.findById(1);\n  return user;\n});\n\n// Run with default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    UserRepository.Default\n  )\n).then(console.log);\n```\n\n### 3. The Final Application Composition\n\n```typescript\n// src/layers.ts\nimport { Layer } from \"effect\";\nimport { BaseLayer } from \"./core\";\nimport { UserModuleLive } from \"./features/User\";\n// import { ProductModuleLive } from \"./features/Product\";\n\nconst AllModules = Layer.mergeAll(UserModuleLive /*, ProductModuleLive */);\n\n// Provide the BaseLayer to all modules at once, creating a self-contained AppLayer.\nexport const AppLayer = Layer.provide(AllModules, BaseLayer);\n```\n\n---\n\n## Anti-Pattern\n\nA flat composition strategy for a large application. While simple at first, it quickly becomes difficult to manage.\n\n```typescript\n// ‚ùå This file becomes huge and hard to navigate in a large project.\nconst AppLayer = Layer.mergeAll(\n  LoggerLive,\n  ConfigLive,\n  DatabaseLive,\n  TracerLive,\n  UserServiceLive,\n  UserRepositoryLive,\n  ProductServiceLive,\n  ProductRepositoryLive,\n  BillingServiceLive,\n  // ...and 50 other services\n);\n```"
  },
  {
    "id": "parse-with-schema-decode",
    "title": "Parse and Validate Data with Schema.decode",
    "description": "Parse and validate data with Schema.decode.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Effect, Schema } from \"effect\";\n\ninterface User {\n  name: string;\n}\n\nconst UserSchema = Schema.Struct({\n  name: Schema.String,\n}) as Schema.Schema<User>;\n\nconst processUserInput = (input: unknown) =>\n  Effect.gen(function* () {\n    const user = yield* Schema.decodeUnknown(UserSchema)(input);\n    return `Welcome, ${user.name}!`;\n  }).pipe(\n    Effect.catchTag(\"ParseError\", () => Effect.succeed(\"Invalid user data.\"))\n  );\n\n// Demonstrate the schema parsing\nconst program = Effect.gen(function* () {\n  // Test with valid input\n  const validInput = { name: \"Paul\" };\n  const validResult = yield* processUserInput(validInput);\n  yield* Effect.logInfo(`Valid input result: ${validResult}`);\n\n  // Test with invalid input\n  const invalidInput = { age: 25 }; // Missing 'name' field\n  const invalidResult = yield* processUserInput(invalidInput);\n  yield* Effect.logInfo(`Invalid input result: ${invalidResult}`);\n\n  // Test with completely invalid input\n  const badInput = \"not an object\";\n  const badResult = yield* processUserInput(badInput);\n  yield* Effect.logInfo(`Bad input result: ${badResult}`);\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Schema.decode` integrates parsing and validation into the Effect workflow,\nmaking error handling composable and type-safe.",
    "antiPattern": "Using `Schema.parse(schema)(input)`, as it throws an exception. This forces\nyou to use `try/catch` blocks, which breaks the composability of Effect.",
    "explanation": "Unlike the older `Schema.parse` which throws, `Schema.decode` is fully\nintegrated into the Effect ecosystem, allowing you to handle validation\nfailures gracefully with operators like `Effect.catchTag`.",
    "content": "# Parse and Validate Data with Schema.decode\n\n## Guideline\n\nWhen you need to parse or validate data against a `Schema`, use the\n`Schema.decode(schema)` function. It takes an `unknown` input and returns an\n`Effect`.\n\n## Rationale\n\nUnlike the older `Schema.parse` which throws, `Schema.decode` is fully\nintegrated into the Effect ecosystem, allowing you to handle validation\nfailures gracefully with operators like `Effect.catchTag`.\n\n## Good Example\n\n```typescript\nimport { Effect, Schema } from \"effect\";\n\ninterface User {\n  name: string;\n}\n\nconst UserSchema = Schema.Struct({\n  name: Schema.String,\n}) as Schema.Schema<User>;\n\nconst processUserInput = (input: unknown) =>\n  Effect.gen(function* () {\n    const user = yield* Schema.decodeUnknown(UserSchema)(input);\n    return `Welcome, ${user.name}!`;\n  }).pipe(\n    Effect.catchTag(\"ParseError\", () => Effect.succeed(\"Invalid user data.\"))\n  );\n\n// Demonstrate the schema parsing\nconst program = Effect.gen(function* () {\n  // Test with valid input\n  const validInput = { name: \"Paul\" };\n  const validResult = yield* processUserInput(validInput);\n  yield* Effect.logInfo(`Valid input result: ${validResult}`);\n\n  // Test with invalid input\n  const invalidInput = { age: 25 }; // Missing 'name' field\n  const invalidResult = yield* processUserInput(invalidInput);\n  yield* Effect.logInfo(`Invalid input result: ${invalidResult}`);\n\n  // Test with completely invalid input\n  const badInput = \"not an object\";\n  const badResult = yield* processUserInput(badInput);\n  yield* Effect.logInfo(`Bad input result: ${badResult}`);\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Schema.decode` integrates parsing and validation into the Effect workflow,\nmaking error handling composable and type-safe.\n\n## Anti-Pattern\n\nUsing `Schema.parse(schema)(input)`, as it throws an exception. This forces\nyou to use `try/catch` blocks, which breaks the composability of Effect."
  },
  {
    "id": "poll-for-status-until-task-completes",
    "title": "Poll for Status Until a Task Completes",
    "description": "Use Effect.race to run a repeating polling task that is automatically interrupted when a main task completes.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This program simulates a long-running data processing job. While it's running, a separate effect polls for its status every 2 seconds. When the main job finishes after 10 seconds, the polling automatically stops.\n\n```typescript\nimport { Effect, Schedule, Duration } from \"effect\";\n\n// The main task that takes a long time to complete\nconst longRunningJob = Effect.log(\"Data processing complete!\").pipe(\n  Effect.delay(Duration.seconds(10)),\n);\n\n// The polling task that checks the status\nconst pollStatus = Effect.log(\"Polling for job status: In Progress...\");\n\n// A schedule that repeats the polling task every 2 seconds, forever\nconst pollingSchedule = Schedule.fixed(Duration.seconds(2));\n\n// The complete polling effect that will run indefinitely until interrupted\nconst repeatingPoller = pollStatus.pipe(Effect.repeat(pollingSchedule));\n\n// Race the main job against the poller.\n// The longRunningJob will win after 10 seconds, interrupting the poller.\nconst program = Effect.race(longRunningJob, repeatingPoller);\n\nEffect.runPromise(program);\n/*\nOutput:\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nData processing complete!\n*/\n```\n\n---",
    "antiPattern": "Manually managing the lifecycle of the polling fiber. This is more verbose, imperative, and error-prone. You have to remember to interrupt the polling fiber in all possible exit paths (success, failure, etc.), which `Effect.race` does for you automatically.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\nimport { longRunningJob, repeatingPoller } from \"./somewhere\";\n\n// ‚ùå WRONG: Manual fiber management is complex.\nconst program = Effect.gen(function* () {\n  // Manually fork the poller into the background\n  const pollerFiber = yield* Effect.fork(repeatingPoller);\n\n  try {\n    // Run the main job\n    const result = yield* longRunningJob;\n    return result;\n  } finally {\n    // You MUST remember to interrupt the poller when you're done.\n    yield* Fiber.interrupt(pollerFiber);\n  }\n});\n```",
    "explanation": "This pattern elegantly solves the problem of coordinating a long-running job with a status-checking mechanism. Instead of manually managing fibers with `fork` and `interrupt`, you can declare this relationship with `Effect.race`.\n\nThe key is that the polling effect is set up to repeat on a schedule that runs indefinitely (or for a very long time). Because it never completes on its own, it can never \"win\" the race. The main task is the only one that can complete successfully. When it does, it wins the race, and Effect's structured concurrency guarantees that the losing effect (the poller) is safely interrupted.\n\nThis creates a self-contained, declarative, and leak-free unit of work.\n\n---",
    "content": "## Guideline\n\nTo run a periodic task (a \"poller\") that should only run for the duration of another main task, combine them using `Effect.race`. The main task will \"win\" the race upon completion, which automatically interrupts and cleans up the repeating polling effect.\n\n---\n\n## Rationale\n\nThis pattern elegantly solves the problem of coordinating a long-running job with a status-checking mechanism. Instead of manually managing fibers with `fork` and `interrupt`, you can declare this relationship with `Effect.race`.\n\nThe key is that the polling effect is set up to repeat on a schedule that runs indefinitely (or for a very long time). Because it never completes on its own, it can never \"win\" the race. The main task is the only one that can complete successfully. When it does, it wins the race, and Effect's structured concurrency guarantees that the losing effect (the poller) is safely interrupted.\n\nThis creates a self-contained, declarative, and leak-free unit of work.\n\n---\n\n## Good Example\n\nThis program simulates a long-running data processing job. While it's running, a separate effect polls for its status every 2 seconds. When the main job finishes after 10 seconds, the polling automatically stops.\n\n```typescript\nimport { Effect, Schedule, Duration } from \"effect\";\n\n// The main task that takes a long time to complete\nconst longRunningJob = Effect.log(\"Data processing complete!\").pipe(\n  Effect.delay(Duration.seconds(10)),\n);\n\n// The polling task that checks the status\nconst pollStatus = Effect.log(\"Polling for job status: In Progress...\");\n\n// A schedule that repeats the polling task every 2 seconds, forever\nconst pollingSchedule = Schedule.fixed(Duration.seconds(2));\n\n// The complete polling effect that will run indefinitely until interrupted\nconst repeatingPoller = pollStatus.pipe(Effect.repeat(pollingSchedule));\n\n// Race the main job against the poller.\n// The longRunningJob will win after 10 seconds, interrupting the poller.\nconst program = Effect.race(longRunningJob, repeatingPoller);\n\nEffect.runPromise(program);\n/*\nOutput:\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nData processing complete!\n*/\n```\n\n---\n\n## Anti-Pattern\n\nManually managing the lifecycle of the polling fiber. This is more verbose, imperative, and error-prone. You have to remember to interrupt the polling fiber in all possible exit paths (success, failure, etc.), which `Effect.race` does for you automatically.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\nimport { longRunningJob, repeatingPoller } from \"./somewhere\";\n\n// ‚ùå WRONG: Manual fiber management is complex.\nconst program = Effect.gen(function* () {\n  // Manually fork the poller into the background\n  const pollerFiber = yield* Effect.fork(repeatingPoller);\n\n  try {\n    // Run the main job\n    const result = yield* longRunningJob;\n    return result;\n  } finally {\n    // You MUST remember to interrupt the poller when you're done.\n    yield* Fiber.interrupt(pollerFiber);\n  }\n});\n```"
  },
  {
    "id": "process-collection-in-parallel-with-foreach",
    "title": "Process a Collection in Parallel with Effect.forEach",
    "description": "Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "Imagine you have a list of 100 user IDs and you need to fetch the data for each one. `Effect.forEach` with a concurrency of 10 will process them in controlled parallel batches.\n\n```typescript\nimport { Clock, Effect } from \"effect\";\n\n// Mock function to simulate fetching a user by ID\nconst fetchUserById = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    yield* Effect.sleep(\"1 second\"); // Simulate network delay\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst userIds = Array.from({ length: 10 }, (_, i) => i + 1);\n\n// Process the entire array, but only run 5 fetches at a time.\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting parallel processing...\");\n\n  const startTime = yield* Clock.currentTimeMillis;\n  const users = yield* Effect.forEach(userIds, fetchUserById, {\n    concurrency: 5, // Limit to 5 concurrent operations\n  });\n  const endTime = yield* Clock.currentTimeMillis;\n\n  yield* Effect.logInfo(\n    `Processed ${users.length} users in ${endTime - startTime}ms`\n  );\n  yield* Effect.logInfo(\n    `First few users: ${JSON.stringify(users.slice(0, 3), null, 2)}`\n  );\n\n  return users;\n});\n\n// The result will be an array of all user objects.\n// The total time will be much less than running them sequentially.\nEffect.runPromise(program);\n\n```\n\n---",
    "antiPattern": "The anti-pattern is using `Effect.all` to process a large or dynamically-sized collection. This can lead to unpredictable and potentially catastrophic resource consumption.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { userIds, fetchUserById } from \"./somewhere\"; // From previous example\n\n// ‚ùå DANGEROUS: This will attempt to start 100 concurrent network requests.\n// If userIds had 10,000 items, this could crash your application or get you blocked by an API.\nconst program = Effect.all(userIds.map(fetchUserById));\n```",
    "explanation": "Running `Effect.all` on a large array of tasks is dangerous. If you have 1,000 items, it will try to start 1,000 concurrent fibers at once, which can exhaust memory, overwhelm your CPU, or hit API rate limits.\n\n`Effect.forEach` with a concurrency limit solves this problem elegantly. It acts as a concurrent processing pool. It will start processing items up to your specified limit (e.g., 10 at a time). As soon as one task finishes, it will pick up the next available item from the list, ensuring that no more than 10 tasks are ever running simultaneously. This provides massive performance gains over sequential processing while maintaining stability and control.\n\n---",
    "content": "## Guideline\n\nTo process an iterable (like an array) of items concurrently, use `Effect.forEach`. To avoid overwhelming systems, always specify the `{ concurrency: number }` option to limit how many effects run at the same time.\n\n---\n\n## Rationale\n\nRunning `Effect.all` on a large array of tasks is dangerous. If you have 1,000 items, it will try to start 1,000 concurrent fibers at once, which can exhaust memory, overwhelm your CPU, or hit API rate limits.\n\n`Effect.forEach` with a concurrency limit solves this problem elegantly. It acts as a concurrent processing pool. It will start processing items up to your specified limit (e.g., 10 at a time). As soon as one task finishes, it will pick up the next available item from the list, ensuring that no more than 10 tasks are ever running simultaneously. This provides massive performance gains over sequential processing while maintaining stability and control.\n\n---\n\n## Good Example\n\nImagine you have a list of 100 user IDs and you need to fetch the data for each one. `Effect.forEach` with a concurrency of 10 will process them in controlled parallel batches.\n\n```typescript\nimport { Clock, Effect } from \"effect\";\n\n// Mock function to simulate fetching a user by ID\nconst fetchUserById = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    yield* Effect.sleep(\"1 second\"); // Simulate network delay\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst userIds = Array.from({ length: 10 }, (_, i) => i + 1);\n\n// Process the entire array, but only run 5 fetches at a time.\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting parallel processing...\");\n\n  const startTime = yield* Clock.currentTimeMillis;\n  const users = yield* Effect.forEach(userIds, fetchUserById, {\n    concurrency: 5, // Limit to 5 concurrent operations\n  });\n  const endTime = yield* Clock.currentTimeMillis;\n\n  yield* Effect.logInfo(\n    `Processed ${users.length} users in ${endTime - startTime}ms`\n  );\n  yield* Effect.logInfo(\n    `First few users: ${JSON.stringify(users.slice(0, 3), null, 2)}`\n  );\n\n  return users;\n});\n\n// The result will be an array of all user objects.\n// The total time will be much less than running them sequentially.\nEffect.runPromise(program);\n\n```\n\n---\n\n## Anti-Pattern\n\nThe anti-pattern is using `Effect.all` to process a large or dynamically-sized collection. This can lead to unpredictable and potentially catastrophic resource consumption.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { userIds, fetchUserById } from \"./somewhere\"; // From previous example\n\n// ‚ùå DANGEROUS: This will attempt to start 100 concurrent network requests.\n// If userIds had 10,000 items, this could crash your application or get you blocked by an API.\nconst program = Effect.all(userIds.map(fetchUserById));\n```"
  },
  {
    "id": "stream-from-file",
    "title": "Process a Large File with Constant Memory",
    "description": "Use Stream.fromReadable with a Node.js Readable stream to process files efficiently.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example demonstrates reading a text file, splitting it into individual lines, and processing each line. The combination of `Stream.fromReadable`, `Stream.decodeText`, and `Stream.splitLines` is a powerful and common pattern for handling text-based files.\n\n```typescript\nimport { FileSystem } from '@effect/platform';\nimport { NodeFileSystem } from '@effect/platform-node';\nimport type { PlatformError } from '@effect/platform/Error';\nimport { Effect, Stream } from 'effect';\nimport * as path from 'node:path';\n\nconst processFile = (\n  filePath: string,\n  content: string\n): Effect.Effect<void, PlatformError, FileSystem.FileSystem> =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Write content to file\n    yield* fs.writeFileString(filePath, content);\n\n    // Create a STREAMING pipeline - reads file in chunks, not all at once\n    const fileStream = fs.readFile(filePath)\n      .pipe(\n        // Decode bytes to text\n        Stream.decodeText('utf-8'),\n        // Split into lines\n        Stream.splitLines,\n        // Process each line\n        Stream.tap((line) => Effect.log(`Processing: ${line}`))\n      );\n\n    // Run the stream to completion\n    yield* Stream.runDrain(fileStream);\n\n    // Clean up file\n    yield* fs.remove(filePath);\n  });\n\nconst program = Effect.gen(function* () {\n  const filePath = path.join(__dirname, 'large-file.txt');\n\n  yield* processFile(\n    filePath,\n    'line 1\\nline 2\\nline 3'\n  ).pipe(\n    Effect.catchAll((error: PlatformError) =>\n      Effect.logError(`Error processing file: ${error.message}`)\n    )\n  );\n});\n\nEffect.runPromise(\n  program.pipe(\n    Effect.provide(NodeFileSystem.layer)\n  ))\n\n  /*\nOutput:\n... level=INFO msg=\"Processing: line 1\"\n... level=INFO msg=\"Processing: line 2\"\n... level=INFO msg=\"Processing: line 3\"\n*/\n```",
    "antiPattern": "The anti-pattern is to use synchronous, memory-intensive functions like `fs.readFileSync`. This approach is simple for tiny files but fails catastrophically for large ones.\n\n```typescript\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nconst filePath = path.join(__dirname, 'large-file.txt');\n// Create a dummy file for the example\nfs.writeFileSync(filePath, 'line 1\\nline 2\\nline 3');\n\ntry {\n  // Anti-pattern: This loads the ENTIRE file into memory as a single buffer.\n  const fileContent = fs.readFileSync(filePath, 'utf-8');\n  const lines = fileContent.split('\\n');\n\n  for (const line of lines) {\n    console.log(`Processing: ${line}`);\n  }\n} catch (err) {\n  console.error('Failed to read file:', err);\n} finally {\n  // Clean up the dummy file\n  fs.unlinkSync(filePath);\n}\n```\n\nThis is a dangerous anti-pattern because:\n\n1.  **It's a Memory Bomb**: If `large-file.txt` were 2GB and your server had 1GB of RAM, this code would immediately crash the process.\n2.  **It Blocks the Event Loop**: `readFileSync` is a synchronous, blocking operation. While it's reading the file from disk, your entire application is frozen and cannot respond to any other requests.\n3.  **It's Not Composable**: You get a giant string that must be processed eagerly. You lose all the benefits of lazy processing, concurrency control, and integrated error handling that `Stream` provides.",
    "explanation": "The most significant advantage of a streaming architecture is its ability to handle datasets far larger than available RAM. When you need to process a multi-gigabyte log file or CSV, loading it all into memory is not an option‚Äîit will crash your application.\n\nThe `Stream.fromReadable` constructor provides a bridge from Node.js's built-in file streaming capabilities to the Effect ecosystem. This approach is superior because:\n\n1.  **Constant Memory Usage**: The file is read in small, manageable chunks. Your application's memory usage remains low and constant, regardless of whether the file is 1 megabyte or 100 gigabytes.\n2.  **Composability**: Once the file is represented as an Effect `Stream`, you can apply the full suite of powerful operators to it: `mapEffect` for concurrent processing, `filter` for selectively choosing lines, `grouped` for batching, and `retry` for resilience.\n3.  **Resource Safety**: Effect's `Stream` is built on `Scope`, which guarantees that the underlying file handle will be closed automatically when the stream finishes, fails, or is interrupted. This prevents resource leaks, a common problem in manual file handling.\n\n---",
    "content": "## Guideline\n\nTo process a large file without consuming excessive memory, create a Node.js `Readable` stream from the file and convert it into an Effect `Stream` using `Stream.fromReadable`.\n\n---\n\n## Rationale\n\nThe most significant advantage of a streaming architecture is its ability to handle datasets far larger than available RAM. When you need to process a multi-gigabyte log file or CSV, loading it all into memory is not an option‚Äîit will crash your application.\n\nThe `Stream.fromReadable` constructor provides a bridge from Node.js's built-in file streaming capabilities to the Effect ecosystem. This approach is superior because:\n\n1.  **Constant Memory Usage**: The file is read in small, manageable chunks. Your application's memory usage remains low and constant, regardless of whether the file is 1 megabyte or 100 gigabytes.\n2.  **Composability**: Once the file is represented as an Effect `Stream`, you can apply the full suite of powerful operators to it: `mapEffect` for concurrent processing, `filter` for selectively choosing lines, `grouped` for batching, and `retry` for resilience.\n3.  **Resource Safety**: Effect's `Stream` is built on `Scope`, which guarantees that the underlying file handle will be closed automatically when the stream finishes, fails, or is interrupted. This prevents resource leaks, a common problem in manual file handling.\n\n---\n\n## Good Example\n\nThis example demonstrates reading a text file, splitting it into individual lines, and processing each line. The combination of `Stream.fromReadable`, `Stream.decodeText`, and `Stream.splitLines` is a powerful and common pattern for handling text-based files.\n\n```typescript\nimport { FileSystem } from '@effect/platform';\nimport { NodeFileSystem } from '@effect/platform-node';\nimport type { PlatformError } from '@effect/platform/Error';\nimport { Effect, Stream } from 'effect';\nimport * as path from 'node:path';\n\nconst processFile = (\n  filePath: string,\n  content: string\n): Effect.Effect<void, PlatformError, FileSystem.FileSystem> =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Write content to file\n    yield* fs.writeFileString(filePath, content);\n\n    // Create a STREAMING pipeline - reads file in chunks, not all at once\n    const fileStream = fs.readFile(filePath)\n      .pipe(\n        // Decode bytes to text\n        Stream.decodeText('utf-8'),\n        // Split into lines\n        Stream.splitLines,\n        // Process each line\n        Stream.tap((line) => Effect.log(`Processing: ${line}`))\n      );\n\n    // Run the stream to completion\n    yield* Stream.runDrain(fileStream);\n\n    // Clean up file\n    yield* fs.remove(filePath);\n  });\n\nconst program = Effect.gen(function* () {\n  const filePath = path.join(__dirname, 'large-file.txt');\n\n  yield* processFile(\n    filePath,\n    'line 1\\nline 2\\nline 3'\n  ).pipe(\n    Effect.catchAll((error: PlatformError) =>\n      Effect.logError(`Error processing file: ${error.message}`)\n    )\n  );\n});\n\nEffect.runPromise(\n  program.pipe(\n    Effect.provide(NodeFileSystem.layer)\n  ))\n\n  /*\nOutput:\n... level=INFO msg=\"Processing: line 1\"\n... level=INFO msg=\"Processing: line 2\"\n... level=INFO msg=\"Processing: line 3\"\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to use synchronous, memory-intensive functions like `fs.readFileSync`. This approach is simple for tiny files but fails catastrophically for large ones.\n\n```typescript\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nconst filePath = path.join(__dirname, 'large-file.txt');\n// Create a dummy file for the example\nfs.writeFileSync(filePath, 'line 1\\nline 2\\nline 3');\n\ntry {\n  // Anti-pattern: This loads the ENTIRE file into memory as a single buffer.\n  const fileContent = fs.readFileSync(filePath, 'utf-8');\n  const lines = fileContent.split('\\n');\n\n  for (const line of lines) {\n    console.log(`Processing: ${line}`);\n  }\n} catch (err) {\n  console.error('Failed to read file:', err);\n} finally {\n  // Clean up the dummy file\n  fs.unlinkSync(filePath);\n}\n```\n\nThis is a dangerous anti-pattern because:\n\n1.  **It's a Memory Bomb**: If `large-file.txt` were 2GB and your server had 1GB of RAM, this code would immediately crash the process.\n2.  **It Blocks the Event Loop**: `readFileSync` is a synchronous, blocking operation. While it's reading the file from disk, your entire application is frozen and cannot respond to any other requests.\n3.  **It's Not Composable**: You get a giant string that must be processed eagerly. You lose all the benefits of lazy processing, concurrency control, and integrated error handling that `Stream` provides."
  },
  {
    "id": "process-a-collection-of-data-asynchronously",
    "title": "Process collections of data asynchronously",
    "description": "Leverage Stream to process collections effectfully with built-in concurrency control and resource safety.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example processes a list of IDs by fetching user data for each one. `Stream.mapEffect` is used to apply an effectful function (`getUserById`) to each element, with concurrency limited to 2 simultaneous requests.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates fetching a user from a database\nconst getUserById = (id: number): Effect.Effect<{ id: number; name: string }, Error> =>\n  Effect.succeed({ id, name: `User ${id}` }).pipe(\n    Effect.delay('100 millis'),\n    Effect.tap(() => Effect.log(`Fetched user ${id}`))\n  );\n\n// The stream-based program\nconst program = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n  // Process each item with an Effect, limiting concurrency to 2\n  Stream.mapEffect(getUserById, { concurrency: 2 }),\n  // Run the stream and collect all results into a Chunk\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const users = yield* program;\n  yield* Effect.log(`All users fetched: ${JSON.stringify(Chunk.toArray(users))}`);\n  return users;\n});\n\nEffect.runPromise(programWithLogging);\n```",
    "antiPattern": "A common but flawed approach is to use `Promise.all` to handle multiple asynchronous operations. This method lacks the safety, control, and composability inherent to Effect's `Stream`.\n\n```typescript\n// A mock function that returns a Promise\nconst getUserByIdAsPromise = (id: number): Promise<{ id: number; name: string }> =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(`Fetched user ${id}`);\n      resolve({ id, name: `User ${id}` });\n    }, 100);\n  });\n\n// The Promise-based program\nconst ids = [1, 2, 3, 4, 5];\nconst promises = ids.map(getUserByIdAsPromise);\n\nPromise.all(promises).then((users) => {\n  console.log('All users fetched:', users);\n});\n```\n\nThis anti-pattern is problematic because it immediately executes all promises in parallel with no concurrency limit, it does not benefit from Effect's structured concurrency for safe interruption, and it breaks out of the Effect context, losing composability with features like logging, retries, and dependency management.",
    "explanation": "`Stream` is a fundamental data type in Effect for handling collections of data, especially in asynchronous contexts. Unlike a simple array, a `Stream` is lazy and pull-based, meaning it only computes or fetches elements as they are needed, making it highly efficient for large or infinite datasets.\n\nThe primary benefits of using `Stream` are:\n\n1.  **Concurrency Control**: `Stream` provides powerful and simple operators like `mapEffect` that have built-in concurrency management. This prevents overwhelming downstream services with too many parallel requests.\n2.  **Resource Safety**: `Stream` is built on `Scope`, ensuring that any resources opened during the stream's operation (like file handles or network connections) are safely and reliably closed, even in the case of errors or interruption.\n3.  **Composability**: Streams are highly composable. They can be filtered, mapped, transformed, and combined with other Effect data types seamlessly, allowing you to build complex data processing pipelines that remain readable and type-safe.\n4.  **Resilience**: `Stream` integrates with `Schedule` to provide sophisticated retry and repeat logic, and with Effect's structured concurrency to ensure that failures in one part of a pipeline lead to a clean and predictable shutdown of the entire process.\n\n---",
    "content": "## Guideline\n\nFor processing collections that involve asynchronous or effectful operations, use `Stream` to ensure resource safety, control concurrency, and maintain composability.\n\n---\n\n## Rationale\n\n`Stream` is a fundamental data type in Effect for handling collections of data, especially in asynchronous contexts. Unlike a simple array, a `Stream` is lazy and pull-based, meaning it only computes or fetches elements as they are needed, making it highly efficient for large or infinite datasets.\n\nThe primary benefits of using `Stream` are:\n\n1.  **Concurrency Control**: `Stream` provides powerful and simple operators like `mapEffect` that have built-in concurrency management. This prevents overwhelming downstream services with too many parallel requests.\n2.  **Resource Safety**: `Stream` is built on `Scope`, ensuring that any resources opened during the stream's operation (like file handles or network connections) are safely and reliably closed, even in the case of errors or interruption.\n3.  **Composability**: Streams are highly composable. They can be filtered, mapped, transformed, and combined with other Effect data types seamlessly, allowing you to build complex data processing pipelines that remain readable and type-safe.\n4.  **Resilience**: `Stream` integrates with `Schedule` to provide sophisticated retry and repeat logic, and with Effect's structured concurrency to ensure that failures in one part of a pipeline lead to a clean and predictable shutdown of the entire process.\n\n---\n\n## Good Example\n\nThis example processes a list of IDs by fetching user data for each one. `Stream.mapEffect` is used to apply an effectful function (`getUserById`) to each element, with concurrency limited to 2 simultaneous requests.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates fetching a user from a database\nconst getUserById = (id: number): Effect.Effect<{ id: number; name: string }, Error> =>\n  Effect.succeed({ id, name: `User ${id}` }).pipe(\n    Effect.delay('100 millis'),\n    Effect.tap(() => Effect.log(`Fetched user ${id}`))\n  );\n\n// The stream-based program\nconst program = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n  // Process each item with an Effect, limiting concurrency to 2\n  Stream.mapEffect(getUserById, { concurrency: 2 }),\n  // Run the stream and collect all results into a Chunk\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const users = yield* program;\n  yield* Effect.log(`All users fetched: ${JSON.stringify(Chunk.toArray(users))}`);\n  return users;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n## Anti-Pattern\n\nA common but flawed approach is to use `Promise.all` to handle multiple asynchronous operations. This method lacks the safety, control, and composability inherent to Effect's `Stream`.\n\n```typescript\n// A mock function that returns a Promise\nconst getUserByIdAsPromise = (id: number): Promise<{ id: number; name: string }> =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(`Fetched user ${id}`);\n      resolve({ id, name: `User ${id}` });\n    }, 100);\n  });\n\n// The Promise-based program\nconst ids = [1, 2, 3, 4, 5];\nconst promises = ids.map(getUserByIdAsPromise);\n\nPromise.all(promises).then((users) => {\n  console.log('All users fetched:', users);\n});\n```\n\nThis anti-pattern is problematic because it immediately executes all promises in parallel with no concurrency limit, it does not benefit from Effect's structured concurrency for safe interruption, and it breaks out of the Effect context, losing composability with features like logging, retries, and dependency management."
  },
  {
    "id": "stream-process-concurrently",
    "title": "Process Items Concurrently",
    "description": "Use Stream.mapEffect with the `concurrency` option to process stream items in parallel.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example processes four items, each taking one second. By setting `concurrency: 2`, the total runtime is approximately two seconds instead of four, because items are processed in parallel pairs.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// A mock function that simulates a slow I/O operation\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.log(`Starting item ${id}...`).pipe(\n    Effect.delay('1 second'),\n    Effect.map(() => `Finished item ${id}`),\n    Effect.tap(Effect.log)\n  );\n\nconst ids = [1, 2, 3, 4];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // Process up to 2 items concurrently\n  Stream.mapEffect(processItem, { concurrency: 2 }),\n  Stream.runDrain\n);\n\n// Measure the total time taken\nconst timedProgram = Effect.timed(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const [duration, _] = yield* timedProgram;\n  const durationMs = Number(duration);\n  yield* Effect.log(`\\nTotal time: ${Math.round(durationMs / 1000)} seconds`);\n  return duration;\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 3...\"\n... level=INFO msg=\"Finished item 2\"\n... level=INFO msg=\"Starting item 4...\"\n... level=INFO msg=\"Finished item 3\"\n... level=INFO msg=\"Finished item 4\"\n\nTotal time: 2 seconds\n*/\n```",
    "antiPattern": "The anti-pattern is to process I/O-bound tasks sequentially. This is the default behavior of `Stream.mapEffect` if you don't specify a concurrency level, and it leads to poor performance.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n// ... same processItem function ...\n\nconst ids = [1, 2, 3, 4];\n\n// Processing sequentially (default concurrency is 1)\nconst program = Stream.fromIterable(ids).pipe(\n  Stream.mapEffect(processItem), // No concurrency option\n  Stream.runDrain\n);\n\nconst timedProgram = Effect.timed(program);\n\nEffect.runPromise(timedProgram).then(([duration, _]) => {\n  console.log(`\\nTotal time: ${Math.round(duration.millis / 1000)} seconds`);\n});\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 2\"\n... etc.\n\nTotal time: 4 seconds\n*/\n```\n\nWhile sequential processing is sometimes necessary to preserve order or avoid race conditions, it is a performance anti-pattern for independent, I/O-bound tasks. The concurrent approach is almost always preferable in such cases.",
    "explanation": "For many data pipelines, the most time-consuming step is performing an I/O-bound operation for each item, such as calling an API or querying a database. Processing these items one by one (sequentially) is safe but slow, as the entire pipeline waits for each operation to complete before starting the next.\n\n`Stream.mapEffect`'s `concurrency` option is the solution. It provides a simple, declarative way to introduce controlled parallelism into your pipeline.\n\n1.  **Performance Boost**: It allows the stream to work on multiple items at once, drastically reducing the total execution time for I/O-bound tasks.\n2.  **Controlled Parallelism**: Unlike `Promise.all` which runs everything at once, you specify the *exact* number of concurrent operations. This is crucial for stability, as it prevents your application from overwhelming downstream services or exhausting its own resources (like file handles or network sockets).\n3.  **Automatic Backpressure**: The stream will not pull new items from the source faster than the concurrent slots can process them. This backpressure is handled automatically, preventing memory issues.\n4.  **Structured Concurrency**: It's fully integrated with Effect's runtime. If any concurrent operation fails, all other in-flight operations for that stream are immediately and reliably interrupted, preventing wasted work and ensuring clean shutdowns.\n\n---",
    "content": "## Guideline\n\nTo process items in a stream concurrently, use `Stream.mapEffect` and provide a value greater than 1 to its `concurrency` option.\n\n---\n\n## Rationale\n\nFor many data pipelines, the most time-consuming step is performing an I/O-bound operation for each item, such as calling an API or querying a database. Processing these items one by one (sequentially) is safe but slow, as the entire pipeline waits for each operation to complete before starting the next.\n\n`Stream.mapEffect`'s `concurrency` option is the solution. It provides a simple, declarative way to introduce controlled parallelism into your pipeline.\n\n1.  **Performance Boost**: It allows the stream to work on multiple items at once, drastically reducing the total execution time for I/O-bound tasks.\n2.  **Controlled Parallelism**: Unlike `Promise.all` which runs everything at once, you specify the *exact* number of concurrent operations. This is crucial for stability, as it prevents your application from overwhelming downstream services or exhausting its own resources (like file handles or network sockets).\n3.  **Automatic Backpressure**: The stream will not pull new items from the source faster than the concurrent slots can process them. This backpressure is handled automatically, preventing memory issues.\n4.  **Structured Concurrency**: It's fully integrated with Effect's runtime. If any concurrent operation fails, all other in-flight operations for that stream are immediately and reliably interrupted, preventing wasted work and ensuring clean shutdowns.\n\n---\n\n## Good Example\n\nThis example processes four items, each taking one second. By setting `concurrency: 2`, the total runtime is approximately two seconds instead of four, because items are processed in parallel pairs.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// A mock function that simulates a slow I/O operation\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.log(`Starting item ${id}...`).pipe(\n    Effect.delay('1 second'),\n    Effect.map(() => `Finished item ${id}`),\n    Effect.tap(Effect.log)\n  );\n\nconst ids = [1, 2, 3, 4];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // Process up to 2 items concurrently\n  Stream.mapEffect(processItem, { concurrency: 2 }),\n  Stream.runDrain\n);\n\n// Measure the total time taken\nconst timedProgram = Effect.timed(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const [duration, _] = yield* timedProgram;\n  const durationMs = Number(duration);\n  yield* Effect.log(`\\nTotal time: ${Math.round(durationMs / 1000)} seconds`);\n  return duration;\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 3...\"\n... level=INFO msg=\"Finished item 2\"\n... level=INFO msg=\"Starting item 4...\"\n... level=INFO msg=\"Finished item 3\"\n... level=INFO msg=\"Finished item 4\"\n\nTotal time: 2 seconds\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to process I/O-bound tasks sequentially. This is the default behavior of `Stream.mapEffect` if you don't specify a concurrency level, and it leads to poor performance.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n// ... same processItem function ...\n\nconst ids = [1, 2, 3, 4];\n\n// Processing sequentially (default concurrency is 1)\nconst program = Stream.fromIterable(ids).pipe(\n  Stream.mapEffect(processItem), // No concurrency option\n  Stream.runDrain\n);\n\nconst timedProgram = Effect.timed(program);\n\nEffect.runPromise(timedProgram).then(([duration, _]) => {\n  console.log(`\\nTotal time: ${Math.round(duration.millis / 1000)} seconds`);\n});\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 2\"\n... etc.\n\nTotal time: 4 seconds\n*/\n```\n\nWhile sequential processing is sometimes necessary to preserve order or avoid race conditions, it is a performance anti-pattern for independent, I/O-bound tasks. The concurrent approach is almost always preferable in such cases."
  },
  {
    "id": "stream-process-in-batches",
    "title": "Process Items in Batches",
    "description": "Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example processes 10 users. By using `Stream.grouped(5)`, it transforms the stream of 10 individual users into a stream of two chunks (each a batch of 5). The `saveUsersInBulk` function is then called only twice, once for each batch.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates a bulk database insert\nconst saveUsersInBulk = (\n  userBatch: Chunk.Chunk<{ id: number }>\n): Effect.Effect<void, Error> =>\n  Effect.log(\n    `Saving batch of ${userBatch.length} users: ${Chunk.toArray(userBatch)\n      .map((u) => u.id)\n      .join(', ')}`\n  );\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Group the stream of users into batches of 5\n  Stream.grouped(5),\n  // Process each batch with our bulk save function\n  Stream.mapEffect(saveUsersInBulk, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving batch of 5 users: 1, 2, 3, 4, 5\"\n... level=INFO msg=\"Saving batch of 5 users: 6, 7, 8, 9, 10\"\n*/\n```",
    "antiPattern": "The anti-pattern is to process items one by one when a more efficient bulk operation is available. This is a common performance bottleneck.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// A mock function that saves one user at a time\nconst saveUser = (user: { id: number }): Effect.Effect<void, Error> =>\n  Effect.log(`Saving single user: ${user.id}`);\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Process each user individually, leading to 10 separate \"saves\"\n  Stream.mapEffect(saveUser, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving single user: 1\"\n... level=INFO msg=\"Saving single user: 2\"\n... (and so on for all 10 users)\n*/\n```\n\nThis individual processing approach is an anti-pattern because it creates unnecessary overhead. If each `saveUser` call took 50ms of network latency, the total time would be over 500ms. The batched approach might only take 100ms (2 batches * 50ms), resulting in a 5x performance improvement.",
    "explanation": "When interacting with external systems like databases or APIs, making one request per item is often incredibly inefficient. The network latency and overhead of each individual call can dominate the total processing time. Most high-performance systems offer bulk or batch endpoints to mitigate this.\n\n`Stream.grouped(n)` provides a simple, declarative way to prepare your data for these bulk operations:\n\n1.  **Performance Optimization**: It dramatically reduces the number of network roundtrips. A single API call with 100 items is far faster than 100 individual API calls.\n2.  **Declarative Batching**: It abstracts away the tedious and error-prone manual logic of counting items, managing temporary buffers, and deciding when to send a batch.\n3.  **Seamless Composition**: It transforms a `Stream<A>` into a `Stream<Chunk<A>>`. This new stream of chunks can be piped directly into `Stream.mapEffect`, allowing you to process each batch concurrently.\n4.  **Handles Leftovers**: The operator automatically handles the final, smaller batch if the total number of items is not perfectly divisible by the batch size.\n\n---",
    "content": "## Guideline\n\nTo process items in fixed-size batches for performance, use the `Stream.grouped(batchSize)` operator to transform a stream of individual items into a stream of `Chunk`s.\n\n---\n\n## Rationale\n\nWhen interacting with external systems like databases or APIs, making one request per item is often incredibly inefficient. The network latency and overhead of each individual call can dominate the total processing time. Most high-performance systems offer bulk or batch endpoints to mitigate this.\n\n`Stream.grouped(n)` provides a simple, declarative way to prepare your data for these bulk operations:\n\n1.  **Performance Optimization**: It dramatically reduces the number of network roundtrips. A single API call with 100 items is far faster than 100 individual API calls.\n2.  **Declarative Batching**: It abstracts away the tedious and error-prone manual logic of counting items, managing temporary buffers, and deciding when to send a batch.\n3.  **Seamless Composition**: It transforms a `Stream<A>` into a `Stream<Chunk<A>>`. This new stream of chunks can be piped directly into `Stream.mapEffect`, allowing you to process each batch concurrently.\n4.  **Handles Leftovers**: The operator automatically handles the final, smaller batch if the total number of items is not perfectly divisible by the batch size.\n\n---\n\n## Good Example\n\nThis example processes 10 users. By using `Stream.grouped(5)`, it transforms the stream of 10 individual users into a stream of two chunks (each a batch of 5). The `saveUsersInBulk` function is then called only twice, once for each batch.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates a bulk database insert\nconst saveUsersInBulk = (\n  userBatch: Chunk.Chunk<{ id: number }>\n): Effect.Effect<void, Error> =>\n  Effect.log(\n    `Saving batch of ${userBatch.length} users: ${Chunk.toArray(userBatch)\n      .map((u) => u.id)\n      .join(', ')}`\n  );\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Group the stream of users into batches of 5\n  Stream.grouped(5),\n  // Process each batch with our bulk save function\n  Stream.mapEffect(saveUsersInBulk, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving batch of 5 users: 1, 2, 3, 4, 5\"\n... level=INFO msg=\"Saving batch of 5 users: 6, 7, 8, 9, 10\"\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to process items one by one when a more efficient bulk operation is available. This is a common performance bottleneck.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// A mock function that saves one user at a time\nconst saveUser = (user: { id: number }): Effect.Effect<void, Error> =>\n  Effect.log(`Saving single user: ${user.id}`);\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Process each user individually, leading to 10 separate \"saves\"\n  Stream.mapEffect(saveUser, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving single user: 1\"\n... level=INFO msg=\"Saving single user: 2\"\n... (and so on for all 10 users)\n*/\n```\n\nThis individual processing approach is an anti-pattern because it creates unnecessary overhead. If each `saveUser` call took 50ms of network latency, the total time would be over 500ms. The batched approach might only take 100ms (2 batches * 50ms), resulting in a 5x performance improvement."
  },
  {
    "id": "process-streaming-data-with-stream",
    "title": "Process Streaming Data with Stream",
    "description": "Use Stream to model and process data that arrives over time in a composable, efficient way.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "This example demonstrates creating a `Stream` from a paginated API. The `Stream` will make API calls as needed, processing one page of users at a time without ever holding the entire user list in memory.\n\n```typescript\nimport { Effect, Stream, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\ninterface PaginatedResponse {\n  users: User[];\n  nextPage: number | null;\n}\n\n// A mock API call that returns a page of users\nconst fetchUserPage = (\n  page: number,\n): Effect.Effect<PaginatedResponse, \"ApiError\"> =>\n  Effect.succeed(\n    page < 3\n      ? {\n          users: [\n            { id: page * 2 + 1, name: `User ${page * 2 + 1}` },\n            { id: page * 2 + 2, name: `User ${page * 2 + 2}` },\n          ],\n          nextPage: page + 1,\n        }\n      : { users: [], nextPage: null },\n  ).pipe(Effect.delay(\"50 millis\"));\n\n// Stream.paginateEffect creates a stream from a paginated source\nconst userStream: Stream.Stream<User, \"ApiError\"> = Stream.paginateEffect(0, (page) =>\n  fetchUserPage(page).pipe(\n    Effect.map((response) => [\n      response.users,\n      Option.fromNullable(response.nextPage)\n    ] as const),\n  ),\n).pipe(\n  // Flatten the stream of user arrays into a stream of individual users\n  Stream.flatMap((users) => Stream.fromIterable(users)),\n);\n\n// We can now process the stream of users.\n// Stream.runForEach will pull from the stream until it's exhausted.\nconst program = Stream.runForEach(userStream, (user: User) =>\n  Effect.log(`Processing user: ${user.name}`),\n);\n\nconst programWithErrorHandling = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Stream processing error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n```\n\n---",
    "antiPattern": "Manually managing pagination state with recursive functions. This is complex, stateful, and easy to get wrong. It also requires loading all results into memory, which is inefficient for large datasets.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { fetchUserPage } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: Manual, stateful, and inefficient recursion.\nconst fetchAllUsers = (\n  page: number,\n  acc: any[],\n): Effect.Effect<any[], \"ApiError\"> =>\n  fetchUserPage(page).pipe(\n    Effect.flatMap((response) => {\n      const allUsers = [...acc, ...response.users];\n      if (response.nextPage) {\n        return fetchAllUsers(response.nextPage, allUsers);\n      }\n      return Effect.succeed(allUsers);\n    }),\n  );\n\n// This holds all users in memory at once.\nconst program = fetchAllUsers(0, []);\n```",
    "explanation": "Some data sources don't fit the one-shot request/response model of `Effect`. For example:\n-   Reading a multi-gigabyte file from disk.\n-   Receiving messages from a WebSocket.\n-   Fetching results from a paginated API.\n\nLoading all this data into memory at once would be inefficient or impossible. `Stream` solves this by allowing you to process the data in chunks as it arrives. It provides a rich API of composable operators (`map`, `filter`, `run`, etc.) that mirror those on `Effect` and `Array`, but are designed for streaming data. This allows you to build efficient, constant-memory data processing pipelines.\n\n---",
    "content": "## Guideline\n\nWhen dealing with a sequence of data that arrives asynchronously, model it as a `Stream`. A `Stream<A, E, R>` is like an asynchronous, effectful `Array`. It represents a sequence of values of type `A` that may fail with an error `E` and requires services `R`.\n\n---\n\n## Rationale\n\nSome data sources don't fit the one-shot request/response model of `Effect`. For example:\n-   Reading a multi-gigabyte file from disk.\n-   Receiving messages from a WebSocket.\n-   Fetching results from a paginated API.\n\nLoading all this data into memory at once would be inefficient or impossible. `Stream` solves this by allowing you to process the data in chunks as it arrives. It provides a rich API of composable operators (`map`, `filter`, `run`, etc.) that mirror those on `Effect` and `Array`, but are designed for streaming data. This allows you to build efficient, constant-memory data processing pipelines.\n\n---\n\n## Good Example\n\nThis example demonstrates creating a `Stream` from a paginated API. The `Stream` will make API calls as needed, processing one page of users at a time without ever holding the entire user list in memory.\n\n```typescript\nimport { Effect, Stream, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\ninterface PaginatedResponse {\n  users: User[];\n  nextPage: number | null;\n}\n\n// A mock API call that returns a page of users\nconst fetchUserPage = (\n  page: number,\n): Effect.Effect<PaginatedResponse, \"ApiError\"> =>\n  Effect.succeed(\n    page < 3\n      ? {\n          users: [\n            { id: page * 2 + 1, name: `User ${page * 2 + 1}` },\n            { id: page * 2 + 2, name: `User ${page * 2 + 2}` },\n          ],\n          nextPage: page + 1,\n        }\n      : { users: [], nextPage: null },\n  ).pipe(Effect.delay(\"50 millis\"));\n\n// Stream.paginateEffect creates a stream from a paginated source\nconst userStream: Stream.Stream<User, \"ApiError\"> = Stream.paginateEffect(0, (page) =>\n  fetchUserPage(page).pipe(\n    Effect.map((response) => [\n      response.users,\n      Option.fromNullable(response.nextPage)\n    ] as const),\n  ),\n).pipe(\n  // Flatten the stream of user arrays into a stream of individual users\n  Stream.flatMap((users) => Stream.fromIterable(users)),\n);\n\n// We can now process the stream of users.\n// Stream.runForEach will pull from the stream until it's exhausted.\nconst program = Stream.runForEach(userStream, (user: User) =>\n  Effect.log(`Processing user: ${user.name}`),\n);\n\nconst programWithErrorHandling = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Stream processing error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n```\n\n---\n\n## Anti-Pattern\n\nManually managing pagination state with recursive functions. This is complex, stateful, and easy to get wrong. It also requires loading all results into memory, which is inefficient for large datasets.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { fetchUserPage } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: Manual, stateful, and inefficient recursion.\nconst fetchAllUsers = (\n  page: number,\n  acc: any[],\n): Effect.Effect<any[], \"ApiError\"> =>\n  fetchUserPage(page).pipe(\n    Effect.flatMap((response) => {\n      const allUsers = [...acc, ...response.users];\n      if (response.nextPage) {\n        return fetchAllUsers(response.nextPage, allUsers);\n      }\n      return Effect.succeed(allUsers);\n    }),\n  );\n\n// This holds all users in memory at once.\nconst program = fetchAllUsers(0, []);\n```"
  },
  {
    "id": "provide-config-layer",
    "title": "Provide Configuration to Your App via a Layer",
    "description": "Provide configuration to your app via a Layer.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "````typescript\nimport { Effect, Layer } from \"effect\";\n\nclass ServerConfig extends Effect.Service<ServerConfig>()(\n  \"ServerConfig\",\n  {\n    sync: () => ({\n      port: process.env.PORT ? parseInt(process.env.PORT) : 8080\n    })\n  }\n) {}\n\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig;\n  yield* Effect.log(`Starting application on port ${config.port}...`);\n});\n\nconst programWithErrorHandling = Effect.provide(program, ServerConfig.Default).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n````\n\n**Explanation:**  \nThis approach makes configuration available contextually, supporting better testing and modularity.",
    "antiPattern": "Manually reading environment variables deep inside business logic. This tightly couples that logic to the external environment, making it difficult to test and reuse.",
    "explanation": "Integrating configuration as a `Layer` plugs it directly into Effect's dependency injection system. This makes your configuration available anywhere in the program and dramatically simplifies testing by allowing you to substitute mock configuration.",
    "content": "# Provide Configuration to Your App via a Layer\n\n## Guideline\n\nTransform your configuration schema into a `Layer` using `Config.layer()` and provide it to your main application `Effect`.\n\n## Rationale\n\nIntegrating configuration as a `Layer` plugs it directly into Effect's dependency injection system. This makes your configuration available anywhere in the program and dramatically simplifies testing by allowing you to substitute mock configuration.\n\n## Good Example\n\n````typescript\nimport { Effect, Layer } from \"effect\";\n\nclass ServerConfig extends Effect.Service<ServerConfig>()(\n  \"ServerConfig\",\n  {\n    sync: () => ({\n      port: process.env.PORT ? parseInt(process.env.PORT) : 8080\n    })\n  }\n) {}\n\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig;\n  yield* Effect.log(`Starting application on port ${config.port}...`);\n});\n\nconst programWithErrorHandling = Effect.provide(program, ServerConfig.Default).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);\n````\n\n**Explanation:**  \nThis approach makes configuration available contextually, supporting better testing and modularity.\n\n## Anti-Pattern\n\nManually reading environment variables deep inside business logic. This tightly couples that logic to the external environment, making it difficult to test and reuse."
  },
  {
    "id": "provide-dependencies-to-routes",
    "title": "Provide Dependencies to Routes",
    "description": "Define dependencies with Effect.Service and provide them to your HTTP server using a Layer.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines a `Database` service. The route handler for `/users/:userId` requires this service to fetch a user. We then provide a \"live\" implementation of the `Database` to the entire server using a `Layer`.\n\n```typescript\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport { Effect, Duration, Fiber } from \"effect/index\";\nimport { Data } from \"effect\";\n\n// 1. Define the service interface using Effect.Service\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) {}\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> {}\n\n// handler producing a `HttpServerResponse`\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\n// assemble router & server\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\n// Create the server effect with all dependencies\nconst serverEffect = HttpServer.serveEffect(app).pipe(\n  Effect.provide(Database.Default),\n  Effect.provide(\n    NodeHttpServer.layer(\n      () => require(\"node:http\").createServer(),\n      { port: 3458 }\n    )\n  )\n);\n\n// Create program that manages server lifecycle\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting server on port 3458...\");\n\n  const serverFiber = yield* Effect.scoped(serverEffect).pipe(Effect.fork);\n\n  yield* Effect.logInfo(\"Server started successfully on http://localhost:3458\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/123\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/456\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  yield* Effect.logInfo(\"Shutting down server...\");\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.logInfo(\"Server shutdown complete\");\n});\n\n// Run the program\nNodeRuntime.runMain(program);\n\n```",
    "antiPattern": "The anti-pattern is to manually instantiate and pass dependencies through function arguments. This creates tight coupling and makes testing difficult.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// Manual implementation of a database client\nclass LiveDatabase {\n  getUser(id: string) {\n    if (id === '123') {\n      return Effect.succeed({ name: 'Paul' });\n    }\n    return Effect.fail('User not found'); // Untyped error\n  }\n}\n\n// The dependency must be passed explicitly to the route definition\nconst createGetUserRoute = (db: LiveDatabase) =>\n  Http.router.get(\n    '/users/:userId',\n    Effect.flatMap(Http.request.ServerRequest, (req) =>\n      db.getUser(req.params.userId)\n    ).pipe(\n      Effect.map(Http.response.json),\n      Effect.catchAll(() => Http.response.empty({ status: 404 }))\n    )\n  );\n\n// Manually instantiate the dependency\nconst db = new LiveDatabase();\nconst getUserRoute = createGetUserRoute(db);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(getUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis approach is flawed because the route handler is now aware of the concrete `LiveDatabase` class. Swapping it for a mock in a test would be cumbersome. Furthermore, if a service deep within the call stack needs a dependency, it must be \"drilled\" down through every intermediate function, which is a significant maintenance burden.",
    "explanation": "As applications grow, route handlers need to perform complex tasks like accessing a database, calling other APIs, or logging. Hard-coding this logic or manually passing dependencies leads to tightly coupled, untestable code.\n\nEffect's dependency injection system (`Service` and `Layer`) solves this by decoupling a service's interface from its implementation. This is the cornerstone of building scalable, maintainable applications in Effect.\n\n1.  **Modern and Simple**: `Effect.Service` is the modern, idiomatic way to define services. It combines the service's definition and its access tag into a single, clean class structure, reducing boilerplate.\n2.  **Testability**: By depending on a service interface, you can easily provide a mock implementation in your tests (e.g., `Database.Test`) instead of the real one (`Database.Live`), allowing for fast, isolated unit tests of your route logic.\n3.  **Decoupling**: Route handlers don't know or care *how* the database connection is created or managed. They simply ask for the `Database` service from the context, and the runtime provides the configured implementation.\n4.  **Composability**: `Layer`s are composable. You can build complex dependency graphs (e.g., a `Database` layer that itself requires a `Config` layer) that Effect will automatically construct and wire up for you.\n\n---",
    "content": "## Guideline\n\nDefine your application's services using `class MyService extends Effect.Service(\"MyService\")`, provide a live implementation via a `Layer`, and use `Effect.provide` to make the service available to your entire HTTP application.\n\n---\n\n## Rationale\n\nAs applications grow, route handlers need to perform complex tasks like accessing a database, calling other APIs, or logging. Hard-coding this logic or manually passing dependencies leads to tightly coupled, untestable code.\n\nEffect's dependency injection system (`Service` and `Layer`) solves this by decoupling a service's interface from its implementation. This is the cornerstone of building scalable, maintainable applications in Effect.\n\n1.  **Modern and Simple**: `Effect.Service` is the modern, idiomatic way to define services. It combines the service's definition and its access tag into a single, clean class structure, reducing boilerplate.\n2.  **Testability**: By depending on a service interface, you can easily provide a mock implementation in your tests (e.g., `Database.Test`) instead of the real one (`Database.Live`), allowing for fast, isolated unit tests of your route logic.\n3.  **Decoupling**: Route handlers don't know or care *how* the database connection is created or managed. They simply ask for the `Database` service from the context, and the runtime provides the configured implementation.\n4.  **Composability**: `Layer`s are composable. You can build complex dependency graphs (e.g., a `Database` layer that itself requires a `Config` layer) that Effect will automatically construct and wire up for you.\n\n---\n\n## Good Example\n\nThis example defines a `Database` service. The route handler for `/users/:userId` requires this service to fetch a user. We then provide a \"live\" implementation of the `Database` to the entire server using a `Layer`.\n\n```typescript\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport { Effect, Duration, Fiber } from \"effect/index\";\nimport { Data } from \"effect\";\n\n// 1. Define the service interface using Effect.Service\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) {}\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> {}\n\n// handler producing a `HttpServerResponse`\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\n// assemble router & server\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\n// Create the server effect with all dependencies\nconst serverEffect = HttpServer.serveEffect(app).pipe(\n  Effect.provide(Database.Default),\n  Effect.provide(\n    NodeHttpServer.layer(\n      () => require(\"node:http\").createServer(),\n      { port: 3458 }\n    )\n  )\n);\n\n// Create program that manages server lifecycle\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting server on port 3458...\");\n\n  const serverFiber = yield* Effect.scoped(serverEffect).pipe(Effect.fork);\n\n  yield* Effect.logInfo(\"Server started successfully on http://localhost:3458\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/123\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/456\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  yield* Effect.logInfo(\"Shutting down server...\");\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.logInfo(\"Server shutdown complete\");\n});\n\n// Run the program\nNodeRuntime.runMain(program);\n\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to manually instantiate and pass dependencies through function arguments. This creates tight coupling and makes testing difficult.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\n// Manual implementation of a database client\nclass LiveDatabase {\n  getUser(id: string) {\n    if (id === '123') {\n      return Effect.succeed({ name: 'Paul' });\n    }\n    return Effect.fail('User not found'); // Untyped error\n  }\n}\n\n// The dependency must be passed explicitly to the route definition\nconst createGetUserRoute = (db: LiveDatabase) =>\n  Http.router.get(\n    '/users/:userId',\n    Effect.flatMap(Http.request.ServerRequest, (req) =>\n      db.getUser(req.params.userId)\n    ).pipe(\n      Effect.map(Http.response.json),\n      Effect.catchAll(() => Http.response.empty({ status: 404 }))\n    )\n  );\n\n// Manually instantiate the dependency\nconst db = new LiveDatabase();\nconst getUserRoute = createGetUserRoute(db);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(getUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis approach is flawed because the route handler is now aware of the concrete `LiveDatabase` class. Swapping it for a mock in a test would be cumbersome. Furthermore, if a service deep within the call stack needs a dependency, it must be \"drilled\" down through every intermediate function, which is a significant maintenance burden."
  },
  {
    "id": "race-concurrent-effects",
    "title": "Race Concurrent Effects for the Fastest Result",
    "description": "Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "A classic use case is checking a fast cache before falling back to a slower database. We can race the cache lookup against the database query.\n\n```typescript\nimport { Effect, Option } from \"effect\";\n\ntype User = { id: number; name: string };\n\n// Simulate a slower cache lookup that might find nothing (None)\nconst checkCache: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.none()\n).pipe(\n  Effect.delay(\"200 millis\") // Made slower so database wins\n);\n\n// Simulate a faster database query that will always find the data\nconst queryDatabase: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.some({ id: 1, name: \"Paul\" })\n).pipe(\n  Effect.delay(\"50 millis\") // Made faster so it wins the race\n);\n\n// Race them. The database should win and return the user data.\nconst program = Effect.race(checkCache, queryDatabase).pipe(\n  // The result of the race is an Option, so we can handle it.\n  Effect.flatMap((result: Option.Option<User>) =>\n    Option.match(result, {\n      onNone: () => Effect.fail(\"User not found anywhere.\"),\n      onSome: (user) => Effect.succeed(user),\n    })\n  )\n);\n\n// In this case, the database wins the race.\nconst programWithResults = Effect.gen(function* () {\n  try {\n    const user = yield* program;\n    yield* Effect.log(`User found: ${JSON.stringify(user)}`);\n    return user;\n  } catch (error) {\n    yield* Effect.logError(`Error: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithResults);\n\n// Also demonstrate with logging\nconst programWithLogging = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting race between cache and database...\");\n\n  try {\n    const user = yield* program;\n    yield* Effect.logInfo(\n      `Success: Found user ${user.name} with ID ${user.id}`\n    );\n    return user;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logInfo(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n\n```\n\n---",
    "antiPattern": "Don't use `Effect.race` if you need the results of *all* the effects. That is the job of `Effect.all`. Using `race` in this scenario will cause you to lose data, as all but one of the effects will be interrupted and their results discarded.\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst fetchProfile = Effect.succeed({ name: \"Paul\" });\nconst fetchPermissions = Effect.succeed([\"admin\", \"editor\"]);\n\n// ‚ùå WRONG: This will only return either the profile OR the permissions,\n// whichever resolves first. You will lose the other piece of data.\nconst incompleteData = Effect.race(fetchProfile, fetchPermissions);\n\n// ‚úÖ CORRECT: Use Effect.all when you need all the results.\nconst completeData = Effect.all([fetchProfile, fetchPermissions]);\n```",
    "explanation": "`Effect.race` is a powerful concurrency primitive for performance and resilience. It starts all provided effects in parallel. The moment one of them succeeds, `Effect.race` immediately interrupts all the other \"losing\" effects and returns the winning result. If one of the effects fails before any have succeeded, the race is not over; the remaining effects continue to run. The entire race only fails if *all* participating effects fail.\n\nThis is commonly used for:\n-   **Performance:** Querying multiple redundant data sources (e.g., two API replicas) and taking the response from whichever is faster.\n-   **Implementing Timeouts:** Racing a primary effect against a delayed `Effect.fail`, effectively creating a timeout mechanism.\n\n---",
    "content": "## Guideline\n\nWhen you have multiple effects that can produce the same type of result, and you only care about the one that finishes first, use `Effect.race(effectA, effectB)`.\n\n---\n\n## Rationale\n\n`Effect.race` is a powerful concurrency primitive for performance and resilience. It starts all provided effects in parallel. The moment one of them succeeds, `Effect.race` immediately interrupts all the other \"losing\" effects and returns the winning result. If one of the effects fails before any have succeeded, the race is not over; the remaining effects continue to run. The entire race only fails if *all* participating effects fail.\n\nThis is commonly used for:\n-   **Performance:** Querying multiple redundant data sources (e.g., two API replicas) and taking the response from whichever is faster.\n-   **Implementing Timeouts:** Racing a primary effect against a delayed `Effect.fail`, effectively creating a timeout mechanism.\n\n---\n\n## Good Example\n\nA classic use case is checking a fast cache before falling back to a slower database. We can race the cache lookup against the database query.\n\n```typescript\nimport { Effect, Option } from \"effect\";\n\ntype User = { id: number; name: string };\n\n// Simulate a slower cache lookup that might find nothing (None)\nconst checkCache: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.none()\n).pipe(\n  Effect.delay(\"200 millis\") // Made slower so database wins\n);\n\n// Simulate a faster database query that will always find the data\nconst queryDatabase: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.some({ id: 1, name: \"Paul\" })\n).pipe(\n  Effect.delay(\"50 millis\") // Made faster so it wins the race\n);\n\n// Race them. The database should win and return the user data.\nconst program = Effect.race(checkCache, queryDatabase).pipe(\n  // The result of the race is an Option, so we can handle it.\n  Effect.flatMap((result: Option.Option<User>) =>\n    Option.match(result, {\n      onNone: () => Effect.fail(\"User not found anywhere.\"),\n      onSome: (user) => Effect.succeed(user),\n    })\n  )\n);\n\n// In this case, the database wins the race.\nconst programWithResults = Effect.gen(function* () {\n  try {\n    const user = yield* program;\n    yield* Effect.log(`User found: ${JSON.stringify(user)}`);\n    return user;\n  } catch (error) {\n    yield* Effect.logError(`Error: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithResults);\n\n// Also demonstrate with logging\nconst programWithLogging = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting race between cache and database...\");\n\n  try {\n    const user = yield* program;\n    yield* Effect.logInfo(\n      `Success: Found user ${user.name} with ID ${user.id}`\n    );\n    return user;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logInfo(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n\n```\n\n---\n\n## Anti-Pattern\n\nDon't use `Effect.race` if you need the results of *all* the effects. That is the job of `Effect.all`. Using `race` in this scenario will cause you to lose data, as all but one of the effects will be interrupted and their results discarded.\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst fetchProfile = Effect.succeed({ name: \"Paul\" });\nconst fetchPermissions = Effect.succeed([\"admin\", \"editor\"]);\n\n// ‚ùå WRONG: This will only return either the profile OR the permissions,\n// whichever resolves first. You will lose the other piece of data.\nconst incompleteData = Effect.race(fetchProfile, fetchPermissions);\n\n// ‚úÖ CORRECT: Use Effect.all when you need all the results.\nconst completeData = Effect.all([fetchProfile, fetchPermissions]);\n```"
  },
  {
    "id": "data-redacted",
    "title": "Redact and Handle Sensitive Data",
    "description": "Use Redacted to wrap sensitive values, preventing accidental exposure in logs or error messages.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Redacted } from \"effect\";\n\n// Wrap a sensitive value\nconst secret = Redacted.make(\"super-secret-password\");\n\n// Use the secret in your application logic\nfunction authenticate(user: string, password: Redacted.Redacted<string>) {\n  // ... authentication logic\n}\n\n// Logging or stringifying a Redacted value\nconsole.log(`Password: ${secret}`); // Output: Password: <redacted>\nconsole.log(String(secret)); // Output: <redacted>\n\n```\n\n**Explanation:**  \n- `Redacted.make(value)` wraps a sensitive value.\n- When logged or stringified, the value is replaced with `<redacted>`.\n- Prevents accidental exposure of secrets in logs or error messages.",
    "antiPattern": "Passing sensitive data as plain strings, which can be accidentally logged, serialized, or leaked in error messages.",
    "explanation": "Sensitive data should never appear in logs, traces, or error messages.  \n`Redacted` provides a type-safe way to mark and protect secrets throughout your application.",
    "content": "# Redact and Handle Sensitive Data with `Redacted`\n\n## Guideline\n\nUse the `Redacted` data type to securely handle sensitive data such as passwords, API keys, or tokens.  \n`Redacted` ensures that secrets are not accidentally logged, serialized, or exposed in error messages.\n\n## Rationale\n\nSensitive data should never appear in logs, traces, or error messages.  \n`Redacted` provides a type-safe way to mark and protect secrets throughout your application.\n\n## Good Example\n\n```typescript\nimport { Redacted } from \"effect\";\n\n// Wrap a sensitive value\nconst secret = Redacted.make(\"super-secret-password\");\n\n// Use the secret in your application logic\nfunction authenticate(user: string, password: Redacted.Redacted<string>) {\n  // ... authentication logic\n}\n\n// Logging or stringifying a Redacted value\nconsole.log(`Password: ${secret}`); // Output: Password: <redacted>\nconsole.log(String(secret)); // Output: <redacted>\n\n```\n\n**Explanation:**  \n- `Redacted.make(value)` wraps a sensitive value.\n- When logged or stringified, the value is replaced with `<redacted>`.\n- Prevents accidental exposure of secrets in logs or error messages.\n\n## Anti-Pattern\n\nPassing sensitive data as plain strings, which can be accidentally logged, serialized, or leaked in error messages."
  },
  {
    "id": "representing-time-spans-with-duration",
    "title": "Representing Time Spans with Duration",
    "description": "Use the Duration data type to represent time intervals instead of raw numbers.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "This example shows how to create and use `Duration` to make time-based operations clear and unambiguous.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\n// Create durations with clear, explicit units\nconst fiveSeconds = Duration.seconds(5);\nconst oneHundredMillis = Duration.millis(100);\n\n// Use them in Effect operators\nconst program = Effect.log(\"Starting...\").pipe(\n  Effect.delay(oneHundredMillis),\n  Effect.flatMap(() => Effect.log(\"Running after 100ms\")),\n  Effect.timeout(fiveSeconds) // This whole operation must complete within 5 seconds\n);\n\n// Durations can also be compared\nconst isLonger = Duration.greaterThan(fiveSeconds, oneHundredMillis); // true\n\n// Demonstrate the duration functionality\nconst demonstration = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Duration Demonstration ===\");\n\n  // Show duration values\n  yield* Effect.logInfo(`Five seconds: ${Duration.toMillis(fiveSeconds)}ms`);\n  yield* Effect.logInfo(\n    `One hundred millis: ${Duration.toMillis(oneHundredMillis)}ms`\n  );\n\n  // Show comparison\n  yield* Effect.logInfo(`Is 5 seconds longer than 100ms? ${isLonger}`);\n\n  // Run the timed program\n  yield* Effect.logInfo(\"Running timed program...\");\n  yield* program;\n\n  // Show more duration operations\n  const combined = Duration.sum(fiveSeconds, oneHundredMillis);\n  yield* Effect.logInfo(`Combined duration: ${Duration.toMillis(combined)}ms`);\n\n  // Show different duration units\n  const oneMinute = Duration.minutes(1);\n  yield* Effect.logInfo(`One minute: ${Duration.toMillis(oneMinute)}ms`);\n\n  const isMinuteLonger = Duration.greaterThan(oneMinute, fiveSeconds);\n  yield* Effect.logInfo(`Is 1 minute longer than 5 seconds? ${isMinuteLonger}`);\n});\n\nEffect.runPromise(demonstration);\n\n```\n\n---",
    "antiPattern": "Using raw numbers for time-based operations. This is ambiguous and error-prone.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: What does '2000' mean? Milliseconds? Seconds?\nconst program = Effect.log(\"Waiting...\").pipe(Effect.delay(2000));\n\n// This is especially dangerous when different parts of an application\n// use different conventions (e.g., one service uses seconds, another uses milliseconds).\n// Using Duration eliminates this entire class of bugs.\n```",
    "explanation": "Using raw numbers to represent time is a common source of bugs and confusion. When you see `setTimeout(fn, 5000)`, it's not immediately clear if the unit is seconds or milliseconds without prior knowledge of the API.\n\n`Duration` solves this by making the unit explicit in the code. It provides a type-safe, immutable, and human-readable way to work with time intervals. This eliminates ambiguity and makes your code easier to read and maintain. Durations are used throughout Effect's time-based operators, such as `Effect.sleep`, `Effect.timeout`, and `Schedule`.\n\n---",
    "content": "## Guideline\n\nWhen you need to represent a span of time (e.g., for a delay, timeout, or schedule), use the `Duration` data type. Create durations with expressive constructors like `Duration.seconds(5)`, `Duration.minutes(10)`, or `Duration.millis(500)`.\n\n---\n\n## Rationale\n\nUsing raw numbers to represent time is a common source of bugs and confusion. When you see `setTimeout(fn, 5000)`, it's not immediately clear if the unit is seconds or milliseconds without prior knowledge of the API.\n\n`Duration` solves this by making the unit explicit in the code. It provides a type-safe, immutable, and human-readable way to work with time intervals. This eliminates ambiguity and makes your code easier to read and maintain. Durations are used throughout Effect's time-based operators, such as `Effect.sleep`, `Effect.timeout`, and `Schedule`.\n\n---\n\n## Good Example\n\nThis example shows how to create and use `Duration` to make time-based operations clear and unambiguous.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\n// Create durations with clear, explicit units\nconst fiveSeconds = Duration.seconds(5);\nconst oneHundredMillis = Duration.millis(100);\n\n// Use them in Effect operators\nconst program = Effect.log(\"Starting...\").pipe(\n  Effect.delay(oneHundredMillis),\n  Effect.flatMap(() => Effect.log(\"Running after 100ms\")),\n  Effect.timeout(fiveSeconds) // This whole operation must complete within 5 seconds\n);\n\n// Durations can also be compared\nconst isLonger = Duration.greaterThan(fiveSeconds, oneHundredMillis); // true\n\n// Demonstrate the duration functionality\nconst demonstration = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Duration Demonstration ===\");\n\n  // Show duration values\n  yield* Effect.logInfo(`Five seconds: ${Duration.toMillis(fiveSeconds)}ms`);\n  yield* Effect.logInfo(\n    `One hundred millis: ${Duration.toMillis(oneHundredMillis)}ms`\n  );\n\n  // Show comparison\n  yield* Effect.logInfo(`Is 5 seconds longer than 100ms? ${isLonger}`);\n\n  // Run the timed program\n  yield* Effect.logInfo(\"Running timed program...\");\n  yield* program;\n\n  // Show more duration operations\n  const combined = Duration.sum(fiveSeconds, oneHundredMillis);\n  yield* Effect.logInfo(`Combined duration: ${Duration.toMillis(combined)}ms`);\n\n  // Show different duration units\n  const oneMinute = Duration.minutes(1);\n  yield* Effect.logInfo(`One minute: ${Duration.toMillis(oneMinute)}ms`);\n\n  const isMinuteLonger = Duration.greaterThan(oneMinute, fiveSeconds);\n  yield* Effect.logInfo(`Is 1 minute longer than 5 seconds? ${isMinuteLonger}`);\n});\n\nEffect.runPromise(demonstration);\n\n```\n\n---\n\n## Anti-Pattern\n\nUsing raw numbers for time-based operations. This is ambiguous and error-prone.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: What does '2000' mean? Milliseconds? Seconds?\nconst program = Effect.log(\"Waiting...\").pipe(Effect.delay(2000));\n\n// This is especially dangerous when different parts of an application\n// use different conventions (e.g., one service uses seconds, another uses milliseconds).\n// Using Duration eliminates this entire class of bugs.\n```"
  },
  {
    "id": "data-duration",
    "title": "Representing Time Spans with Duration",
    "description": "Use Duration to model and manipulate time spans, enabling safe and expressive time-based logic.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Duration } from \"effect\";\n\n// Create durations using helpers\nconst oneSecond = Duration.seconds(1);\nconst fiveMinutes = Duration.minutes(5);\nconst twoHours = Duration.hours(2);\n\n// Add, subtract, and compare durations\nconst total = Duration.sum(oneSecond, fiveMinutes); // 5 min 1 sec\nconst isLonger = Duration.greaterThan(twoHours, fiveMinutes); // true\n\n// Convert to milliseconds or human-readable format\nconst ms = Duration.toMillis(fiveMinutes); // 300000\nconst readable = Duration.format(oneSecond); // \"1s\"\n\n```\n\n**Explanation:**  \n- `Duration` is immutable and type-safe.\n- Use helpers for common intervals and arithmetic for composition.\n- Prefer `Duration` over raw numbers for all time-based logic.",
    "antiPattern": "Using raw numbers (e.g., `5000` for 5 seconds) for time intervals, which is error-prone, hard to read, and less maintainable.",
    "explanation": "Working with raw numbers for time intervals (e.g., milliseconds) is error-prone and hard to read.  \n`Duration` provides a clear, expressive API for modeling time spans, improving code safety and maintainability.",
    "content": "# Representing Time Spans with `Duration`\n\n## Guideline\n\nUse the `Duration` data type to represent and manipulate time intervals in a type-safe, human-readable, and composable way.  \nThis enables robust time-based logic for scheduling, retries, timeouts, and more.\n\n## Rationale\n\nWorking with raw numbers for time intervals (e.g., milliseconds) is error-prone and hard to read.  \n`Duration` provides a clear, expressive API for modeling time spans, improving code safety and maintainability.\n\n## Good Example\n\n```typescript\nimport { Duration } from \"effect\";\n\n// Create durations using helpers\nconst oneSecond = Duration.seconds(1);\nconst fiveMinutes = Duration.minutes(5);\nconst twoHours = Duration.hours(2);\n\n// Add, subtract, and compare durations\nconst total = Duration.sum(oneSecond, fiveMinutes); // 5 min 1 sec\nconst isLonger = Duration.greaterThan(twoHours, fiveMinutes); // true\n\n// Convert to milliseconds or human-readable format\nconst ms = Duration.toMillis(fiveMinutes); // 300000\nconst readable = Duration.format(oneSecond); // \"1s\"\n\n```\n\n**Explanation:**  \n- `Duration` is immutable and type-safe.\n- Use helpers for common intervals and arithmetic for composition.\n- Prefer `Duration` over raw numbers for all time-based logic.\n\n## Anti-Pattern\n\nUsing raw numbers (e.g., `5000` for 5 seconds) for time intervals, which is error-prone, hard to read, and less maintainable."
  },
  {
    "id": "retry-based-on-specific-errors",
    "title": "Retry Operations Based on Specific Errors",
    "description": "Use predicate-based retry policies to retry an operation only for specific, recoverable errors.",
    "skillLevel": "intermediate",
    "useCases": [
      "error-management"
    ],
    "example": "This example simulates an API client that can fail with different, specific error types. The retry policy is configured to *only* retry on `ServerBusyError` and give up immediately on `NotFoundError`.\n\n```typescript\nimport { Data, Effect, Schedule } from \"effect\";\n\n// Define specific, tagged errors for our API client\nclass ServerBusyError extends Data.TaggedError(\"ServerBusyError\") {}\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\nlet attemptCount = 0;\n\n// A flaky API call that can fail in different ways\nconst flakyApiCall = Effect.try({\n  try: () => {\n    attemptCount++;\n    const random = Math.random();\n\n    if (attemptCount <= 2) {\n      // First two attempts fail with ServerBusyError (retryable)\n      console.log(\n        `Attempt ${attemptCount}: API call failed - Server is busy. Retrying...`\n      );\n      throw new ServerBusyError();\n    }\n\n    // Third attempt succeeds\n    console.log(`Attempt ${attemptCount}: API call succeeded!`);\n    return { data: \"success\", attempt: attemptCount };\n  },\n  catch: (e) => e as ServerBusyError | NotFoundError,\n});\n\n// A predicate that returns true only for the error we want to retry\nconst isRetryableError = (e: ServerBusyError | NotFoundError) =>\n  e._tag === \"ServerBusyError\";\n\n// A policy that retries 3 times, but only if the error is retryable\nconst selectiveRetryPolicy = Schedule.recurs(3).pipe(\n  Schedule.whileInput(isRetryableError),\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Retry Based on Specific Errors Demo ===\");\n\n  try {\n    const result = yield* flakyApiCall.pipe(Effect.retry(selectiveRetryPolicy));\n    yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n    return result;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\"Failed with NotFoundError - not retrying\");\n      } else if (error instanceof ServerBusyError) {\n        yield* Effect.logInfo(\"Failed with ServerBusyError after all retries\");\n      } else {\n        yield* Effect.logInfo(`Failed with unexpected error: ${error}`);\n      }\n      return null;\n    })\n  )\n);\n\n// Also demonstrate a case where NotFoundError is not retried\nconst demonstrateNotFound = Effect.gen(function* () {\n  yield* Effect.logInfo(\"\\n=== Demonstrating Non-Retryable Error ===\");\n\n  const alwaysNotFound = Effect.fail(new NotFoundError());\n\n  const result = yield* alwaysNotFound.pipe(\n    Effect.retry(selectiveRetryPolicy),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`NotFoundError was not retried: ${error._tag}`);\n        return null;\n      })\n    )\n  );\n\n  return result;\n});\n\nEffect.runPromise(program.pipe(Effect.flatMap(() => demonstrateNotFound)));\n\n```\n\n---",
    "antiPattern": "Using a generic `Effect.retry` that retries on all errors. This can lead to wasted resources and obscure permanent issues.\n\n```typescript\nimport { Effect, Schedule } from \"effect\";\nimport { flakyApiCall } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This policy will retry even if the API returns a 404 Not Found.\n// This wastes time and network requests on an error that will never succeed.\nconst blindRetryPolicy = Schedule.recurs(3);\n\nconst program = flakyApiCall.pipe(Effect.retry(blindRetryPolicy));\n```",
    "explanation": "Not all errors are created equal. Retrying on a permanent error like \"permission denied\" or \"not found\" is pointless and can hide underlying issues. You only want to retry on *transient*, recoverable errors, such as network timeouts or \"server busy\" responses.\n\nBy adding a predicate to your retry schedule, you gain fine-grained control over the retry logic. This allows you to build much more intelligent and efficient error handling systems that react appropriately to different failure modes. This is a common requirement for building robust clients for external APIs.\n\n---",
    "content": "## Guideline\n\nTo selectively retry an operation, use `Effect.retry` with a `Schedule` that includes a predicate. The most common way is to use `Schedule.whileInput((error) => ...)`, which will continue retrying only as long as the predicate returns `true` for the error that occurred.\n\n---\n\n## Rationale\n\nNot all errors are created equal. Retrying on a permanent error like \"permission denied\" or \"not found\" is pointless and can hide underlying issues. You only want to retry on *transient*, recoverable errors, such as network timeouts or \"server busy\" responses.\n\nBy adding a predicate to your retry schedule, you gain fine-grained control over the retry logic. This allows you to build much more intelligent and efficient error handling systems that react appropriately to different failure modes. This is a common requirement for building robust clients for external APIs.\n\n---\n\n## Good Example\n\nThis example simulates an API client that can fail with different, specific error types. The retry policy is configured to *only* retry on `ServerBusyError` and give up immediately on `NotFoundError`.\n\n```typescript\nimport { Data, Effect, Schedule } from \"effect\";\n\n// Define specific, tagged errors for our API client\nclass ServerBusyError extends Data.TaggedError(\"ServerBusyError\") {}\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\nlet attemptCount = 0;\n\n// A flaky API call that can fail in different ways\nconst flakyApiCall = Effect.try({\n  try: () => {\n    attemptCount++;\n    const random = Math.random();\n\n    if (attemptCount <= 2) {\n      // First two attempts fail with ServerBusyError (retryable)\n      console.log(\n        `Attempt ${attemptCount}: API call failed - Server is busy. Retrying...`\n      );\n      throw new ServerBusyError();\n    }\n\n    // Third attempt succeeds\n    console.log(`Attempt ${attemptCount}: API call succeeded!`);\n    return { data: \"success\", attempt: attemptCount };\n  },\n  catch: (e) => e as ServerBusyError | NotFoundError,\n});\n\n// A predicate that returns true only for the error we want to retry\nconst isRetryableError = (e: ServerBusyError | NotFoundError) =>\n  e._tag === \"ServerBusyError\";\n\n// A policy that retries 3 times, but only if the error is retryable\nconst selectiveRetryPolicy = Schedule.recurs(3).pipe(\n  Schedule.whileInput(isRetryableError),\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Retry Based on Specific Errors Demo ===\");\n\n  try {\n    const result = yield* flakyApiCall.pipe(Effect.retry(selectiveRetryPolicy));\n    yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n    return result;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\"Failed with NotFoundError - not retrying\");\n      } else if (error instanceof ServerBusyError) {\n        yield* Effect.logInfo(\"Failed with ServerBusyError after all retries\");\n      } else {\n        yield* Effect.logInfo(`Failed with unexpected error: ${error}`);\n      }\n      return null;\n    })\n  )\n);\n\n// Also demonstrate a case where NotFoundError is not retried\nconst demonstrateNotFound = Effect.gen(function* () {\n  yield* Effect.logInfo(\"\\n=== Demonstrating Non-Retryable Error ===\");\n\n  const alwaysNotFound = Effect.fail(new NotFoundError());\n\n  const result = yield* alwaysNotFound.pipe(\n    Effect.retry(selectiveRetryPolicy),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`NotFoundError was not retried: ${error._tag}`);\n        return null;\n      })\n    )\n  );\n\n  return result;\n});\n\nEffect.runPromise(program.pipe(Effect.flatMap(() => demonstrateNotFound)));\n\n```\n\n---\n\n## Anti-Pattern\n\nUsing a generic `Effect.retry` that retries on all errors. This can lead to wasted resources and obscure permanent issues.\n\n```typescript\nimport { Effect, Schedule } from \"effect\";\nimport { flakyApiCall } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This policy will retry even if the API returns a 404 Not Found.\n// This wastes time and network requests on an error that will never succeed.\nconst blindRetryPolicy = Schedule.recurs(3);\n\nconst program = flakyApiCall.pipe(Effect.retry(blindRetryPolicy));\n```"
  },
  {
    "id": "stream-run-for-effects",
    "title": "Run a Pipeline for its Side Effects",
    "description": "Use Stream.runDrain to execute a stream for its side effects when you don't need the final values.",
    "skillLevel": "beginner",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example creates a stream of tasks. For each task, it performs a side effect (logging it as \"complete\"). `Stream.runDrain` executes the pipeline, ensuring all logs are written, but without collecting the `void` results of each logging operation.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\nconst tasks = ['task 1', 'task 2', 'task 3'];\n\n// A function that performs a side effect for a task\nconst completeTask = (task: string): Effect.Effect<void, never> =>\n  Effect.log(`Completing ${task}`);\n\nconst program = Stream.fromIterable(tasks).pipe(\n  // For each task, run the side-effectful operation\n  Stream.mapEffect(completeTask, { concurrency: 1 }),\n  // Run the stream for its effects, discarding the `void` results\n  Stream.runDrain\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  yield* program;\n  yield* Effect.log('\\nAll tasks have been processed.');\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Completing task 1\"\n... level=INFO msg=\"Completing task 2\"\n... level=INFO msg=\"Completing task 3\"\n\nAll tasks have been processed.\n*/\n```",
    "antiPattern": "The anti-pattern is using `Stream.runCollect` when you only care about the side effects. This needlessly consumes memory and can lead to crashes.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n// ... same tasks and completeTask function ...\n\nconst program = Stream.fromIterable(tasks).pipe(\n  Stream.mapEffect(completeTask, { concurrency: 1 }),\n  // Anti-pattern: Collecting results that we are just going to ignore\n  Stream.runCollect\n);\n\nEffect.runPromise(program).then((results) => {\n  // The `results` variable here is a Chunk of `[void, void, void]`.\n  // It served no purpose but consumed memory.\n  console.log(\n    `\\nAll tasks processed. Unnecessarily collected ${results.length} empty results.`\n  );\n});\n```\n\nWhile this works for a small array of three items, it's a dangerous habit. If the `tasks` array contained millions of items, this code would create a `Chunk` with millions of `void` values, consuming a significant amount of memory for no reason and potentially crashing the application. `Stream.runDrain` avoids this problem entirely.",
    "explanation": "Not all pipelines are designed to produce a final list of values. Often, the goal is to perform an action for each item‚Äîwrite it to a database, send it to a message queue, or log it to a file. In these \"fire and forget\" scenarios, collecting the results is not just unnecessary; it's a performance anti-pattern.\n\n`Stream.runDrain` is the perfect tool for this job:\n\n1.  **Memory Efficiency**: This is its primary advantage. `runDrain` processes each item and then immediately discards it, resulting in constant, minimal memory usage. This makes it the only safe choice for processing extremely large or infinite streams.\n2.  **Clarity of Intent**: Using `runDrain` clearly communicates that you are interested in the successful execution of the stream's effects, not in its output values. The final `Effect` it produces resolves to `void`, reinforcing that no value is returned.\n3.  **Performance**: By avoiding the overhead of allocating and managing a growing list in memory, `runDrain` can be faster for pipelines with a very large number of small items.\n\n---",
    "content": "## Guideline\n\nTo run a stream purely for its side effects without accumulating the results in memory, use the `Stream.runDrain` sink.\n\n---\n\n## Rationale\n\nNot all pipelines are designed to produce a final list of values. Often, the goal is to perform an action for each item‚Äîwrite it to a database, send it to a message queue, or log it to a file. In these \"fire and forget\" scenarios, collecting the results is not just unnecessary; it's a performance anti-pattern.\n\n`Stream.runDrain` is the perfect tool for this job:\n\n1.  **Memory Efficiency**: This is its primary advantage. `runDrain` processes each item and then immediately discards it, resulting in constant, minimal memory usage. This makes it the only safe choice for processing extremely large or infinite streams.\n2.  **Clarity of Intent**: Using `runDrain` clearly communicates that you are interested in the successful execution of the stream's effects, not in its output values. The final `Effect` it produces resolves to `void`, reinforcing that no value is returned.\n3.  **Performance**: By avoiding the overhead of allocating and managing a growing list in memory, `runDrain` can be faster for pipelines with a very large number of small items.\n\n---\n\n## Good Example\n\nThis example creates a stream of tasks. For each task, it performs a side effect (logging it as \"complete\"). `Stream.runDrain` executes the pipeline, ensuring all logs are written, but without collecting the `void` results of each logging operation.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\nconst tasks = ['task 1', 'task 2', 'task 3'];\n\n// A function that performs a side effect for a task\nconst completeTask = (task: string): Effect.Effect<void, never> =>\n  Effect.log(`Completing ${task}`);\n\nconst program = Stream.fromIterable(tasks).pipe(\n  // For each task, run the side-effectful operation\n  Stream.mapEffect(completeTask, { concurrency: 1 }),\n  // Run the stream for its effects, discarding the `void` results\n  Stream.runDrain\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  yield* program;\n  yield* Effect.log('\\nAll tasks have been processed.');\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Completing task 1\"\n... level=INFO msg=\"Completing task 2\"\n... level=INFO msg=\"Completing task 3\"\n\nAll tasks have been processed.\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is using `Stream.runCollect` when you only care about the side effects. This needlessly consumes memory and can lead to crashes.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n// ... same tasks and completeTask function ...\n\nconst program = Stream.fromIterable(tasks).pipe(\n  Stream.mapEffect(completeTask, { concurrency: 1 }),\n  // Anti-pattern: Collecting results that we are just going to ignore\n  Stream.runCollect\n);\n\nEffect.runPromise(program).then((results) => {\n  // The `results` variable here is a Chunk of `[void, void, void]`.\n  // It served no purpose but consumed memory.\n  console.log(\n    `\\nAll tasks processed. Unnecessarily collected ${results.length} empty results.`\n  );\n});\n```\n\nWhile this works for a small array of three items, it's a dangerous habit. If the `tasks` array contained millions of items, this code would create a `Chunk` with millions of `void` values, consuming a significant amount of memory for no reason and potentially crashing the application. `Stream.runDrain` avoids this problem entirely."
  },
  {
    "id": "run-background-tasks-with-fork",
    "title": "Run Background Tasks with Effect.fork",
    "description": "Use Effect.fork to start a non-blocking background process and manage its lifecycle via its Fiber.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This program forks a background process that logs a \"tick\" every second. The main process does its own work for 5 seconds and then explicitly interrupts the background logger before exiting.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\n// A long-running effect that logs a message every second, forever\n// Effect.forever creates an infinite loop that repeats the effect\n// This simulates a background service like a health check or monitoring task\nconst tickingClock = Effect.log(\"tick\").pipe(\n  Effect.delay(\"1 second\"), // Wait 1 second between ticks\n  Effect.forever, // Repeat indefinitely - this creates an infinite effect\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Forking the ticking clock into the background.\");\n  \n  // Start the clock, but don't wait for it.\n  // Effect.fork creates a new fiber that runs concurrently with the main program\n  // The main fiber continues immediately without waiting for the background task\n  // This is essential for non-blocking background operations\n  const clockFiber = yield* Effect.fork(tickingClock);\n  \n  // At this point, we have two fibers running:\n  // 1. The main fiber (this program)\n  // 2. The background clock fiber (ticking every second)\n\n  yield* Effect.log(\"Main process is now doing other work for 5 seconds...\");\n  \n  // Simulate the main application doing work\n  // While this sleep happens, the background clock continues ticking\n  // This demonstrates true concurrency - both fibers run simultaneously\n  yield* Effect.sleep(\"5 seconds\");\n\n  yield* Effect.log(\"Main process is done. Interrupting the clock fiber.\");\n  \n  // Stop the background process.\n  // Fiber.interrupt sends an interruption signal to the fiber\n  // This allows the fiber to perform cleanup operations before terminating\n  // Without this, the background task would continue running indefinitely\n  yield* Fiber.interrupt(clockFiber);\n  \n  // Important: Always clean up background fibers to prevent resource leaks\n  // In a real application, you might want to:\n  // 1. Use Fiber.join instead of interrupt to wait for graceful completion\n  // 2. Handle interruption signals within the background task\n  // 3. Implement proper shutdown procedures\n\n  yield* Effect.log(\"Program finished.\");\n  \n  // Key concepts demonstrated:\n  // 1. Fork creates concurrent fibers without blocking\n  // 2. Background tasks run independently of the main program\n  // 3. Fiber interruption provides controlled shutdown\n  // 4. Multiple fibers can run simultaneously on the same thread pool\n});\n\n// This example shows how to:\n// - Run background tasks that don't block the main program\n// - Manage fiber lifecycles (create, run, interrupt)\n// - Coordinate between multiple concurrent operations\n// - Properly clean up resources when shutting down\nEffect.runPromise(program);\n```\n\n---",
    "antiPattern": "The anti-pattern is using `Effect.fork` when you immediately need the result of the computation. This is an overly complicated and less readable way of just running the effect directly.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst someEffect = Effect.succeed(42);\n\n// ‚ùå WRONG: This is unnecessarily complex.\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(someEffect);\n  // You immediately wait for the result, defeating the purpose of forking.\n  const result = yield* Fiber.join(fiber);\n  return result;\n});\n\n// ‚úÖ CORRECT: Just run the effect directly if you need its result right away.\nconst simplerProgram = Effect.gen(function* () {\n  const result = yield* someEffect;\n  return result;\n});\n```",
    "explanation": "Unlike `Effect.all` or a direct `yield*`, which wait for the computation to complete, `Effect.fork` is a \"fire and forget\" operation. It starts the effect on a new, concurrent fiber and immediately returns control to the parent fiber.\n\nThis is essential for managing long-running background tasks like:\n-   A web server listener.\n-   A message queue consumer.\n-   A periodic cache cleanup job.\n\nThe returned `Fiber` object is your remote control for the background task. You can use `Fiber.interrupt` to safely stop it (ensuring all its finalizers are run) or `Fiber.join` to wait for it to complete at some later point.\n\n---",
    "content": "## Guideline\n\nTo start an `Effect` in the background without blocking the current execution flow, use `Effect.fork`. This immediately returns a `Fiber`, which is a handle to the running computation that you can use to manage its lifecycle (e.g., interrupt it or wait for its result).\n\n---\n\n## Rationale\n\nUnlike `Effect.all` or a direct `yield*`, which wait for the computation to complete, `Effect.fork` is a \"fire and forget\" operation. It starts the effect on a new, concurrent fiber and immediately returns control to the parent fiber.\n\nThis is essential for managing long-running background tasks like:\n-   A web server listener.\n-   A message queue consumer.\n-   A periodic cache cleanup job.\n\nThe returned `Fiber` object is your remote control for the background task. You can use `Fiber.interrupt` to safely stop it (ensuring all its finalizers are run) or `Fiber.join` to wait for it to complete at some later point.\n\n---\n\n## Good Example\n\nThis program forks a background process that logs a \"tick\" every second. The main process does its own work for 5 seconds and then explicitly interrupts the background logger before exiting.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\n// A long-running effect that logs a message every second, forever\n// Effect.forever creates an infinite loop that repeats the effect\n// This simulates a background service like a health check or monitoring task\nconst tickingClock = Effect.log(\"tick\").pipe(\n  Effect.delay(\"1 second\"), // Wait 1 second between ticks\n  Effect.forever, // Repeat indefinitely - this creates an infinite effect\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Forking the ticking clock into the background.\");\n  \n  // Start the clock, but don't wait for it.\n  // Effect.fork creates a new fiber that runs concurrently with the main program\n  // The main fiber continues immediately without waiting for the background task\n  // This is essential for non-blocking background operations\n  const clockFiber = yield* Effect.fork(tickingClock);\n  \n  // At this point, we have two fibers running:\n  // 1. The main fiber (this program)\n  // 2. The background clock fiber (ticking every second)\n\n  yield* Effect.log(\"Main process is now doing other work for 5 seconds...\");\n  \n  // Simulate the main application doing work\n  // While this sleep happens, the background clock continues ticking\n  // This demonstrates true concurrency - both fibers run simultaneously\n  yield* Effect.sleep(\"5 seconds\");\n\n  yield* Effect.log(\"Main process is done. Interrupting the clock fiber.\");\n  \n  // Stop the background process.\n  // Fiber.interrupt sends an interruption signal to the fiber\n  // This allows the fiber to perform cleanup operations before terminating\n  // Without this, the background task would continue running indefinitely\n  yield* Fiber.interrupt(clockFiber);\n  \n  // Important: Always clean up background fibers to prevent resource leaks\n  // In a real application, you might want to:\n  // 1. Use Fiber.join instead of interrupt to wait for graceful completion\n  // 2. Handle interruption signals within the background task\n  // 3. Implement proper shutdown procedures\n\n  yield* Effect.log(\"Program finished.\");\n  \n  // Key concepts demonstrated:\n  // 1. Fork creates concurrent fibers without blocking\n  // 2. Background tasks run independently of the main program\n  // 3. Fiber interruption provides controlled shutdown\n  // 4. Multiple fibers can run simultaneously on the same thread pool\n});\n\n// This example shows how to:\n// - Run background tasks that don't block the main program\n// - Manage fiber lifecycles (create, run, interrupt)\n// - Coordinate between multiple concurrent operations\n// - Properly clean up resources when shutting down\nEffect.runPromise(program);\n```\n\n---\n\n## Anti-Pattern\n\nThe anti-pattern is using `Effect.fork` when you immediately need the result of the computation. This is an overly complicated and less readable way of just running the effect directly.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst someEffect = Effect.succeed(42);\n\n// ‚ùå WRONG: This is unnecessarily complex.\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(someEffect);\n  // You immediately wait for the result, defeating the purpose of forking.\n  const result = yield* Fiber.join(fiber);\n  return result;\n});\n\n// ‚úÖ CORRECT: Just run the effect directly if you need its result right away.\nconst simplerProgram = Effect.gen(function* () {\n  const result = yield* someEffect;\n  return result;\n});\n```"
  },
  {
    "id": "run-effects-in-parallel-with-all",
    "title": "Run Independent Effects in Parallel with Effect.all",
    "description": "Use Effect.all to execute a collection of independent effects concurrently.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "Imagine fetching a user's profile and their latest posts from two different API endpoints. These are independent operations and can be run in parallel to save time.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Simulate fetching a user, takes 1 second\nconst fetchUser = Effect.succeed({ id: 1, name: \"Paul\" }).pipe(\n  Effect.delay(\"1 second\"),\n);\n\n// Simulate fetching posts, takes 1.5 seconds\nconst fetchPosts = Effect.succeed([{ title: \"Effect is great\" }]).pipe(\n  Effect.delay(\"1.5 seconds\"),\n);\n\n// Run both effects concurrently - must specify concurrency option!\nconst program = Effect.all([fetchUser, fetchPosts], { concurrency: \"unbounded\" });\n\n// The resulting effect will succeed with a tuple: [{id, name}, [{title}]]\n// Total execution time will be ~1.5 seconds (the duration of the longest task).\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(`Results: ${JSON.stringify(results)}`);\n  return results;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---",
    "antiPattern": "The anti-pattern is running independent tasks sequentially using `Effect.gen`. This is inefficient and unnecessarily slows down your application.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { fetchUser, fetchPosts } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This is inefficient.\nconst program = Effect.gen(function* () {\n  // fetchUser runs and completes...\n  const user = yield* fetchUser;\n  // ...only then does fetchPosts begin.\n  const posts = yield* fetchPosts;\n  return [user, posts];\n});\n\n// Total execution time will be ~2.5 seconds (1s + 1.5s),\n// which is a full second slower than the parallel version.\nEffect.runPromise(program).then(console.log);\n```",
    "explanation": "Running tasks sequentially when they could be done in parallel is a common source of performance bottlenecks. `Effect.all` is the solution. It's the direct equivalent of `Promise.all` in the Effect ecosystem.\n\nInstead of waiting for Task A to finish before starting Task B, `Effect.all` starts all tasks simultaneously. The total time to complete is determined by the duration of the *longest* running effect, not the sum of all durations. If any single effect in the collection fails, the entire `Effect.all` will fail immediately.\n\n---",
    "content": "## Guideline\n\nWhen you have multiple `Effect`s that do not depend on each other's results, run them concurrently using `Effect.all`. This will execute all effects at the same time and return a new `Effect` that succeeds with a tuple containing all the results.\n\n---\n\n## Rationale\n\nRunning tasks sequentially when they could be done in parallel is a common source of performance bottlenecks. `Effect.all` is the solution. It's the direct equivalent of `Promise.all` in the Effect ecosystem.\n\nInstead of waiting for Task A to finish before starting Task B, `Effect.all` starts all tasks simultaneously. The total time to complete is determined by the duration of the *longest* running effect, not the sum of all durations. If any single effect in the collection fails, the entire `Effect.all` will fail immediately.\n\n---\n\n## Good Example\n\nImagine fetching a user's profile and their latest posts from two different API endpoints. These are independent operations and can be run in parallel to save time.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Simulate fetching a user, takes 1 second\nconst fetchUser = Effect.succeed({ id: 1, name: \"Paul\" }).pipe(\n  Effect.delay(\"1 second\"),\n);\n\n// Simulate fetching posts, takes 1.5 seconds\nconst fetchPosts = Effect.succeed([{ title: \"Effect is great\" }]).pipe(\n  Effect.delay(\"1.5 seconds\"),\n);\n\n// Run both effects concurrently - must specify concurrency option!\nconst program = Effect.all([fetchUser, fetchPosts], { concurrency: \"unbounded\" });\n\n// The resulting effect will succeed with a tuple: [{id, name}, [{title}]]\n// Total execution time will be ~1.5 seconds (the duration of the longest task).\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(`Results: ${JSON.stringify(results)}`);\n  return results;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---\n\n## Anti-Pattern\n\nThe anti-pattern is running independent tasks sequentially using `Effect.gen`. This is inefficient and unnecessarily slows down your application.\n\n```typescript\nimport { Effect } from \"effect\";\nimport { fetchUser, fetchPosts } from \"./somewhere\"; // From previous example\n\n// ‚ùå WRONG: This is inefficient.\nconst program = Effect.gen(function* () {\n  // fetchUser runs and completes...\n  const user = yield* fetchUser;\n  // ...only then does fetchPosts begin.\n  const posts = yield* fetchPosts;\n  return [user, posts];\n});\n\n// Total execution time will be ~2.5 seconds (1s + 1.5s),\n// which is a full second slower than the parallel version.\nEffect.runPromise(program).then(console.log);\n```"
  },
  {
    "id": "safely-bracket-resource-usage",
    "title": "Safely Bracket Resource Usage with `acquireRelease`",
    "description": "Bracket the use of a resource between an `acquire` and a `release` effect.",
    "skillLevel": "beginner",
    "useCases": [
      "resource-management"
    ],
    "example": "```typescript\nimport { Effect, Console } from \"effect\";\n\n// A mock resource that needs to be managed\nconst getDbConnection = Effect.sync(() => ({ id: Math.random() })).pipe(\n  Effect.tap(() => Effect.log(\"Connection Acquired\")),\n);\n\nconst closeDbConnection = (conn: { id: number }): Effect.Effect<void, never, never> =>\n  Effect.log(`Connection ${conn.id} Released`);\n\n// The program that uses the resource\nconst program = Effect.acquireRelease(\n  getDbConnection, // 1. acquire\n  (connection) => closeDbConnection(connection) // 2. cleanup\n).pipe(\n  Effect.tap((connection) =>\n    Effect.log(`Using connection ${connection.id} to run query...`)\n  )\n);\n\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput:\nConnection Acquired\nUsing connection 0.12345... to run query...\nConnection 0.12345... Released\n*/\n```\n\n**Explanation:**\nBy using `Effect.acquireRelease`, the `closeDbConnection` logic is guaranteed to run after the main logic completes. This creates a self-contained, leak-proof unit of work that can be safely composed into larger programs.",
    "antiPattern": "Using a standard `try...finally` block with `async/await`. While it handles success and failure cases, it is **not interruption-safe**. If the fiber executing the `Promise` is interrupted by Effect's structured concurrency, the `finally` block is not guaranteed to run, leading to resource leaks.\n\n```typescript\n// ANTI-PATTERN: Not interruption-safe\nasync function getUser() {\n  const connection = await getDbConnectionPromise(); // acquire\n  try {\n    return await useConnectionPromise(connection); // use\n  } finally {\n    // This block may not run if the fiber is interrupted!\n    await closeConnectionPromise(connection); // release\n  }\n}\n```",
    "explanation": "This pattern is the foundation of resource safety in Effect. It provides a composable and interruption-safe alternative to a standard `try...finally` block. The `release` effect is guaranteed to execute, preventing resource leaks which are common in complex asynchronous applications, especially those involving concurrency where tasks can be cancelled.",
    "content": "# Safely Bracket Resource Usage with `acquireRelease`\n\n## Guideline\n\nWrap the acquisition, usage, and release of a resource within an `Effect.acquireRelease` call. This ensures the resource's cleanup logic is executed, regardless of whether the usage logic succeeds, fails, or is interrupted.\n\n## Rationale\n\nThis pattern is the foundation of resource safety in Effect. It provides a composable and interruption-safe alternative to a standard `try...finally` block. The `release` effect is guaranteed to execute, preventing resource leaks which are common in complex asynchronous applications, especially those involving concurrency where tasks can be cancelled.\n\n## Good Example\n\n```typescript\nimport { Effect, Console } from \"effect\";\n\n// A mock resource that needs to be managed\nconst getDbConnection = Effect.sync(() => ({ id: Math.random() })).pipe(\n  Effect.tap(() => Effect.log(\"Connection Acquired\")),\n);\n\nconst closeDbConnection = (conn: { id: number }): Effect.Effect<void, never, never> =>\n  Effect.log(`Connection ${conn.id} Released`);\n\n// The program that uses the resource\nconst program = Effect.acquireRelease(\n  getDbConnection, // 1. acquire\n  (connection) => closeDbConnection(connection) // 2. cleanup\n).pipe(\n  Effect.tap((connection) =>\n    Effect.log(`Using connection ${connection.id} to run query...`)\n  )\n);\n\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput:\nConnection Acquired\nUsing connection 0.12345... to run query...\nConnection 0.12345... Released\n*/\n```\n\n**Explanation:**\nBy using `Effect.acquireRelease`, the `closeDbConnection` logic is guaranteed to run after the main logic completes. This creates a self-contained, leak-proof unit of work that can be safely composed into larger programs.\n\n## Anti-Pattern\n\nUsing a standard `try...finally` block with `async/await`. While it handles success and failure cases, it is **not interruption-safe**. If the fiber executing the `Promise` is interrupted by Effect's structured concurrency, the `finally` block is not guaranteed to run, leading to resource leaks.\n\n```typescript\n// ANTI-PATTERN: Not interruption-safe\nasync function getUser() {\n  const connection = await getDbConnectionPromise(); // acquire\n  try {\n    return await useConnectionPromise(connection); // use\n  } finally {\n    // This block may not run if the fiber is interrupted!\n    await closeConnectionPromise(connection); // release\n  }\n}\n```"
  },
  {
    "id": "send-json-response",
    "title": "Send a JSON Response",
    "description": "Use Http.response.json to automatically serialize data structures into a JSON response.",
    "skillLevel": "beginner",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines a route that fetches a user object and returns it as a JSON response. The `Http.response.json` function handles all the necessary serialization and header configuration.\n\n```typescript\nimport { Effect, Context, Duration, Layer } from \"effect\";\nimport { NodeContext, NodeHttpServer } from \"@effect/platform-node\";\nimport { createServer } from \"node:http\";\n\nconst PORT = 3459; // Changed port to avoid conflicts\n\n// Define HTTP Server service\nclass JsonServer extends Effect.Service<JsonServer>()(\"JsonServer\", {\n  sync: () => ({\n    handleRequest: () =>\n      Effect.succeed({\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          message: \"Hello, JSON!\",\n          timestamp: new Date().toISOString(),\n        }),\n      }),\n  }),\n}) {}\n\n// Create and run the server\nconst program = Effect.gen(function* () {\n  const jsonServer = yield* JsonServer;\n\n  // Create and start HTTP server\n  const server = createServer((req, res) => {\n    const requestHandler = Effect.gen(function* () {\n      try {\n        const response = yield* jsonServer.handleRequest();\n        res.writeHead(response.status, response.headers);\n        res.end(response.body);\n        // Log the response for demonstration\n        yield* Effect.logInfo(`Sent JSON response: ${response.body}`);\n      } catch (error: any) {\n        res.writeHead(500, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Internal Server Error\" }));\n        yield* Effect.logError(`Request error: ${error.message}`);\n      }\n    });\n    \n    Effect.runPromise(requestHandler);\n  });\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    server.on(\"error\", (error: NodeJS.ErrnoException) => {\n      if (error.code === \"EADDRINUSE\") {\n        resume(Effect.fail(new Error(`Port ${PORT} is already in use`)));\n      } else {\n        resume(Effect.fail(error));\n      }\n    });\n\n    server.listen(PORT, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.logInfo(`Server running at http://localhost:${PORT}`);\n  yield* Effect.logInfo(\"Try: curl http://localhost:3459\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  // Shutdown gracefully\n  yield* Effect.sync(() => server.close());\n  yield* Effect.logInfo(\"Server shutdown complete\");\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Server error: ${error.message}`);\n      return error;\n    })\n  ),\n  // Merge layers and provide them in a single call to ensure proper lifecycle management\n  Effect.provide(Layer.merge(\n    JsonServer.Default,\n    NodeContext.layer\n  ))\n);\n\n// Run the program\n// Use Effect.runFork for server applications that shouldn't resolve the promise\nEffect.runPromise(program.pipe(\n  // Ensure the Effect has no remaining context requirements for runPromise\n  Effect.map(() => undefined)\n));\n\n```",
    "antiPattern": "The anti-pattern is to manually serialize the data to a string and set the headers yourself. This is verbose and introduces opportunities for error.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst getUserRoute = Http.router.get(\n  '/users/1',\n  Effect.succeed({ id: 1, name: 'Paul', team: 'Effect' }).pipe(\n    Effect.flatMap((user) => {\n      // Manually serialize the object to a JSON string.\n      const jsonString = JSON.stringify(user);\n      // Create a text response with the string.\n      const response = Http.response.text(jsonString);\n      // Manually set the Content-Type header.\n      return Effect.succeed(\n        Http.response.setHeader(\n          response,\n          'Content-Type',\n          'application/json; charset=utf-8'\n        )\n      );\n    })\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(getUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual approach is unnecessarily complex. It forces you to remember to perform both the serialization and the header configuration. If you forget the `setHeader` call, many clients will fail to parse the response correctly. The `Http.response.json` helper eliminates this entire class of potential bugs.",
    "explanation": "APIs predominantly communicate using JSON. The `Http` module provides a dedicated `Http.response.json` helper to make this as simple and robust as possible. Manually constructing a JSON response involves serializing the data and setting the correct HTTP headers, which is tedious and error-prone.\n\nUsing `Http.response.json` is superior because:\n\n1.  **Automatic Serialization**: It safely handles the `JSON.stringify` operation for you, including handling potential circular references or other serialization errors.\n2.  **Correct Headers**: It automatically sets the `Content-Type: application/json; charset=utf-8` header. This is critical for clients to correctly interpret the response body. Forgetting this header is a common source of bugs in manually constructed APIs.\n3.  **Simplicity and Readability**: Your intent is made clear with a single, declarative function call. The code is cleaner and focuses on the data being sent, not the mechanics of HTTP.\n4.  **Composability**: It creates a standard `Http.response` object that works seamlessly with all other parts of the Effect `Http` module.\n\n---",
    "content": "## Guideline\n\nTo return a JavaScript object or value as a JSON response, use the `Http.response.json(data)` constructor.\n\n---\n\n## Rationale\n\nAPIs predominantly communicate using JSON. The `Http` module provides a dedicated `Http.response.json` helper to make this as simple and robust as possible. Manually constructing a JSON response involves serializing the data and setting the correct HTTP headers, which is tedious and error-prone.\n\nUsing `Http.response.json` is superior because:\n\n1.  **Automatic Serialization**: It safely handles the `JSON.stringify` operation for you, including handling potential circular references or other serialization errors.\n2.  **Correct Headers**: It automatically sets the `Content-Type: application/json; charset=utf-8` header. This is critical for clients to correctly interpret the response body. Forgetting this header is a common source of bugs in manually constructed APIs.\n3.  **Simplicity and Readability**: Your intent is made clear with a single, declarative function call. The code is cleaner and focuses on the data being sent, not the mechanics of HTTP.\n4.  **Composability**: It creates a standard `Http.response` object that works seamlessly with all other parts of the Effect `Http` module.\n\n---\n\n## Good Example\n\nThis example defines a route that fetches a user object and returns it as a JSON response. The `Http.response.json` function handles all the necessary serialization and header configuration.\n\n```typescript\nimport { Effect, Context, Duration, Layer } from \"effect\";\nimport { NodeContext, NodeHttpServer } from \"@effect/platform-node\";\nimport { createServer } from \"node:http\";\n\nconst PORT = 3459; // Changed port to avoid conflicts\n\n// Define HTTP Server service\nclass JsonServer extends Effect.Service<JsonServer>()(\"JsonServer\", {\n  sync: () => ({\n    handleRequest: () =>\n      Effect.succeed({\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          message: \"Hello, JSON!\",\n          timestamp: new Date().toISOString(),\n        }),\n      }),\n  }),\n}) {}\n\n// Create and run the server\nconst program = Effect.gen(function* () {\n  const jsonServer = yield* JsonServer;\n\n  // Create and start HTTP server\n  const server = createServer((req, res) => {\n    const requestHandler = Effect.gen(function* () {\n      try {\n        const response = yield* jsonServer.handleRequest();\n        res.writeHead(response.status, response.headers);\n        res.end(response.body);\n        // Log the response for demonstration\n        yield* Effect.logInfo(`Sent JSON response: ${response.body}`);\n      } catch (error: any) {\n        res.writeHead(500, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Internal Server Error\" }));\n        yield* Effect.logError(`Request error: ${error.message}`);\n      }\n    });\n    \n    Effect.runPromise(requestHandler);\n  });\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    server.on(\"error\", (error: NodeJS.ErrnoException) => {\n      if (error.code === \"EADDRINUSE\") {\n        resume(Effect.fail(new Error(`Port ${PORT} is already in use`)));\n      } else {\n        resume(Effect.fail(error));\n      }\n    });\n\n    server.listen(PORT, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.logInfo(`Server running at http://localhost:${PORT}`);\n  yield* Effect.logInfo(\"Try: curl http://localhost:3459\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  // Shutdown gracefully\n  yield* Effect.sync(() => server.close());\n  yield* Effect.logInfo(\"Server shutdown complete\");\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Server error: ${error.message}`);\n      return error;\n    })\n  ),\n  // Merge layers and provide them in a single call to ensure proper lifecycle management\n  Effect.provide(Layer.merge(\n    JsonServer.Default,\n    NodeContext.layer\n  ))\n);\n\n// Run the program\n// Use Effect.runFork for server applications that shouldn't resolve the promise\nEffect.runPromise(program.pipe(\n  // Ensure the Effect has no remaining context requirements for runPromise\n  Effect.map(() => undefined)\n));\n\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to manually serialize the data to a string and set the headers yourself. This is verbose and introduces opportunities for error.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst getUserRoute = Http.router.get(\n  '/users/1',\n  Effect.succeed({ id: 1, name: 'Paul', team: 'Effect' }).pipe(\n    Effect.flatMap((user) => {\n      // Manually serialize the object to a JSON string.\n      const jsonString = JSON.stringify(user);\n      // Create a text response with the string.\n      const response = Http.response.text(jsonString);\n      // Manually set the Content-Type header.\n      return Effect.succeed(\n        Http.response.setHeader(\n          response,\n          'Content-Type',\n          'application/json; charset=utf-8'\n        )\n      );\n    })\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(getUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual approach is unnecessarily complex. It forces you to remember to perform both the serialization and the header configuration. If you forget the `setHeader` call, many clients will fail to parse the response correctly. The `Http.response.json` helper eliminates this entire class of potential bugs."
  },
  {
    "id": "combinator-sequencing",
    "title": "Sequencing with andThen, tap, and flatten",
    "description": "Use sequencing combinators to run computations in order, perform side effects, or flatten nested structures, while preserving error and context handling.",
    "skillLevel": "intermediate",
    "useCases": [
      "concurrency"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// andThen: Run one effect, then another, ignore the first result\nconst logThenCompute = Effect.log(\"Starting...\").pipe(\n  Effect.andThen(Effect.succeed(42))\n); // Effect<number>\n\n// tap: Log the result of an effect, but keep the value\nconst computeAndLog = Effect.succeed(42).pipe(\n  Effect.tap((n) => Effect.log(`Result is ${n}`))\n); // Effect<number>\n\n// flatten: Remove one level of nesting\nconst nestedOption = Option.some(Option.some(1));\nconst flatOption = Option.flatten(nestedOption); // Option<number>\n\nconst nestedEffect = Effect.succeed(Effect.succeed(1));\nconst flatEffect = Effect.flatten(nestedEffect); // Effect<number>\n\n// tapError: Log errors without handling them\nconst mightFail = Effect.fail(\"fail!\").pipe(\n  Effect.tapError((err) => Effect.logError(`Error: ${err}`))\n); // Effect<never>\n\n// Stream: tap for side effects on each element\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(\n  Stream.tap((n) => Effect.log(`Saw: ${n}`))\n); // Stream<number>\n```\n\n**Explanation:**  \n- `andThen` is for sequencing when you don‚Äôt care about the first result.\n- `tap` is for running side effects (like logging) without changing the value.\n- `flatten` is for removing unnecessary nesting (e.g., `Option<Option<A>>` ‚Üí `Option<A>`).",
    "antiPattern": "Using `flatMap` with a function that ignores its argument, or manually unwrapping and re-wrapping nested structures, instead of using the dedicated combinators.",
    "explanation": "Sequencing is fundamental for expressing workflows.  \nThese combinators let you:\n- Run computations in order (`andThen`)\n- Attach logging, metrics, or other side effects (`tap`)\n- Simplify nested structures (`flatten`)\n\nAll while preserving composability, error handling, and type safety.",
    "content": "# Sequencing with `andThen`, `tap`, and `flatten`\n\n## Guideline\n\nUse sequencing combinators to run computations in order, perform side effects, or flatten nested structures.  \n- `andThen` runs one computation after another, ignoring the first result.\n- `tap` runs a side-effecting computation with the result, without changing the value.\n- `flatten` removes one level of nesting from nested structures.\n\nThese work for `Effect`, `Stream`, `Option`, and `Either`.\n\n## Rationale\n\nSequencing is fundamental for expressing workflows.  \nThese combinators let you:\n- Run computations in order (`andThen`)\n- Attach logging, metrics, or other side effects (`tap`)\n- Simplify nested structures (`flatten`)\n\nAll while preserving composability, error handling, and type safety.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// andThen: Run one effect, then another, ignore the first result\nconst logThenCompute = Effect.log(\"Starting...\").pipe(\n  Effect.andThen(Effect.succeed(42))\n); // Effect<number>\n\n// tap: Log the result of an effect, but keep the value\nconst computeAndLog = Effect.succeed(42).pipe(\n  Effect.tap((n) => Effect.log(`Result is ${n}`))\n); // Effect<number>\n\n// flatten: Remove one level of nesting\nconst nestedOption = Option.some(Option.some(1));\nconst flatOption = Option.flatten(nestedOption); // Option<number>\n\nconst nestedEffect = Effect.succeed(Effect.succeed(1));\nconst flatEffect = Effect.flatten(nestedEffect); // Effect<number>\n\n// tapError: Log errors without handling them\nconst mightFail = Effect.fail(\"fail!\").pipe(\n  Effect.tapError((err) => Effect.logError(`Error: ${err}`))\n); // Effect<never>\n\n// Stream: tap for side effects on each element\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(\n  Stream.tap((n) => Effect.log(`Saw: ${n}`))\n); // Stream<number>\n```\n\n**Explanation:**  \n- `andThen` is for sequencing when you don‚Äôt care about the first result.\n- `tap` is for running side effects (like logging) without changing the value.\n- `flatten` is for removing unnecessary nesting (e.g., `Option<Option<A>>` ‚Üí `Option<A>`).\n\n## Anti-Pattern\n\nUsing `flatMap` with a function that ignores its argument, or manually unwrapping and re-wrapping nested structures, instead of using the dedicated combinators."
  },
  {
    "id": "setup-new-project",
    "title": "Set Up a New Effect Project",
    "description": "Set up a new Effect project.",
    "skillLevel": "beginner",
    "useCases": [
      "project-setup--execution"
    ],
    "example": "```typescript\n// 1. Init project (e.g., `npm init -y`)\n// 2. Install deps (e.g., `npm install effect`, `npm install -D typescript tsx`)\n// 3. Create tsconfig.json with `\"strict\": true`\n// 4. Create src/index.ts\nimport { Effect } from \"effect\";\n\nconst program = Effect.log(\"Hello, World!\");\n\nEffect.runSync(program);\n\n// 5. Run the program (e.g., `npx tsx src/index.ts`)\n```\n\n**Explanation:**  \nThis setup ensures you have TypeScript and Effect ready to go, with strict\ntype-checking for maximum safety and correctness.",
    "antiPattern": "Avoid disabling `strict` mode in your `tsconfig.json`. Running with\n`\"strict\": false` will cause you to lose many of the type-safety guarantees\nthat make Effect so powerful.",
    "explanation": "A proper setup is crucial for leveraging Effect's powerful type-safety\nfeatures. Using TypeScript's `strict` mode is non-negotiable.",
    "content": "# Set Up a New Effect Project\n\n## Guideline\n\nTo start a new Effect project, initialize a standard Node.js project, add\n`effect` and `typescript` as dependencies, and create a `tsconfig.json` file\nwith strict mode enabled.\n\n## Rationale\n\nA proper setup is crucial for leveraging Effect's powerful type-safety\nfeatures. Using TypeScript's `strict` mode is non-negotiable.\n\n## Good Example\n\n```typescript\n// 1. Init project (e.g., `npm init -y`)\n// 2. Install deps (e.g., `npm install effect`, `npm install -D typescript tsx`)\n// 3. Create tsconfig.json with `\"strict\": true`\n// 4. Create src/index.ts\nimport { Effect } from \"effect\";\n\nconst program = Effect.log(\"Hello, World!\");\n\nEffect.runSync(program);\n\n// 5. Run the program (e.g., `npx tsx src/index.ts`)\n```\n\n**Explanation:**  \nThis setup ensures you have TypeScript and Effect ready to go, with strict\ntype-checking for maximum safety and correctness.\n\n## Anti-Pattern\n\nAvoid disabling `strict` mode in your `tsconfig.json`. Running with\n`\"strict\": false` will cause you to lose many of the type-safety guarantees\nthat make Effect so powerful."
  },
  {
    "id": "solve-promise-problems-with-effect",
    "title": "Solve Promise Problems with Effect",
    "description": "Recognize that Effect solves the core limitations of Promises: untyped errors, no dependency injection, and no cancellation.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "This code is type-safe, testable, and cancellable. The signature `Effect.Effect<User, DbError, HttpClient>` tells us everything we need to know.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\ninterface DbErrorType {\n  readonly _tag: \"DbError\";\n  readonly message: string;\n}\n\nconst DbError = Data.tagged<DbErrorType>(\"DbError\");\n\ninterface User {\n  name: string;\n}\n\nclass HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  sync: () => ({\n    findById: (id: number): Effect.Effect<User, DbErrorType> =>\n      Effect.try({\n        try: () => ({ name: `User ${id}` }),\n        catch: () => DbError({ message: \"Failed to find user\" }),\n      }),\n  }),\n}) {}\n\nconst findUser = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    return yield* client.findById(id);\n  });\n\n// Demonstrate how Effect solves promise problems\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Solving Promise Problems with Effect ===\");\n\n  // Problem 1: Proper error handling (no more try/catch hell)\n  yield* Effect.logInfo(\"1. Demonstrating type-safe error handling:\");\n\n  const result1 = yield* findUser(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Handled error: ${error.message}`);\n        return { name: \"Default User\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Found user: ${result1.name}`);\n\n  // Problem 2: Easy composition and chaining\n  yield* Effect.logInfo(\"\\n2. Demonstrating easy composition:\");\n\n  const composedOperation = Effect.gen(function* () {\n    const user1 = yield* findUser(1);\n    const user2 = yield* findUser(2);\n    yield* Effect.logInfo(`Composed result: ${user1.name} and ${user2.name}`);\n    return [user1, user2];\n  });\n\n  yield* composedOperation;\n\n  // Problem 3: Resource management and cleanup\n  yield* Effect.logInfo(\"\\n3. Demonstrating resource management:\");\n\n  const resourceOperation = Effect.gen(function* () {\n    yield* Effect.logInfo(\"Acquiring resource...\");\n    const resource = \"database-connection\";\n\n    yield* Effect.addFinalizer(() => Effect.logInfo(\"Cleaning up resource...\"));\n\n    const user = yield* findUser(456);\n    yield* Effect.logInfo(`Used resource to get: ${user.name}`);\n\n    return user;\n  }).pipe(Effect.scoped);\n\n  yield* resourceOperation;\n\n  yield* Effect.logInfo(\"\\n‚úÖ All operations completed successfully!\");\n});\n\nEffect.runPromise(Effect.provide(program, HttpClient.Default));\n\n```\n\n---",
    "antiPattern": "This `Promise`-based function has several hidden problems that Effect solves:\n-   What happens if `db.findUser` rejects? The error is untyped (`any`).\n-   Where does `db` come from? It's a hidden dependency, making this function hard to test.\n-   If the operation is slow, how do we cancel it? We can't.\n\n```typescript\n// ‚ùå This function has hidden dependencies and untyped errors.\nasync function findUserUnsafely(id: number): Promise<any> {\n  try {\n    const user = await db.findUser(id); // `db` is a hidden global or import\n    return user;\n  } catch (error) {\n    // `error` is of type `any`. We don't know what it is.\n    // We might log it and re-throw, but we can't handle it safely.\n    throw error;\n  }\n}\n```",
    "explanation": "While `async/await` is great for simple cases, building large, robust applications with `Promise`s reveals these critical gaps. Effect addresses each one directly:\n\n-   **Typed Errors:** The `E` channel in `Effect<A, E, R>` forces you to handle specific, known error types, eliminating an entire class of runtime bugs.\n-   **Dependency Injection:** The `R` channel provides a powerful, built-in system for declaring and providing dependencies (`Layer`s), making your code modular and testable.\n-   **Cancellation (Interruption):** Effect's structured concurrency and `Fiber` model provide robust, built-in cancellation. When an effect is interrupted, Effect guarantees that its cleanup logic (finalizers) will be run.\n\nUnderstanding that Effect was built specifically to solve these problems is key to appreciating its design and power.\n\n---",
    "content": "## Guideline\n\nRecognize that `Effect` is not just a \"better Promise,\" but a fundamentally different construct designed to solve the core limitations of native `Promise`s in TypeScript:\n1.  **Untyped Errors:** Promises can reject with `any` value, forcing `try/catch` blocks and unsafe type checks.\n2.  **No Dependency Injection:** Promises have no built-in way to declare or manage dependencies, leading to tightly coupled code.\n3.  **No Cancellation:** Once a `Promise` starts, it cannot be cancelled from the outside.\n\n---\n\n## Rationale\n\nWhile `async/await` is great for simple cases, building large, robust applications with `Promise`s reveals these critical gaps. Effect addresses each one directly:\n\n-   **Typed Errors:** The `E` channel in `Effect<A, E, R>` forces you to handle specific, known error types, eliminating an entire class of runtime bugs.\n-   **Dependency Injection:** The `R` channel provides a powerful, built-in system for declaring and providing dependencies (`Layer`s), making your code modular and testable.\n-   **Cancellation (Interruption):** Effect's structured concurrency and `Fiber` model provide robust, built-in cancellation. When an effect is interrupted, Effect guarantees that its cleanup logic (finalizers) will be run.\n\nUnderstanding that Effect was built specifically to solve these problems is key to appreciating its design and power.\n\n---\n\n## Good Example (The Effect Way)\n\nThis code is type-safe, testable, and cancellable. The signature `Effect.Effect<User, DbError, HttpClient>` tells us everything we need to know.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\ninterface DbErrorType {\n  readonly _tag: \"DbError\";\n  readonly message: string;\n}\n\nconst DbError = Data.tagged<DbErrorType>(\"DbError\");\n\ninterface User {\n  name: string;\n}\n\nclass HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  sync: () => ({\n    findById: (id: number): Effect.Effect<User, DbErrorType> =>\n      Effect.try({\n        try: () => ({ name: `User ${id}` }),\n        catch: () => DbError({ message: \"Failed to find user\" }),\n      }),\n  }),\n}) {}\n\nconst findUser = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    return yield* client.findById(id);\n  });\n\n// Demonstrate how Effect solves promise problems\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Solving Promise Problems with Effect ===\");\n\n  // Problem 1: Proper error handling (no more try/catch hell)\n  yield* Effect.logInfo(\"1. Demonstrating type-safe error handling:\");\n\n  const result1 = yield* findUser(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Handled error: ${error.message}`);\n        return { name: \"Default User\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Found user: ${result1.name}`);\n\n  // Problem 2: Easy composition and chaining\n  yield* Effect.logInfo(\"\\n2. Demonstrating easy composition:\");\n\n  const composedOperation = Effect.gen(function* () {\n    const user1 = yield* findUser(1);\n    const user2 = yield* findUser(2);\n    yield* Effect.logInfo(`Composed result: ${user1.name} and ${user2.name}`);\n    return [user1, user2];\n  });\n\n  yield* composedOperation;\n\n  // Problem 3: Resource management and cleanup\n  yield* Effect.logInfo(\"\\n3. Demonstrating resource management:\");\n\n  const resourceOperation = Effect.gen(function* () {\n    yield* Effect.logInfo(\"Acquiring resource...\");\n    const resource = \"database-connection\";\n\n    yield* Effect.addFinalizer(() => Effect.logInfo(\"Cleaning up resource...\"));\n\n    const user = yield* findUser(456);\n    yield* Effect.logInfo(`Used resource to get: ${user.name}`);\n\n    return user;\n  }).pipe(Effect.scoped);\n\n  yield* resourceOperation;\n\n  yield* Effect.logInfo(\"\\n‚úÖ All operations completed successfully!\");\n});\n\nEffect.runPromise(Effect.provide(program, HttpClient.Default));\n\n```\n\n---\n\n## Anti-Pattern (The Promise Way)\n\nThis `Promise`-based function has several hidden problems that Effect solves:\n-   What happens if `db.findUser` rejects? The error is untyped (`any`).\n-   Where does `db` come from? It's a hidden dependency, making this function hard to test.\n-   If the operation is slow, how do we cancel it? We can't.\n\n```typescript\n// ‚ùå This function has hidden dependencies and untyped errors.\nasync function findUserUnsafely(id: number): Promise<any> {\n  try {\n    const user = await db.findUser(id); // `db` is a hidden global or import\n    return user;\n  } catch (error) {\n    // `error` is of type `any`. We don't know what it is.\n    // We might log it and re-throw, but we can't handle it safely.\n    throw error;\n  }\n}\n```"
  },
  {
    "id": "supercharge-your-editor-with-the-effect-lsp",
    "title": "Supercharge Your Editor with the Effect LSP",
    "description": "Install and use the Effect LSP extension for enhanced type information and error checking in your editor.",
    "skillLevel": "intermediate",
    "useCases": [
      "tooling-and-debugging"
    ],
    "example": "Imagine you have the following code. Without the LSP, hovering over `program` might show a complex, hard-to-read inferred type.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define Logger service using Effect.Service pattern\nclass Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.log(`LOG: ${msg}`)\n    })\n  }\n) {}\n\nconst program = Effect.succeed(42).pipe(\n  Effect.map((n) => n.toString()),\n  Effect.flatMap((s) => Effect.log(s)),\n  Effect.provide(Logger.Default)\n);\n\n// Run the program\nEffect.runPromise(program);\n```\n\nWith the Effect LSP installed, your editor would display a clear, readable overlay right above the `program` variable, looking something like this:\n\n```\n// (LSP Inlay Hint)\n// program: Effect<void, never, never>\n```\n\nThis immediately tells you that the final program returns nothing (`void`), has no expected failures (`never`), and has no remaining requirements (`never`), so it's ready to be run.\n\n---",
    "antiPattern": "Going without the LSP. While your code will still compile and work perfectly fine, you are essentially \"flying blind.\" You miss out on the rich, real-time feedback that the LSP provides, forcing you to rely more heavily on manual type checking, `tsc` runs, and deciphering complex inferred types from your editor's default tooltips. This leads to a slower, less efficient development cycle.",
    "explanation": "Effect's type system is incredibly powerful, but TypeScript's default language server doesn't always display the rich information contained within the `A`, `E`, and `R` channels in the most intuitive way.\n\nThe Effect LSP is a specialized tool that understands the semantics of Effect. It hooks into your editor to provide a superior experience:\n-   **Rich Inline Types:** It displays the full `Effect<A, E, R>` signature directly in your code as you work, so you always know exactly what an effect produces, how it can fail, and what it requires.\n-   **Clear Error Messages:** It provides more specific and helpful error messages tailored to Effect's APIs.\n-   **Enhanced Autocompletion:** It can offer more context-aware suggestions.\n\nThis tool essentially makes the compiler's knowledge visible at a glance, reducing the mental overhead of tracking complex types and allowing you to catch errors before you even save the file.\n\n---",
    "content": "## Guideline\n\nTo significantly improve your development experience with Effect, install the official **Effect Language Server (LSP)** extension for your code editor (e.g., the \"Effect\" extension in VS Code).\n\n---\n\n## Rationale\n\nEffect's type system is incredibly powerful, but TypeScript's default language server doesn't always display the rich information contained within the `A`, `E`, and `R` channels in the most intuitive way.\n\nThe Effect LSP is a specialized tool that understands the semantics of Effect. It hooks into your editor to provide a superior experience:\n-   **Rich Inline Types:** It displays the full `Effect<A, E, R>` signature directly in your code as you work, so you always know exactly what an effect produces, how it can fail, and what it requires.\n-   **Clear Error Messages:** It provides more specific and helpful error messages tailored to Effect's APIs.\n-   **Enhanced Autocompletion:** It can offer more context-aware suggestions.\n\nThis tool essentially makes the compiler's knowledge visible at a glance, reducing the mental overhead of tracking complex types and allowing you to catch errors before you even save the file.\n\n---\n\n## Good Example\n\nImagine you have the following code. Without the LSP, hovering over `program` might show a complex, hard-to-read inferred type.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define Logger service using Effect.Service pattern\nclass Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.log(`LOG: ${msg}`)\n    })\n  }\n) {}\n\nconst program = Effect.succeed(42).pipe(\n  Effect.map((n) => n.toString()),\n  Effect.flatMap((s) => Effect.log(s)),\n  Effect.provide(Logger.Default)\n);\n\n// Run the program\nEffect.runPromise(program);\n```\n\nWith the Effect LSP installed, your editor would display a clear, readable overlay right above the `program` variable, looking something like this:\n\n```\n// (LSP Inlay Hint)\n// program: Effect<void, never, never>\n```\n\nThis immediately tells you that the final program returns nothing (`void`), has no expected failures (`never`), and has no remaining requirements (`never`), so it's ready to be run.\n\n---\n\n## Anti-Pattern\n\nGoing without the LSP. While your code will still compile and work perfectly fine, you are essentially \"flying blind.\" You miss out on the rich, real-time feedback that the LSP provides, forcing you to rely more heavily on manual type checking, `tsc` runs, and deciphering complex inferred types from your editor's default tooltips. This leads to a slower, less efficient development cycle."
  },
  {
    "id": "teach-your-ai-agents-effect-with-the-mcp-server",
    "title": "Teach your AI Agents Effect with the MCP Server",
    "description": "Use the MCP server to provide live application context to AI coding agents, enabling more accurate assistance.",
    "skillLevel": "advanced",
    "useCases": [
      "tooling-and-debugging"
    ],
    "example": "The \"Good Example\" is the workflow this pattern enables.\n\n1.  **You run the MCP server** in your terminal, pointing it at your main `AppLayer`.\n    ```bash\n    npx @effect/mcp-server --layer src/layers.ts:AppLayer\n    ```\n\n2.  **You configure your AI agent** (e.g., Cursor) to use the MCP server's endpoint (`http://localhost:3333`).\n\n3.  **You ask the AI a question** that requires deep context about your app:\n    > \"Refactor this code to use the `UserService` to fetch a user by ID and log the result with the `Logger`.\"\n\n4.  **The AI, in the background, queries the MCP server:**\n    -   It discovers that `UserService` and `Logger` are available in the `AppLayer`.\n    -   It retrieves the exact method signature for `UserService.getUser` and `Logger.log`.\n\n5.  **The AI generates correct, context-aware code** because it's not guessing; it's using the live architectural information provided by the MCP server.\n\n```typescript\n// The AI generates this correct code:\nimport { Effect } from \"effect\";\nimport { UserService } from \"./features/User/UserService.js\";\nconst program = Effect.gen(function* () {\n  const userService = yield* UserService;\n\n  const user = yield* userService.getUser(\"123\");\n  yield* Effect.log(`Found user: ${user.name}`);\n});\n\n```\n\n---",
    "antiPattern": "Working with an AI agent without providing it with specific context. The agent will be forced to guess based on open files or generic knowledge. This often leads to it hallucinating method names, getting dependency injection wrong, or failing to handle specific error types, requiring you to manually correct its output and defeating the purpose of using an AI assistant.",
    "explanation": "AI coding agents are powerful, but they often lack the deep, structural understanding of a complex Effect application. They might not know which services are available in the context, what a specific `Layer` provides, or how your feature modules are composed.\n\nThe MCP server solves this problem. It's a specialized server that runs alongside your application during development. It inspects your `AppLayer` and creates a real-time, queryable model of your entire application architecture.\n\nAn AI agent can then connect to this MCP server to ask specific questions before generating code, such as:\n-   \"What services are available in the current context?\"\n-   \"What is the full API of the `UserService`?\"\n-   \"What errors can `UserRepository.findById` fail with?\"\n\nBy providing this live, ground-truth context, you transform your AI from a generic coding assistant into a specialized expert on *your* specific codebase, resulting in far more accurate and useful code generation and refactoring.\n\n---",
    "content": "## Guideline\n\nTo enable AI coding agents (like Cursor or custom bots) to provide highly accurate, context-aware assistance for your Effect application, run the **Effect MCP (Meta-Circular-Protocol) server**. This tool exposes your application's entire dependency graph and service structure in a machine-readable format.\n\n---\n\n## Rationale\n\nAI coding agents are powerful, but they often lack the deep, structural understanding of a complex Effect application. They might not know which services are available in the context, what a specific `Layer` provides, or how your feature modules are composed.\n\nThe MCP server solves this problem. It's a specialized server that runs alongside your application during development. It inspects your `AppLayer` and creates a real-time, queryable model of your entire application architecture.\n\nAn AI agent can then connect to this MCP server to ask specific questions before generating code, such as:\n-   \"What services are available in the current context?\"\n-   \"What is the full API of the `UserService`?\"\n-   \"What errors can `UserRepository.findById` fail with?\"\n\nBy providing this live, ground-truth context, you transform your AI from a generic coding assistant into a specialized expert on *your* specific codebase, resulting in far more accurate and useful code generation and refactoring.\n\n---\n\n## Good Example\n\nThe \"Good Example\" is the workflow this pattern enables.\n\n1.  **You run the MCP server** in your terminal, pointing it at your main `AppLayer`.\n    ```bash\n    npx @effect/mcp-server --layer src/layers.ts:AppLayer\n    ```\n\n2.  **You configure your AI agent** (e.g., Cursor) to use the MCP server's endpoint (`http://localhost:3333`).\n\n3.  **You ask the AI a question** that requires deep context about your app:\n    > \"Refactor this code to use the `UserService` to fetch a user by ID and log the result with the `Logger`.\"\n\n4.  **The AI, in the background, queries the MCP server:**\n    -   It discovers that `UserService` and `Logger` are available in the `AppLayer`.\n    -   It retrieves the exact method signature for `UserService.getUser` and `Logger.log`.\n\n5.  **The AI generates correct, context-aware code** because it's not guessing; it's using the live architectural information provided by the MCP server.\n\n```typescript\n// The AI generates this correct code:\nimport { Effect } from \"effect\";\nimport { UserService } from \"./features/User/UserService.js\";\nconst program = Effect.gen(function* () {\n  const userService = yield* UserService;\n\n  const user = yield* userService.getUser(\"123\");\n  yield* Effect.log(`Found user: ${user.name}`);\n});\n\n```\n\n---\n\n## Anti-Pattern\n\nWorking with an AI agent without providing it with specific context. The agent will be forced to guess based on open files or generic knowledge. This often leads to it hallucinating method names, getting dependency injection wrong, or failing to handle specific error types, requiring you to manually correct its output and defeating the purpose of using an AI assistant."
  },
  {
    "id": "trace-operations-with-spans",
    "title": "Trace Operations Across Services with Spans",
    "description": "Use Effect.withSpan to create custom tracing spans for important operations.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "This example shows a multi-step operation. Each step, and the overall operation, is wrapped in a span. This creates a parent-child hierarchy in the trace that is easy to visualize.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\nconst validateInput = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Starting input validation...\");\n    yield* Effect.sleep(Duration.millis(10));\n    const result = { email: \"paul@example.com\" };\n    yield* Effect.logInfo(`‚úÖ Input validated: ${result.email}`);\n    return result;\n  }).pipe(\n    // This creates a child span\n    Effect.withSpan(\"validateInput\")\n  );\n\nconst saveToDatabase = (user: { email: string }) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Saving user to database: ${user.email}`);\n    yield* Effect.sleep(Duration.millis(50));\n    const result = { id: 123, ...user };\n    yield* Effect.logInfo(`‚úÖ User saved with ID: ${result.id}`);\n    return result;\n  }).pipe(\n    // This span includes useful attributes\n    Effect.withSpan(\"saveToDatabase\", {\n      attributes: { \"db.system\": \"postgresql\", \"db.user.email\": user.email },\n    })\n  );\n\nconst createUser = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"=== Creating User with Tracing ===\");\n    yield* Effect.logInfo(\n      \"This demonstrates how spans trace operations through the call stack\"\n    );\n\n    const validated = yield* validateInput(input);\n    const user = yield* saveToDatabase(validated);\n\n    yield* Effect.logInfo(\n      `‚úÖ User creation completed: ${JSON.stringify(user)}`\n    );\n    yield* Effect.logInfo(\n      \"Note: In production, spans would be sent to a tracing system like Jaeger or Zipkin\"\n    );\n\n    return user;\n  }).pipe(\n    // This is the parent span for the entire operation\n    Effect.withSpan(\"createUserOperation\")\n  );\n\n// Demonstrate the tracing functionality\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Trace Operations with Spans Demo ===\");\n\n  // Create multiple users to show tracing in action\n  const user1 = yield* createUser({ email: \"user1@example.com\" });\n\n  yield* Effect.logInfo(\"\\n--- Creating second user ---\");\n  const user2 = yield* createUser({ email: \"user2@example.com\" });\n\n  yield* Effect.logInfo(\"\\n=== Summary ===\");\n  yield* Effect.logInfo(\"Created users with tracing spans:\");\n  yield* Effect.logInfo(`User 1: ID ${user1.id}, Email: ${user1.email}`);\n  yield* Effect.logInfo(`User 2: ID ${user2.id}, Email: ${user2.email}`);\n});\n\n// When run with a tracing SDK, this will produce traces with root spans\n// \"createUserOperation\" and child spans: \"validateInput\" and \"saveToDatabase\".\nEffect.runPromise(program);\n\n```\n\n---",
    "antiPattern": "Not adding custom spans to your business logic. \nWithout them, your traces will only show high-level information from your framework (e.g., \"HTTP POST /users\"). \nYou will have no visibility into the performance of the individual steps *inside* your request handler, making it very difficult to pinpoint bottlenecks. Your application's logic remains a \"black box\" in your traces.",
    "explanation": "While logs tell you *what* happened, traces tell you *why it was slow*. In a complex application, a single user request might trigger calls to multiple services (authentication, database, external APIs). Tracing allows you to visualize this entire chain of events as a single, hierarchical \"trace.\"\n\nEach piece of work in that trace is a `span`. `Effect.withSpan` allows you to create your own custom spans. This is invaluable for answering questions like:\n-   \"For this API request, did we spend most of our time in the database or calling the external payment gateway?\"\n-   \"Which part of our user creation logic is the bottleneck?\"\n\nEffect's tracing is built on OpenTelemetry, the industry standard, so it integrates seamlessly with tools like Jaeger, Zipkin, and Datadog.\n\n---",
    "content": "## Guideline\n\nTo gain visibility into the performance and flow of your application, wrap logical units of work with `Effect.withSpan(\"span-name\")`. You can add contextual information to these spans using the `attributes` option.\n\n---\n\n## Rationale\n\nWhile logs tell you *what* happened, traces tell you *why it was slow*. In a complex application, a single user request might trigger calls to multiple services (authentication, database, external APIs). Tracing allows you to visualize this entire chain of events as a single, hierarchical \"trace.\"\n\nEach piece of work in that trace is a `span`. `Effect.withSpan` allows you to create your own custom spans. This is invaluable for answering questions like:\n-   \"For this API request, did we spend most of our time in the database or calling the external payment gateway?\"\n-   \"Which part of our user creation logic is the bottleneck?\"\n\nEffect's tracing is built on OpenTelemetry, the industry standard, so it integrates seamlessly with tools like Jaeger, Zipkin, and Datadog.\n\n---\n\n## Good Example\n\nThis example shows a multi-step operation. Each step, and the overall operation, is wrapped in a span. This creates a parent-child hierarchy in the trace that is easy to visualize.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\nconst validateInput = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Starting input validation...\");\n    yield* Effect.sleep(Duration.millis(10));\n    const result = { email: \"paul@example.com\" };\n    yield* Effect.logInfo(`‚úÖ Input validated: ${result.email}`);\n    return result;\n  }).pipe(\n    // This creates a child span\n    Effect.withSpan(\"validateInput\")\n  );\n\nconst saveToDatabase = (user: { email: string }) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Saving user to database: ${user.email}`);\n    yield* Effect.sleep(Duration.millis(50));\n    const result = { id: 123, ...user };\n    yield* Effect.logInfo(`‚úÖ User saved with ID: ${result.id}`);\n    return result;\n  }).pipe(\n    // This span includes useful attributes\n    Effect.withSpan(\"saveToDatabase\", {\n      attributes: { \"db.system\": \"postgresql\", \"db.user.email\": user.email },\n    })\n  );\n\nconst createUser = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"=== Creating User with Tracing ===\");\n    yield* Effect.logInfo(\n      \"This demonstrates how spans trace operations through the call stack\"\n    );\n\n    const validated = yield* validateInput(input);\n    const user = yield* saveToDatabase(validated);\n\n    yield* Effect.logInfo(\n      `‚úÖ User creation completed: ${JSON.stringify(user)}`\n    );\n    yield* Effect.logInfo(\n      \"Note: In production, spans would be sent to a tracing system like Jaeger or Zipkin\"\n    );\n\n    return user;\n  }).pipe(\n    // This is the parent span for the entire operation\n    Effect.withSpan(\"createUserOperation\")\n  );\n\n// Demonstrate the tracing functionality\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Trace Operations with Spans Demo ===\");\n\n  // Create multiple users to show tracing in action\n  const user1 = yield* createUser({ email: \"user1@example.com\" });\n\n  yield* Effect.logInfo(\"\\n--- Creating second user ---\");\n  const user2 = yield* createUser({ email: \"user2@example.com\" });\n\n  yield* Effect.logInfo(\"\\n=== Summary ===\");\n  yield* Effect.logInfo(\"Created users with tracing spans:\");\n  yield* Effect.logInfo(`User 1: ID ${user1.id}, Email: ${user1.email}`);\n  yield* Effect.logInfo(`User 2: ID ${user2.id}, Email: ${user2.email}`);\n});\n\n// When run with a tracing SDK, this will produce traces with root spans\n// \"createUserOperation\" and child spans: \"validateInput\" and \"saveToDatabase\".\nEffect.runPromise(program);\n\n```\n\n---\n\n## Anti-Pattern\n\nNot adding custom spans to your business logic. \nWithout them, your traces will only show high-level information from your framework (e.g., \"HTTP POST /users\"). \nYou will have no visibility into the performance of the individual steps *inside* your request handler, making it very difficult to pinpoint bottlenecks. Your application's logic remains a \"black box\" in your traces."
  },
  {
    "id": "observability-tracing-spans",
    "title": "Trace Operations Across Services with Spans",
    "description": "Use Effect.withSpan to create and annotate tracing spans for operations, enabling distributed tracing and performance analysis.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Trace a database query with a custom span\nconst fetchUser = Effect.sync(() => {\n  // ...fetch user from database\n  return { id: 1, name: \"Alice\" };\n}).pipe(Effect.withSpan(\"db.fetchUser\"));\n\n// Trace an HTTP request with additional attributes\nconst fetchData = Effect.tryPromise({\n  try: () => fetch(\"https://api.example.com/data\").then((res) => res.json()),\n  catch: (err) => `Network error: ${String(err)}`,\n}).pipe(\n  Effect.withSpan(\"http.fetchData\", {\n    attributes: { url: \"https://api.example.com/data\" },\n  })\n);\n\n// Use spans in a workflow\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Starting workflow\").pipe(\n    Effect.withSpan(\"workflow.start\")\n  );\n  const user = yield* fetchUser;\n  yield* Effect.log(`Fetched user: ${user.name}`).pipe(\n    Effect.withSpan(\"workflow.end\")\n  );\n});\n\n```\n\n**Explanation:**  \n- `Effect.withSpan` creates a tracing span around an operation.\n- Spans can be named and annotated with attributes for richer context.\n- Tracing enables distributed observability and performance analysis.",
    "antiPattern": "Relying only on logs or metrics for performance analysis, or lacking visibility into the flow of requests and operations across services.",
    "explanation": "Tracing spans help you understand the flow and timing of operations, especially in distributed systems or complex workflows.  \nThey allow you to pinpoint bottlenecks, visualize dependencies, and correlate logs and metrics with specific requests.",
    "content": "# Trace Operations Across Services with Spans\n\n## Guideline\n\nUse `Effect.withSpan` to create custom tracing spans around important operations in your application.  \nThis enables distributed tracing, performance analysis, and deep visibility into how requests flow through your system.\n\n## Rationale\n\nTracing spans help you understand the flow and timing of operations, especially in distributed systems or complex workflows.  \nThey allow you to pinpoint bottlenecks, visualize dependencies, and correlate logs and metrics with specific requests.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Trace a database query with a custom span\nconst fetchUser = Effect.sync(() => {\n  // ...fetch user from database\n  return { id: 1, name: \"Alice\" };\n}).pipe(Effect.withSpan(\"db.fetchUser\"));\n\n// Trace an HTTP request with additional attributes\nconst fetchData = Effect.tryPromise({\n  try: () => fetch(\"https://api.example.com/data\").then((res) => res.json()),\n  catch: (err) => `Network error: ${String(err)}`,\n}).pipe(\n  Effect.withSpan(\"http.fetchData\", {\n    attributes: { url: \"https://api.example.com/data\" },\n  })\n);\n\n// Use spans in a workflow\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Starting workflow\").pipe(\n    Effect.withSpan(\"workflow.start\")\n  );\n  const user = yield* fetchUser;\n  yield* Effect.log(`Fetched user: ${user.name}`).pipe(\n    Effect.withSpan(\"workflow.end\")\n  );\n});\n\n```\n\n**Explanation:**  \n- `Effect.withSpan` creates a tracing span around an operation.\n- Spans can be named and annotated with attributes for richer context.\n- Tracing enables distributed observability and performance analysis.\n\n## Anti-Pattern\n\nRelying only on logs or metrics for performance analysis, or lacking visibility into the flow of requests and operations across services."
  },
  {
    "id": "transform-data-with-schema",
    "title": "Transform Data During Validation with Schema",
    "description": "Use Schema.transform to safely convert data types during the validation and parsing process.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "This schema parses a string but produces a `Date` object, making the final data structure much more useful.\n\n```typescript\nimport { Schema, Effect } from \"effect\";\n\n// Define types for better type safety\ntype RawEvent = {\n  name: string;\n  timestamp: string;\n};\n\ntype ParsedEvent = {\n  name: string;\n  timestamp: Date;\n};\n\n// Define the schema for our event\nconst ApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String\n});\n\n// Example input\nconst rawInput: RawEvent = {\n  name: \"User Login\",\n  timestamp: \"2025-06-22T20:08:42.000Z\"\n};\n\n// Parse and transform\nconst program = Effect.gen(function* () {\n  const parsed = yield* Schema.decode(ApiEventSchema)(rawInput);\n  return {\n    name: parsed.name,\n    timestamp: new Date(parsed.timestamp)\n  } as ParsedEvent;\n});\n\nconst programWithLogging = Effect.gen(function* () {\n  try {\n    const event = yield* program;\n    yield* Effect.log(`Event year: ${event.timestamp.getFullYear()}`);\n    yield* Effect.log(`Full event: ${JSON.stringify(event, null, 2)}`);\n    return event;\n  } catch (error) {\n    yield* Effect.logError(`Failed to parse event: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n```\n\n\n`transformOrFail` is perfect for creating branded types, as the validation can fail.\n\n```typescript\nimport { Schema, Effect, Brand, Either } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\nconst Email = Schema.string.pipe(\n  Schema.transformOrFail(\n    Schema.brand<Email>(\"Email\"),\n    (s, _, ast) =>\n      s.includes(\"@\")\n        ? Either.right(s as Email)\n        : Either.left(Schema.ParseError.create(ast, \"Invalid email format\")),\n    (email) => Either.right(email),\n  ),\n);\n\nconst result = Schema.decode(Email)(\"paul@example.com\"); // Succeeds\nconst errorResult = Schema.decode(Email)(\"invalid-email\"); // Fails\n```\n\n---",
    "antiPattern": "Performing validation and transformation in two separate steps. This is more verbose, requires creating intermediate types, and separates the validation logic from the transformation logic.\n\n```typescript\nimport { Schema, Effect } from \"effect\";\n\n// ‚ùå WRONG: Requires an intermediate \"Raw\" type.\nconst RawApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String,\n});\n\nconst rawInput = { name: \"User Login\", timestamp: \"2025-06-22T20:08:42.000Z\" };\n\n// The logic is now split into two distinct, less cohesive steps.\nconst program = Schema.decode(RawApiEventSchema)(rawInput).pipe(\n  Effect.map((rawEvent) => ({\n    ...rawEvent,\n    timestamp: new Date(rawEvent.timestamp), // Manual transformation after parsing.\n  })),\n);\n```",
    "explanation": "Often, the data you receive from external sources (like an API) isn't in the ideal format for your application's domain model. For example, dates are sent as ISO strings, but you want to work with `Date` objects.\n\n`Schema.transform` integrates this conversion directly into the parsing step. It takes two functions: one to `decode` the input type into the domain type, and one to `encode` it back. This makes your schema the single source of truth for both the shape and the type transformation of your data.\n\nFor transformations that can fail (like creating a branded type), you can use `Schema.transformOrFail`, which allows the decoding step to return an `Either`.\n\n---",
    "content": "## Guideline\n\nTo convert data from one type to another as part of the validation process, use `Schema.transform`. This allows you to define a schema that parses an input type (e.g., `string`) and outputs a different, richer domain type (e.g., `Date`).\n\n---\n\n## Rationale\n\nOften, the data you receive from external sources (like an API) isn't in the ideal format for your application's domain model. For example, dates are sent as ISO strings, but you want to work with `Date` objects.\n\n`Schema.transform` integrates this conversion directly into the parsing step. It takes two functions: one to `decode` the input type into the domain type, and one to `encode` it back. This makes your schema the single source of truth for both the shape and the type transformation of your data.\n\nFor transformations that can fail (like creating a branded type), you can use `Schema.transformOrFail`, which allows the decoding step to return an `Either`.\n\n---\n\n## Good Example 1: Parsing a Date String\n\nThis schema parses a string but produces a `Date` object, making the final data structure much more useful.\n\n```typescript\nimport { Schema, Effect } from \"effect\";\n\n// Define types for better type safety\ntype RawEvent = {\n  name: string;\n  timestamp: string;\n};\n\ntype ParsedEvent = {\n  name: string;\n  timestamp: Date;\n};\n\n// Define the schema for our event\nconst ApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String\n});\n\n// Example input\nconst rawInput: RawEvent = {\n  name: \"User Login\",\n  timestamp: \"2025-06-22T20:08:42.000Z\"\n};\n\n// Parse and transform\nconst program = Effect.gen(function* () {\n  const parsed = yield* Schema.decode(ApiEventSchema)(rawInput);\n  return {\n    name: parsed.name,\n    timestamp: new Date(parsed.timestamp)\n  } as ParsedEvent;\n});\n\nconst programWithLogging = Effect.gen(function* () {\n  try {\n    const event = yield* program;\n    yield* Effect.log(`Event year: ${event.timestamp.getFullYear()}`);\n    yield* Effect.log(`Full event: ${JSON.stringify(event, null, 2)}`);\n    return event;\n  } catch (error) {\n    yield* Effect.logError(`Failed to parse event: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n```\n\n## Good Example 2: Creating a Branded Type\n\n`transformOrFail` is perfect for creating branded types, as the validation can fail.\n\n```typescript\nimport { Schema, Effect, Brand, Either } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\nconst Email = Schema.string.pipe(\n  Schema.transformOrFail(\n    Schema.brand<Email>(\"Email\"),\n    (s, _, ast) =>\n      s.includes(\"@\")\n        ? Either.right(s as Email)\n        : Either.left(Schema.ParseError.create(ast, \"Invalid email format\")),\n    (email) => Either.right(email),\n  ),\n);\n\nconst result = Schema.decode(Email)(\"paul@example.com\"); // Succeeds\nconst errorResult = Schema.decode(Email)(\"invalid-email\"); // Fails\n```\n\n---\n\n## Anti-Pattern\n\nPerforming validation and transformation in two separate steps. This is more verbose, requires creating intermediate types, and separates the validation logic from the transformation logic.\n\n```typescript\nimport { Schema, Effect } from \"effect\";\n\n// ‚ùå WRONG: Requires an intermediate \"Raw\" type.\nconst RawApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String,\n});\n\nconst rawInput = { name: \"User Login\", timestamp: \"2025-06-22T20:08:42.000Z\" };\n\n// The logic is now split into two distinct, less cohesive steps.\nconst program = Schema.decode(RawApiEventSchema)(rawInput).pipe(\n  Effect.map((rawEvent) => ({\n    ...rawEvent,\n    timestamp: new Date(rawEvent.timestamp), // Manual transformation after parsing.\n  })),\n);\n```"
  },
  {
    "id": "transform-effect-values",
    "title": "Transform Effect Values with map and flatMap",
    "description": "Transform Effect values with map and flatMap.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nconst getUser = (id: number): Effect.Effect<{ id: number; name: string }> =>\n  Effect.succeed({ id, name: \"Paul\" });\n\nconst getPosts = (userId: number): Effect.Effect<{ title: string }[]> =>\n  Effect.succeed([{ title: \"My First Post\" }, { title: \"Second Post\" }]);\n\nconst userPosts = getUser(123).pipe(\n  Effect.flatMap((user) => getPosts(user.id))\n);\n\n// Demonstrate transforming Effect values\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Transform Effect Values Demo ===\");\n\n  // 1. Basic transformation with map\n  yield* Effect.log(\"\\n1. Transform with map:\");\n  const userWithUpperName = yield* getUser(123).pipe(\n    Effect.map((user) => ({ ...user, name: user.name.toUpperCase() }))\n  );\n  yield* Effect.log(\"Transformed user:\", userWithUpperName);\n\n  // 2. Chain effects with flatMap\n  yield* Effect.log(\"\\n2. Chain effects with flatMap:\");\n  const posts = yield* userPosts;\n  yield* Effect.log(\"User posts:\", posts);\n\n  // 3. Transform and combine multiple effects\n  yield* Effect.log(\"\\n3. Transform and combine multiple effects:\");\n  const userWithPosts = yield* getUser(456).pipe(\n    Effect.flatMap((user) =>\n      getPosts(user.id).pipe(\n        Effect.map((posts) => ({\n          user: user.name,\n          postCount: posts.length,\n          titles: posts.map((p) => p.title),\n        }))\n      )\n    )\n  );\n  yield* Effect.log(\"User with posts:\", userWithPosts);\n\n  // 4. Transform with tap for side effects\n  yield* Effect.log(\"\\n4. Transform with tap for side effects:\");\n  const result = yield* getUser(789).pipe(\n    Effect.tap((user) => Effect.log(`Processing user: ${user.name}`)),\n    Effect.map((user) => `Hello, ${user.name}!`)\n  );\n  yield* Effect.log(\"Final result:\", result);\n\n  yield* Effect.log(\"\\n‚úÖ All transformations completed successfully!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \nUse `flatMap` to chain effects that depend on each other, and `map` for\nsimple value transformations.",
    "antiPattern": "Using `map` when you should be using `flatMap`. This results in a nested\n`Effect<Effect<...>>`, which is usually not what you want.",
    "explanation": "`Effect.map` is like `Array.prototype.map`. `Effect.flatMap` is like\n`Promise.prototype.then` and is used when your transformation function itself\nreturns an `Effect`.",
    "content": "# Transform Effect Values with map and flatMap\n\n## Guideline\n\nTo work with the success value of an `Effect`, use `Effect.map` for simple,\nsynchronous transformations and `Effect.flatMap` for effectful transformations.\n\n## Rationale\n\n`Effect.map` is like `Array.prototype.map`. `Effect.flatMap` is like\n`Promise.prototype.then` and is used when your transformation function itself\nreturns an `Effect`.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst getUser = (id: number): Effect.Effect<{ id: number; name: string }> =>\n  Effect.succeed({ id, name: \"Paul\" });\n\nconst getPosts = (userId: number): Effect.Effect<{ title: string }[]> =>\n  Effect.succeed([{ title: \"My First Post\" }, { title: \"Second Post\" }]);\n\nconst userPosts = getUser(123).pipe(\n  Effect.flatMap((user) => getPosts(user.id))\n);\n\n// Demonstrate transforming Effect values\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Transform Effect Values Demo ===\");\n\n  // 1. Basic transformation with map\n  yield* Effect.log(\"\\n1. Transform with map:\");\n  const userWithUpperName = yield* getUser(123).pipe(\n    Effect.map((user) => ({ ...user, name: user.name.toUpperCase() }))\n  );\n  yield* Effect.log(\"Transformed user:\", userWithUpperName);\n\n  // 2. Chain effects with flatMap\n  yield* Effect.log(\"\\n2. Chain effects with flatMap:\");\n  const posts = yield* userPosts;\n  yield* Effect.log(\"User posts:\", posts);\n\n  // 3. Transform and combine multiple effects\n  yield* Effect.log(\"\\n3. Transform and combine multiple effects:\");\n  const userWithPosts = yield* getUser(456).pipe(\n    Effect.flatMap((user) =>\n      getPosts(user.id).pipe(\n        Effect.map((posts) => ({\n          user: user.name,\n          postCount: posts.length,\n          titles: posts.map((p) => p.title),\n        }))\n      )\n    )\n  );\n  yield* Effect.log(\"User with posts:\", userWithPosts);\n\n  // 4. Transform with tap for side effects\n  yield* Effect.log(\"\\n4. Transform with tap for side effects:\");\n  const result = yield* getUser(789).pipe(\n    Effect.tap((user) => Effect.log(`Processing user: ${user.name}`)),\n    Effect.map((user) => `Hello, ${user.name}!`)\n  );\n  yield* Effect.log(\"Final result:\", result);\n\n  yield* Effect.log(\"\\n‚úÖ All transformations completed successfully!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \nUse `flatMap` to chain effects that depend on each other, and `map` for\nsimple value transformations.\n\n## Anti-Pattern\n\nUsing `map` when you should be using `flatMap`. This results in a nested\n`Effect<Effect<...>>`, which is usually not what you want."
  },
  {
    "id": "combinator-map",
    "title": "Transforming Values with map",
    "description": "Use map to apply a pure function to the value inside an Effect, Stream, Option, or Either.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Transform the result of an effect\nconst effect = Effect.succeed(2).pipe(\n  Effect.map((n) => n * 10)\n); // Effect<number>\n\n// Option: Transform an optional value\nconst option = Option.some(2).pipe(\n  Option.map((n) => n * 10)\n); // Option<number>\n\n// Either: Transform a value that may be an error\nconst either = Either.right(2).pipe(\n  Either.map((n) => n * 10)\n); // Either<never, number>\n\n// Stream: Transform every value in a stream\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(\n  Stream.map((n) => n * 10)\n); // Stream<number>\n```\n\n**Explanation:**  \nNo matter which type you use, `map` lets you apply a function to the value inside, without changing the error or context.",
    "antiPattern": "Manually extracting the value (e.g., with `.getOrElse`, `.unsafeRunSync`, or similar) just to transform it, then re-wrapping it.  \nThis breaks composability and loses the benefits of type safety and error handling.",
    "explanation": "`map` is the most fundamental combinator in functional programming.  \nIt allows you to focus on *what* you want to do with a value, not *how* to extract it.  \nThe same mental model applies across all major Effect types.",
    "content": "# Transforming Values with `map`\n\n## Guideline\n\nUse the `map` combinator to apply a pure function to the value inside an `Effect`, `Stream`, `Option`, or `Either`.  \nThis lets you transform results without changing the structure or error-handling behavior of the original type.\n\n## Rationale\n\n`map` is the most fundamental combinator in functional programming.  \nIt allows you to focus on *what* you want to do with a value, not *how* to extract it.  \nThe same mental model applies across all major Effect types.\n\n## Good Example\n\n```typescript\nimport { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Transform the result of an effect\nconst effect = Effect.succeed(2).pipe(\n  Effect.map((n) => n * 10)\n); // Effect<number>\n\n// Option: Transform an optional value\nconst option = Option.some(2).pipe(\n  Option.map((n) => n * 10)\n); // Option<number>\n\n// Either: Transform a value that may be an error\nconst either = Either.right(2).pipe(\n  Either.map((n) => n * 10)\n); // Either<never, number>\n\n// Stream: Transform every value in a stream\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(\n  Stream.map((n) => n * 10)\n); // Stream<number>\n```\n\n**Explanation:**  \nNo matter which type you use, `map` lets you apply a function to the value inside, without changing the error or context.\n\n## Anti-Pattern\n\nManually extracting the value (e.g., with `.getOrElse`, `.unsafeRunSync`, or similar) just to transform it, then re-wrapping it.  \nThis breaks composability and loses the benefits of type safety and error handling."
  },
  {
    "id": "stream-from-paginated-api",
    "title": "Turn a Paginated API into a Single Stream",
    "description": "Use Stream.paginateEffect to model a paginated data source as a single, continuous stream.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-data-pipelines"
    ],
    "example": "This example simulates fetching users from a paginated API. The `fetchUsersPage` function gets one page of data and returns the next page number. `Stream.paginateEffect` uses this function to create a single stream of all users across all pages.\n\n```typescript\nimport { Effect, Stream, Chunk, Option } from 'effect';\n\n// --- Mock Paginated API ---\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Define FetchError as a class with a literal type tag\nclass FetchError {\n  readonly _tag = 'FetchError' as const;\n  constructor(readonly message: string) {}\n}\n\n// Helper to create FetchError instances\nconst fetchError = (message: string): FetchError => new FetchError(message);\n\nconst allUsers: User[] = Array.from({ length: 25 }, (_, i) => ({\n  id: i + 1,\n  name: `User ${i + 1}`,\n}));\n\n// This function simulates fetching a page of users from an API.\nconst fetchUsersPage = (\n  page: number\n): Effect.Effect<[Chunk.Chunk<User>, Option.Option<number>], FetchError> =>\n  Effect.gen(function* () {\n    const pageSize = 10;\n    const offset = (page - 1) * pageSize;\n\n    // Simulate potential API errors\n    if (page < 1) {\n      return yield* Effect.fail(fetchError('Invalid page number'));\n    }\n\n    const users = Chunk.fromIterable(allUsers.slice(offset, offset + pageSize));\n\n    const nextPage =\n      Chunk.isNonEmpty(users) && allUsers.length > offset + pageSize\n        ? Option.some(page + 1)\n        : Option.none();\n\n    yield* Effect.log(`Fetched page ${page}`);\n    return [users, nextPage];\n  });\n\n// --- The Pattern ---\n// Use paginateEffect, providing an initial state (page 1) and the fetch function.\nconst userStream = Stream.paginateEffect(1, fetchUsersPage);\n\nconst program = userStream.pipe(\n  Stream.runCollect,\n  Effect.map((users) => users.length),\n  Effect.tap((totalUsers) => \n    Effect.log(`Total users fetched: ${totalUsers}`)\n  ),\n  Effect.catchTag('FetchError', (error) => \n    Effect.succeed(`Error fetching users: ${error.message}`)\n  )\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n\n/*\nOutput:\n... level=INFO msg=\"Fetched page 1\"\n... level=INFO msg=\"Fetched page 2\"\n... level=INFO msg=\"Fetched page 3\"\n... level=INFO msg=\"Total users fetched: 25\"\n25\n*/\n```",
    "antiPattern": "The anti-pattern is to write manual, imperative logic to handle the pagination loop. This code is stateful, harder to read, and not composable.\n\n```typescript\nimport { Effect, Chunk, Option } from 'effect';\n// ... same mock API setup ...\n\nconst fetchAllUsersManually = (): Effect.Effect<Chunk.Chunk<User>, Error> =>\n  Effect.gen(function* () {\n    // Manual state management for results and current page\n    let allFetchedUsers: User[] = [];\n    let currentPage: Option.Option<number> = Option.some(1);\n\n    // Manual loop to fetch pages\n    while (Option.isSome(currentPage)) {\n      const [users, nextPage] = yield* fetchUsersPage(currentPage.value);\n      allFetchedUsers = allFetchedUsers.concat(Chunk.toArray(users));\n      currentPage = nextPage;\n    }\n\n    return Chunk.fromIterable(allFetchedUsers);\n  });\n\nconst program = fetchAllUsersManually().pipe(\n  Effect.map((users) => users.length)\n);\n\nEffect.runPromise(program).then((totalUsers) => {\n  console.log(`Total users fetched from all pages: ${totalUsers}`);\n});\n```\n\nThis manual approach is inferior because it forces you to manage state explicitly (`allFetchedUsers`, `currentPage`). The logic is contained within a single, monolithic effect that is not lazy and cannot be easily composed with other stream operators without first collecting all results. `Stream.paginateEffect` abstracts away this entire block of boilerplate code.",
    "explanation": "Calling paginated APIs is a classic programming challenge. It often involves writing complex, stateful, and imperative code with manual loops to fetch one page, check if there's a next page, fetch that page, and so on, all while accumulating the results. This logic is tedious to write and easy to get wrong.\n\n`Stream.paginateEffect` elegantly solves this by declaratively modeling the pagination process:\n\n1.  **Declarative and Stateless**: You provide a function that knows how to fetch a single page, and the `Stream` handles the looping, state management (the current page token/number), and termination logic for you. Your business logic remains clean and stateless.\n2.  **Lazy and Efficient**: The stream fetches pages on demand as they are consumed. If a downstream consumer only needs the first 20 items, the stream will only make enough API calls to satisfy that need, rather than wastefully fetching all pages upfront.\n3.  **Fully Composable**: The result is a standard `Stream`. This means you can pipe the continuous flow of items directly into other powerful operators like `mapEffect` for concurrent processing or `grouped` for batching, without ever thinking about page boundaries again.\n\n---",
    "content": "## Guideline\n\nTo handle a data source that is split across multiple pages, use `Stream.paginateEffect` to abstract the pagination logic into a single, continuous `Stream`.\n\n---\n\n## Rationale\n\nCalling paginated APIs is a classic programming challenge. It often involves writing complex, stateful, and imperative code with manual loops to fetch one page, check if there's a next page, fetch that page, and so on, all while accumulating the results. This logic is tedious to write and easy to get wrong.\n\n`Stream.paginateEffect` elegantly solves this by declaratively modeling the pagination process:\n\n1.  **Declarative and Stateless**: You provide a function that knows how to fetch a single page, and the `Stream` handles the looping, state management (the current page token/number), and termination logic for you. Your business logic remains clean and stateless.\n2.  **Lazy and Efficient**: The stream fetches pages on demand as they are consumed. If a downstream consumer only needs the first 20 items, the stream will only make enough API calls to satisfy that need, rather than wastefully fetching all pages upfront.\n3.  **Fully Composable**: The result is a standard `Stream`. This means you can pipe the continuous flow of items directly into other powerful operators like `mapEffect` for concurrent processing or `grouped` for batching, without ever thinking about page boundaries again.\n\n---\n\n## Good Example\n\nThis example simulates fetching users from a paginated API. The `fetchUsersPage` function gets one page of data and returns the next page number. `Stream.paginateEffect` uses this function to create a single stream of all users across all pages.\n\n```typescript\nimport { Effect, Stream, Chunk, Option } from 'effect';\n\n// --- Mock Paginated API ---\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Define FetchError as a class with a literal type tag\nclass FetchError {\n  readonly _tag = 'FetchError' as const;\n  constructor(readonly message: string) {}\n}\n\n// Helper to create FetchError instances\nconst fetchError = (message: string): FetchError => new FetchError(message);\n\nconst allUsers: User[] = Array.from({ length: 25 }, (_, i) => ({\n  id: i + 1,\n  name: `User ${i + 1}`,\n}));\n\n// This function simulates fetching a page of users from an API.\nconst fetchUsersPage = (\n  page: number\n): Effect.Effect<[Chunk.Chunk<User>, Option.Option<number>], FetchError> =>\n  Effect.gen(function* () {\n    const pageSize = 10;\n    const offset = (page - 1) * pageSize;\n\n    // Simulate potential API errors\n    if (page < 1) {\n      return yield* Effect.fail(fetchError('Invalid page number'));\n    }\n\n    const users = Chunk.fromIterable(allUsers.slice(offset, offset + pageSize));\n\n    const nextPage =\n      Chunk.isNonEmpty(users) && allUsers.length > offset + pageSize\n        ? Option.some(page + 1)\n        : Option.none();\n\n    yield* Effect.log(`Fetched page ${page}`);\n    return [users, nextPage];\n  });\n\n// --- The Pattern ---\n// Use paginateEffect, providing an initial state (page 1) and the fetch function.\nconst userStream = Stream.paginateEffect(1, fetchUsersPage);\n\nconst program = userStream.pipe(\n  Stream.runCollect,\n  Effect.map((users) => users.length),\n  Effect.tap((totalUsers) => \n    Effect.log(`Total users fetched: ${totalUsers}`)\n  ),\n  Effect.catchTag('FetchError', (error) => \n    Effect.succeed(`Error fetching users: ${error.message}`)\n  )\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n\n/*\nOutput:\n... level=INFO msg=\"Fetched page 1\"\n... level=INFO msg=\"Fetched page 2\"\n... level=INFO msg=\"Fetched page 3\"\n... level=INFO msg=\"Total users fetched: 25\"\n25\n*/\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to write manual, imperative logic to handle the pagination loop. This code is stateful, harder to read, and not composable.\n\n```typescript\nimport { Effect, Chunk, Option } from 'effect';\n// ... same mock API setup ...\n\nconst fetchAllUsersManually = (): Effect.Effect<Chunk.Chunk<User>, Error> =>\n  Effect.gen(function* () {\n    // Manual state management for results and current page\n    let allFetchedUsers: User[] = [];\n    let currentPage: Option.Option<number> = Option.some(1);\n\n    // Manual loop to fetch pages\n    while (Option.isSome(currentPage)) {\n      const [users, nextPage] = yield* fetchUsersPage(currentPage.value);\n      allFetchedUsers = allFetchedUsers.concat(Chunk.toArray(users));\n      currentPage = nextPage;\n    }\n\n    return Chunk.fromIterable(allFetchedUsers);\n  });\n\nconst program = fetchAllUsersManually().pipe(\n  Effect.map((users) => users.length)\n);\n\nEffect.runPromise(program).then((totalUsers) => {\n  console.log(`Total users fetched from all pages: ${totalUsers}`);\n});\n```\n\nThis manual approach is inferior because it forces you to manage state explicitly (`allFetchedUsers`, `currentPage`). The logic is contained within a single, monolithic effect that is not lazy and cannot be easily composed with other stream operators without first collecting all results. `Stream.paginateEffect` abstracts away this entire block of boilerplate code."
  },
  {
    "id": "data-class",
    "title": "Type Classes for Equality, Ordering, and Hashing with Data.Class",
    "description": "Use Data.Class to define and derive type classes for your data types, supporting composable equality, ordering, and hashing.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data, Equal, HashSet } from \"effect\";\n\n// Define custom data types with structural equality\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\nconst user3 = Data.struct({ id: 2, name: \"Bob\" });\n\n// Data.struct provides automatic structural equality\nconsole.log(Equal.equals(user1, user2)); // true (same structure)\nconsole.log(Equal.equals(user1, user3)); // false (different values)\n\n// Use in a HashSet (works because Data.struct implements Equal)\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true (structural equality)\n\n// Create an array and use structural equality\nconst users = [user1, user3];\nconsole.log(users.some((u) => Equal.equals(u, user2))); // true\n\n```\n\n**Explanation:**  \n- `Data.Class.getEqual` derives an equality type class for your data type.\n- `Data.Class.getOrder` derives an ordering type class, useful for sorting.\n- `Data.Class.getHash` derives a hash function for use in sets and maps.\n- These type classes make your types fully compatible with Effect‚Äôs collections and algorithms.",
    "antiPattern": "Relying on reference equality, ad-hoc comparison functions, or not providing type class instances for your custom types, which can lead to bugs and inconsistent behavior in collections.",
    "explanation": "Type classes like `Equal`, `Order`, and `Hash` provide a principled way to define how your types are compared, ordered, and hashed.  \nThis is essential for using your types in sets, maps, and for sorting or deduplication.",
    "content": "# Type Classes for Equality, Ordering, and Hashing with `Data.Class`\n\n## Guideline\n\nUse `Data.Class` to derive or implement type classes for equality, ordering, and hashing for your custom data types.  \nThis enables composable, type-safe abstractions and allows your types to work seamlessly with Effect‚Äôs collections and algorithms.\n\n## Rationale\n\nType classes like `Equal`, `Order`, and `Hash` provide a principled way to define how your types are compared, ordered, and hashed.  \nThis is essential for using your types in sets, maps, and for sorting or deduplication.\n\n## Good Example\n\n```typescript\nimport { Data, Equal, HashSet } from \"effect\";\n\n// Define custom data types with structural equality\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\nconst user3 = Data.struct({ id: 2, name: \"Bob\" });\n\n// Data.struct provides automatic structural equality\nconsole.log(Equal.equals(user1, user2)); // true (same structure)\nconsole.log(Equal.equals(user1, user3)); // false (different values)\n\n// Use in a HashSet (works because Data.struct implements Equal)\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true (structural equality)\n\n// Create an array and use structural equality\nconst users = [user1, user3];\nconsole.log(users.some((u) => Equal.equals(u, user2))); // true\n\n```\n\n**Explanation:**  \n- `Data.Class.getEqual` derives an equality type class for your data type.\n- `Data.Class.getOrder` derives an ordering type class, useful for sorting.\n- `Data.Class.getHash` derives a hash function for use in sets and maps.\n- These type classes make your types fully compatible with Effect‚Äôs collections and algorithms.\n\n## Anti-Pattern\n\nRelying on reference equality, ad-hoc comparison functions, or not providing type class instances for your custom types, which can lead to bugs and inconsistent behavior in collections."
  },
  {
    "id": "understand-fibers-as-lightweight-threads",
    "title": "Understand Fibers as Lightweight Threads",
    "description": "Understand that a Fiber is a lightweight, virtual thread managed by the Effect runtime for massive concurrency.",
    "skillLevel": "advanced",
    "useCases": [
      "concurrency"
    ],
    "example": "This program demonstrates the efficiency of fibers by forking 100,000 of them. Each fiber does a small amount of work (sleeping for 1 second). Trying to do this with 100,000 OS threads would instantly crash any system.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Demonstrate the lightweight nature of fibers by creating 100,000 of them\n  // This would be impossible with OS threads due to memory and context switching overhead\n  const fiberCount = 100_000;\n  yield* Effect.log(`Forking ${fiberCount} fibers...`);\n\n  // Create an array of 100,000 simple effects\n  // Each effect sleeps for 1 second and then returns its index\n  // This simulates lightweight concurrent tasks\n  const tasks = Array.from({ length: fiberCount }, (_, i) =>\n    Effect.sleep(\"1 second\").pipe(Effect.as(i))\n  );\n\n  // Fork all of them into background fibers\n  // Effect.fork creates a new fiber for each task without blocking\n  // This demonstrates fiber creation scalability - 100k fibers created almost instantly\n  // Each fiber is much lighter than an OS thread (typically ~1KB vs ~8MB per thread)\n  const fibers = yield* Effect.forEach(tasks, Effect.fork);\n\n  yield* Effect.log(\n    \"All fibers have been forked. Now waiting for them to complete...\"\n  );\n\n  // Wait for all fibers to finish their work\n  // Fiber.joinAll waits for all fibers to complete and collects their results\n  // This demonstrates fiber coordination - managing thousands of concurrent operations\n  // The runtime efficiently schedules these fibers using a work-stealing thread pool\n  const results = yield* Fiber.joinAll(fibers);\n\n  yield* Effect.log(`All ${results.length} fibers have completed.`);\n\n  // Key insights from this example:\n  // 1. Fibers are extremely lightweight - 100k fibers use minimal memory\n  // 2. Fiber creation is fast - no expensive OS thread allocation\n  // 3. The Effect runtime efficiently schedules fibers across available CPU cores\n  // 4. Fibers can be suspended and resumed without blocking OS threads\n  // 5. This enables massive concurrency for I/O-bound operations\n});\n\n// This program runs successfully, demonstrating the low overhead of fibers.\n// Try running this with OS threads - you'd likely hit system limits around 1000-10000 threads\n// With fibers, 100k+ concurrent operations are easily achievable\nEffect.runPromise(program);\n\n```\n\n---",
    "antiPattern": "The anti-pattern is thinking that a `Fiber` is the same as an OS thread. This can lead to incorrect assumptions about performance and behavior.\n\n-   **Don't assume parallelism on CPU-bound tasks:** In a standard Node.js environment, all fibers run on a single OS thread. If you run 10 CPU-intensive tasks on 10 fibers, they will not run in parallel on 10 different CPU cores. They will share time on the single main thread. Fibers provide massive concurrency for I/O-bound tasks (like network requests), not CPU-bound parallelism.\n-   **Don't worry about blocking:** A `Fiber` that is \"sleeping\" or waiting for I/O (like `Effect.sleep` or a `fetch` request) does not block the underlying OS thread. The Effect runtime simply puts it aside and uses the thread to run other ready fibers.",
    "explanation": "In traditional multi-threaded programming, each thread is managed by the operating system, consumes significant memory (for its stack), and involves expensive context switching. This limits the number of concurrent threads you can realistically create.\n\nEffect's `Fiber`s are different. They are managed entirely by the Effect runtime, not the OS. They are incredibly lightweight data structures that don't have their own OS thread stack. The Effect runtime uses a cooperative scheduling mechanism to run many fibers on a small pool of OS threads (often just one in Node.js).\n\nThis model, known as M:N threading (M fibers on N OS threads), allows for a massive level of concurrency that is impossible with traditional threads. It's what makes Effect so powerful for building highly concurrent applications like servers, data pipelines, and real-time systems.\n\nWhen you use operators like `Effect.fork` or `Effect.all`, you are creating new fibers.\n\n---",
    "content": "## Guideline\n\nThink of a `Fiber` as a \"virtual thread\" or a \"green thread.\" It is the fundamental unit of concurrency in Effect. Every `Effect` you run is executed on a `Fiber`. Unlike OS threads, which are heavy and limited, you can create hundreds of thousands or even millions of fibers without issue.\n\n---\n\n## Rationale\n\nIn traditional multi-threaded programming, each thread is managed by the operating system, consumes significant memory (for its stack), and involves expensive context switching. This limits the number of concurrent threads you can realistically create.\n\nEffect's `Fiber`s are different. They are managed entirely by the Effect runtime, not the OS. They are incredibly lightweight data structures that don't have their own OS thread stack. The Effect runtime uses a cooperative scheduling mechanism to run many fibers on a small pool of OS threads (often just one in Node.js).\n\nThis model, known as M:N threading (M fibers on N OS threads), allows for a massive level of concurrency that is impossible with traditional threads. It's what makes Effect so powerful for building highly concurrent applications like servers, data pipelines, and real-time systems.\n\nWhen you use operators like `Effect.fork` or `Effect.all`, you are creating new fibers.\n\n---\n\n## Good Example\n\nThis program demonstrates the efficiency of fibers by forking 100,000 of them. Each fiber does a small amount of work (sleeping for 1 second). Trying to do this with 100,000 OS threads would instantly crash any system.\n\n```typescript\nimport { Effect, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Demonstrate the lightweight nature of fibers by creating 100,000 of them\n  // This would be impossible with OS threads due to memory and context switching overhead\n  const fiberCount = 100_000;\n  yield* Effect.log(`Forking ${fiberCount} fibers...`);\n\n  // Create an array of 100,000 simple effects\n  // Each effect sleeps for 1 second and then returns its index\n  // This simulates lightweight concurrent tasks\n  const tasks = Array.from({ length: fiberCount }, (_, i) =>\n    Effect.sleep(\"1 second\").pipe(Effect.as(i))\n  );\n\n  // Fork all of them into background fibers\n  // Effect.fork creates a new fiber for each task without blocking\n  // This demonstrates fiber creation scalability - 100k fibers created almost instantly\n  // Each fiber is much lighter than an OS thread (typically ~1KB vs ~8MB per thread)\n  const fibers = yield* Effect.forEach(tasks, Effect.fork);\n\n  yield* Effect.log(\n    \"All fibers have been forked. Now waiting for them to complete...\"\n  );\n\n  // Wait for all fibers to finish their work\n  // Fiber.joinAll waits for all fibers to complete and collects their results\n  // This demonstrates fiber coordination - managing thousands of concurrent operations\n  // The runtime efficiently schedules these fibers using a work-stealing thread pool\n  const results = yield* Fiber.joinAll(fibers);\n\n  yield* Effect.log(`All ${results.length} fibers have completed.`);\n\n  // Key insights from this example:\n  // 1. Fibers are extremely lightweight - 100k fibers use minimal memory\n  // 2. Fiber creation is fast - no expensive OS thread allocation\n  // 3. The Effect runtime efficiently schedules fibers across available CPU cores\n  // 4. Fibers can be suspended and resumed without blocking OS threads\n  // 5. This enables massive concurrency for I/O-bound operations\n});\n\n// This program runs successfully, demonstrating the low overhead of fibers.\n// Try running this with OS threads - you'd likely hit system limits around 1000-10000 threads\n// With fibers, 100k+ concurrent operations are easily achievable\nEffect.runPromise(program);\n\n```\n\n---\n\n## Anti-Pattern: Mental Model Mismatch\n\nThe anti-pattern is thinking that a `Fiber` is the same as an OS thread. This can lead to incorrect assumptions about performance and behavior.\n\n-   **Don't assume parallelism on CPU-bound tasks:** In a standard Node.js environment, all fibers run on a single OS thread. If you run 10 CPU-intensive tasks on 10 fibers, they will not run in parallel on 10 different CPU cores. They will share time on the single main thread. Fibers provide massive concurrency for I/O-bound tasks (like network requests), not CPU-bound parallelism.\n-   **Don't worry about blocking:** A `Fiber` that is \"sleeping\" or waiting for I/O (like `Effect.sleep` or a `fetch` request) does not block the underlying OS thread. The Effect runtime simply puts it aside and uses the thread to run other ready fibers."
  },
  {
    "id": "understand-layers-for-dependency-injection",
    "title": "Understand Layers for Dependency Injection",
    "description": "Understand that a Layer is a blueprint describing how to construct a service and its dependencies.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "Here, we define a `Notifier` service that requires a `Logger` to be built. The `NotifierLive` layer's type signature, `Layer<Logger, never, Notifier>`, clearly documents this dependency.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define the Logger service with a default implementation\nexport class Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    // Provide a synchronous implementation\n    sync: () => ({\n      log: (msg: string) => Effect.log(`LOG: ${msg}`)\n    })\n  }\n) {}\n\n// Define the Notifier service that depends on Logger\nexport class Notifier extends Effect.Service<Notifier>()(\n  \"Notifier\",\n  {\n    // Provide an implementation that requires Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        notify: (msg: string) => logger.log(`Notifying: ${msg}`)\n      };\n    }),\n    // Specify dependencies\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Create a program that uses both services\nconst program = Effect.gen(function* () {\n  const notifier = yield* Notifier;\n  yield* notifier.notify(\"Hello, World!\");\n});\n\n// Run the program with the default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Notifier.Default\n  )\n);\n```\n\n---",
    "antiPattern": "Manually creating and passing service instances around. This is the \"poor man's DI\" and leads to tightly coupled code that is difficult to test and maintain.\n\n```typescript\n// ‚ùå WRONG: Manual instantiation and prop-drilling.\nclass LoggerImpl {\n  log(msg: string) { console.log(msg); }\n}\n\nclass NotifierImpl {\n  constructor(private logger: LoggerImpl) {}\n  notify(msg: string) { this.logger.log(msg); }\n}\n\n// Dependencies must be created and passed in manually.\nconst logger = new LoggerImpl();\nconst notifier = new NotifierImpl(logger);\n\n// This is not easily testable without creating real instances.\nnotifier.notify(\"Hello\");\n```",
    "explanation": "In Effect, you don't create service instances directly. Instead, you define `Layer`s that describe *how* to create them. This separation of declaration from implementation is the core of Effect's powerful dependency injection (DI) system.\n\nThis approach has several key benefits:\n-   **Composability:** You can combine small, focused layers into a complete application layer (`Layer.merge`, `Layer.provide`).\n-   **Declarative Dependencies:** A layer's type signature explicitly documents its own dependencies, making your application's architecture clear and self-documenting.\n-   **Testability:** For testing, you can easily swap a \"live\" layer (e.g., one that connects to a real database) with a \"test\" layer (one that provides mock data) without changing any of your business logic.\n\n---",
    "content": "## Guideline\n\nThink of a `Layer<R, E, A>` as a recipe for building a service. It's a declarative blueprint that specifies:\n-   **`A` (Output)**: The service it provides (e.g., `HttpClient`).\n-   **`R` (Requirements)**: The other services it needs to be built (e.g., `ConfigService`).\n-   **`E` (Error)**: The errors that could occur during its construction (e.g., `ConfigError`).\n\n---\n\n## Rationale\n\nIn Effect, you don't create service instances directly. Instead, you define `Layer`s that describe *how* to create them. This separation of declaration from implementation is the core of Effect's powerful dependency injection (DI) system.\n\nThis approach has several key benefits:\n-   **Composability:** You can combine small, focused layers into a complete application layer (`Layer.merge`, `Layer.provide`).\n-   **Declarative Dependencies:** A layer's type signature explicitly documents its own dependencies, making your application's architecture clear and self-documenting.\n-   **Testability:** For testing, you can easily swap a \"live\" layer (e.g., one that connects to a real database) with a \"test\" layer (one that provides mock data) without changing any of your business logic.\n\n---\n\n## Good Example\n\nHere, we define a `Notifier` service that requires a `Logger` to be built. The `NotifierLive` layer's type signature, `Layer<Logger, never, Notifier>`, clearly documents this dependency.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define the Logger service with a default implementation\nexport class Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    // Provide a synchronous implementation\n    sync: () => ({\n      log: (msg: string) => Effect.log(`LOG: ${msg}`)\n    })\n  }\n) {}\n\n// Define the Notifier service that depends on Logger\nexport class Notifier extends Effect.Service<Notifier>()(\n  \"Notifier\",\n  {\n    // Provide an implementation that requires Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        notify: (msg: string) => logger.log(`Notifying: ${msg}`)\n      };\n    }),\n    // Specify dependencies\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Create a program that uses both services\nconst program = Effect.gen(function* () {\n  const notifier = yield* Notifier;\n  yield* notifier.notify(\"Hello, World!\");\n});\n\n// Run the program with the default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Notifier.Default\n  )\n);\n```\n\n---\n\n## Anti-Pattern\n\nManually creating and passing service instances around. This is the \"poor man's DI\" and leads to tightly coupled code that is difficult to test and maintain.\n\n```typescript\n// ‚ùå WRONG: Manual instantiation and prop-drilling.\nclass LoggerImpl {\n  log(msg: string) { console.log(msg); }\n}\n\nclass NotifierImpl {\n  constructor(private logger: LoggerImpl) {}\n  notify(msg: string) { this.logger.log(msg); }\n}\n\n// Dependencies must be created and passed in manually.\nconst logger = new LoggerImpl();\nconst notifier = new NotifierImpl(logger);\n\n// This is not easily testable without creating real instances.\nnotifier.notify(\"Hello\");\n```"
  },
  {
    "id": "effects-are-lazy",
    "title": "Understand that Effects are Lazy Blueprints",
    "description": "Understand that effects are lazy blueprints.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nEffect.runSync(Effect.log(\"1. Defining the Effect blueprint...\"));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"3. The blueprint is now being executed!\");\n  return 42;\n});\n\nconst demonstrationProgram = Effect.gen(function* () {\n  yield* Effect.log(\"2. The blueprint has been defined. No work has been done yet.\");\n  yield* program;\n});\n\nEffect.runSync(demonstrationProgram);\n```\n\n**Explanation:**  \nDefining an `Effect` does not execute any code inside it. Only when you call\n`Effect.runSync(program)` does the computation actually happen.",
    "antiPattern": "Assuming an `Effect` behaves like a `Promise`. A `Promise` executes its work\nimmediately upon creation. Never expect a side effect to occur just from\ndefining an `Effect`.",
    "explanation": "This laziness is a superpower because it makes your code composable,\npredictable, and testable. Unlike a `Promise` which executes immediately,\nan `Effect` is just a description of work, like a recipe waiting for a chef.",
    "content": "# Understand that Effects are Lazy Blueprints\n\n## Guideline\n\nAn `Effect` is not a value or a `Promise`. It is a lazy, immutable blueprint\nthat describes a computation. It does nothing on its own until it is passed to\na runtime executor (e.g., `Effect.runPromise` or `Effect.runSync`).\n\n## Rationale\n\nThis laziness is a superpower because it makes your code composable,\npredictable, and testable. Unlike a `Promise` which executes immediately,\nan `Effect` is just a description of work, like a recipe waiting for a chef.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nEffect.runSync(Effect.log(\"1. Defining the Effect blueprint...\"));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"3. The blueprint is now being executed!\");\n  return 42;\n});\n\nconst demonstrationProgram = Effect.gen(function* () {\n  yield* Effect.log(\"2. The blueprint has been defined. No work has been done yet.\");\n  yield* program;\n});\n\nEffect.runSync(demonstrationProgram);\n```\n\n**Explanation:**  \nDefining an `Effect` does not execute any code inside it. Only when you call\n`Effect.runSync(program)` does the computation actually happen.\n\n## Anti-Pattern\n\nAssuming an `Effect` behaves like a `Promise`. A `Promise` executes its work\nimmediately upon creation. Never expect a side effect to occur just from\ndefining an `Effect`."
  },
  {
    "id": "understand-effect-channels",
    "title": "Understand the Three Effect Channels (A, E, R)",
    "description": "Understand that an Effect&lt;A, E, R&gt; describes a computation with a success type (A), an error type (E), and a requirements type (R).",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "This function signature is a self-documenting contract. It clearly states that to get a `User`, you must provide a `Database` service, and the operation might fail with a `UserNotFoundError`.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define the types for our channels\ninterface User { readonly name: string; } // The 'A' type\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\") {} // The 'E' type\n\n// Define the Database service using Effect.Service\nexport class Database extends Effect.Service<Database>()(\n  \"Database\",\n  {\n    // Provide a default implementation\n    sync: () => ({\n      findUser: (id: number) =>\n        id === 1\n          ? Effect.succeed({ name: \"Paul\" })\n          : Effect.fail(new UserNotFoundError())\n    })\n  }\n) {}\n\n// This function's signature shows all three channels\nconst getUser = (id: number): Effect.Effect<User, UserNotFoundError, Database> =>\n  Effect.gen(function* () {\n    const db = yield* Database;\n    return yield* db.findUser(id);\n  });\n\n// The program will use the default implementation\nconst program = getUser(1);\n\n// Run the program with the default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* Effect.provide(program, Database.Default);\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`); // { name: 'Paul' }\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---",
    "antiPattern": "Ignoring the type system and using generic types. This throws away all the safety and clarity that Effect provides.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This signature is dishonest and unsafe.\n// It hides the dependency on a database and the possibility of failure.\nfunction getUserUnsafely(id: number, db: any): Effect.Effect<any> {\n  try {\n    const user = db.findUser(id);\n    if (!user) {\n      // This will be an unhandled defect, not a typed error.\n      throw new Error(\"User not found\");\n    }\n    return Effect.succeed(user);\n  } catch (e) {\n    // This is also an untyped failure.\n    return Effect.fail(e);\n  }\n}\n```",
    "explanation": "This three-channel signature is what makes Effect so expressive and safe. Unlike a ``Promise<A>`` which can only describe its success type, an ``Effect``'s signature tells you everything you need to know about a computation before you run it:\n1.  **What it produces (`A`):** The data you get on the \"happy path.\"\n2.  **How it can fail (`E`):** The specific, known errors you need to handle. This makes error handling type-safe and explicit, unlike throwing generic `Error`s.\n3.  **What it needs (`R`):** The \"ingredients\" or dependencies required to run the effect. This is the foundation of Effect's powerful dependency injection system. An `Effect` can only be executed when its `R` channel is `never`, meaning all its dependencies have been provided.\n\nThis turns the TypeScript compiler into a powerful assistant that ensures you've handled all possible outcomes and provided all necessary dependencies.\n\n---",
    "content": "## Guideline\n\nEvery `Effect` has three generic type parameters: ``Effect<A, E, R>`` which represent its three \"channels\":\n-   **`A` (Success Channel):** The type of value the `Effect` will produce if it succeeds.\n-   **`E` (Error/Failure Channel):** The type of error the `Effect` can fail with. These are expected, recoverable errors.\n-   **`R` (Requirement/Context Channel):** The services or dependencies the `Effect` needs to run.\n\n---\n\n## Rationale\n\nThis three-channel signature is what makes Effect so expressive and safe. Unlike a ``Promise<A>`` which can only describe its success type, an ``Effect``'s signature tells you everything you need to know about a computation before you run it:\n1.  **What it produces (`A`):** The data you get on the \"happy path.\"\n2.  **How it can fail (`E`):** The specific, known errors you need to handle. This makes error handling type-safe and explicit, unlike throwing generic `Error`s.\n3.  **What it needs (`R`):** The \"ingredients\" or dependencies required to run the effect. This is the foundation of Effect's powerful dependency injection system. An `Effect` can only be executed when its `R` channel is `never`, meaning all its dependencies have been provided.\n\nThis turns the TypeScript compiler into a powerful assistant that ensures you've handled all possible outcomes and provided all necessary dependencies.\n\n---\n\n## Good Example\n\nThis function signature is a self-documenting contract. It clearly states that to get a `User`, you must provide a `Database` service, and the operation might fail with a `UserNotFoundError`.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define the types for our channels\ninterface User { readonly name: string; } // The 'A' type\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\") {} // The 'E' type\n\n// Define the Database service using Effect.Service\nexport class Database extends Effect.Service<Database>()(\n  \"Database\",\n  {\n    // Provide a default implementation\n    sync: () => ({\n      findUser: (id: number) =>\n        id === 1\n          ? Effect.succeed({ name: \"Paul\" })\n          : Effect.fail(new UserNotFoundError())\n    })\n  }\n) {}\n\n// This function's signature shows all three channels\nconst getUser = (id: number): Effect.Effect<User, UserNotFoundError, Database> =>\n  Effect.gen(function* () {\n    const db = yield* Database;\n    return yield* db.findUser(id);\n  });\n\n// The program will use the default implementation\nconst program = getUser(1);\n\n// Run the program with the default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* Effect.provide(program, Database.Default);\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`); // { name: 'Paul' }\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n```\n\n---\n\n## Anti-Pattern\n\nIgnoring the type system and using generic types. This throws away all the safety and clarity that Effect provides.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// ‚ùå WRONG: This signature is dishonest and unsafe.\n// It hides the dependency on a database and the possibility of failure.\nfunction getUserUnsafely(id: number, db: any): Effect.Effect<any> {\n  try {\n    const user = db.findUser(id);\n    if (!user) {\n      // This will be an unhandled defect, not a typed error.\n      throw new Error(\"User not found\");\n    }\n    return Effect.succeed(user);\n  } catch (e) {\n    // This is also an untyped failure.\n    return Effect.fail(e);\n  }\n}\n```"
  },
  {
    "id": "use-pipe-for-composition",
    "title": "Use .pipe for Composition",
    "description": "Use .pipe for composition.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.succeed(5).pipe(\n  Effect.map((n) => n * 2),\n  Effect.map((n) => `The result is ${n}`),\n  Effect.tap(Effect.log)\n);\n\n// Demonstrate various pipe composition patterns\nconst demo = Effect.gen(function* () {\n  yield* Effect.log(\"=== Using Pipe for Composition Demo ===\");\n\n  // 1. Basic pipe composition\n  yield* Effect.log(\"\\n1. Basic pipe composition:\");\n  yield* program;\n\n  // 2. Complex pipe composition with multiple transformations\n  yield* Effect.log(\"\\n2. Complex pipe composition:\");\n  const complexResult = yield* Effect.succeed(10).pipe(\n    Effect.map((n) => n + 5),\n    Effect.map((n) => n * 2),\n    Effect.tap((n) => Effect.log(`Intermediate result: ${n}`)),\n    Effect.map((n) => n.toString()),\n    Effect.map((s) => `Final: ${s}`)\n  );\n  yield* Effect.log(\"Complex result: \" + complexResult);\n\n  // 3. Pipe with flatMap for chaining effects\n  yield* Effect.log(\"\\n3. Pipe with flatMap for chaining effects:\");\n  const chainedResult = yield* Effect.succeed(\"hello\").pipe(\n    Effect.map((s) => s.toUpperCase()),\n    Effect.flatMap((s) => Effect.succeed(`${s} WORLD`)),\n    Effect.flatMap((s) => Effect.succeed(`${s}!`)),\n    Effect.tap((s) => Effect.log(`Chained: ${s}`))\n  );\n  yield* Effect.log(\"Chained result: \" + chainedResult);\n\n  // 4. Pipe with error handling\n  yield* Effect.log(\"\\n4. Pipe with error handling:\");\n  const errorHandledResult = yield* Effect.succeed(-1).pipe(\n    Effect.flatMap((n) =>\n      n > 0 ? Effect.succeed(n) : Effect.fail(new Error(\"Negative number\"))\n    ),\n    Effect.catchAll((error) =>\n      Effect.succeed(\"Handled error: \" + error.message)\n    ),\n    Effect.tap((result) => Effect.log(`Error handled: ${result}`))\n  );\n  yield* Effect.log(\"Error handled result: \" + errorHandledResult);\n\n  // 5. Pipe with multiple operations\n  yield* Effect.log(\"\\n5. Pipe with multiple operations:\");\n  const multiOpResult = yield* Effect.succeed([1, 2, 3, 4, 5]).pipe(\n    Effect.map((arr) => arr.filter((n) => n % 2 === 0)),\n    Effect.map((arr) => arr.map((n) => n * 2)),\n    Effect.map((arr) => arr.reduce((sum, n) => sum + n, 0)),\n    Effect.tap((sum) => Effect.log(`Sum of even numbers doubled: ${sum}`))\n  );\n  yield* Effect.log(\"Multi-operation result: \" + multiOpResult);\n\n  yield* Effect.log(\"\\n‚úÖ Pipe composition demonstration completed!\");\n});\n\nEffect.runPromise(demo);\n\n```\n\n**Explanation:**  \nUsing `.pipe()` allows you to compose operations in a top-to-bottom style,\nimproving readability and maintainability.",
    "antiPattern": "Nesting function calls manually. This is hard to read and reorder.\n`Effect.tap(Effect.map(Effect.map(Effect.succeed(5), n => n * 2), n => ...))`",
    "explanation": "Piping makes code readable and avoids deeply nested function calls. It allows\nyou to see the flow of data transformations in a clear, linear fashion.",
    "content": "# Use .pipe for Composition\n\n## Guideline\n\nTo apply a sequence of transformations or operations to an `Effect`, use the\n`.pipe()` method.\n\n## Rationale\n\nPiping makes code readable and avoids deeply nested function calls. It allows\nyou to see the flow of data transformations in a clear, linear fashion.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.succeed(5).pipe(\n  Effect.map((n) => n * 2),\n  Effect.map((n) => `The result is ${n}`),\n  Effect.tap(Effect.log)\n);\n\n// Demonstrate various pipe composition patterns\nconst demo = Effect.gen(function* () {\n  yield* Effect.log(\"=== Using Pipe for Composition Demo ===\");\n\n  // 1. Basic pipe composition\n  yield* Effect.log(\"\\n1. Basic pipe composition:\");\n  yield* program;\n\n  // 2. Complex pipe composition with multiple transformations\n  yield* Effect.log(\"\\n2. Complex pipe composition:\");\n  const complexResult = yield* Effect.succeed(10).pipe(\n    Effect.map((n) => n + 5),\n    Effect.map((n) => n * 2),\n    Effect.tap((n) => Effect.log(`Intermediate result: ${n}`)),\n    Effect.map((n) => n.toString()),\n    Effect.map((s) => `Final: ${s}`)\n  );\n  yield* Effect.log(\"Complex result: \" + complexResult);\n\n  // 3. Pipe with flatMap for chaining effects\n  yield* Effect.log(\"\\n3. Pipe with flatMap for chaining effects:\");\n  const chainedResult = yield* Effect.succeed(\"hello\").pipe(\n    Effect.map((s) => s.toUpperCase()),\n    Effect.flatMap((s) => Effect.succeed(`${s} WORLD`)),\n    Effect.flatMap((s) => Effect.succeed(`${s}!`)),\n    Effect.tap((s) => Effect.log(`Chained: ${s}`))\n  );\n  yield* Effect.log(\"Chained result: \" + chainedResult);\n\n  // 4. Pipe with error handling\n  yield* Effect.log(\"\\n4. Pipe with error handling:\");\n  const errorHandledResult = yield* Effect.succeed(-1).pipe(\n    Effect.flatMap((n) =>\n      n > 0 ? Effect.succeed(n) : Effect.fail(new Error(\"Negative number\"))\n    ),\n    Effect.catchAll((error) =>\n      Effect.succeed(\"Handled error: \" + error.message)\n    ),\n    Effect.tap((result) => Effect.log(`Error handled: ${result}`))\n  );\n  yield* Effect.log(\"Error handled result: \" + errorHandledResult);\n\n  // 5. Pipe with multiple operations\n  yield* Effect.log(\"\\n5. Pipe with multiple operations:\");\n  const multiOpResult = yield* Effect.succeed([1, 2, 3, 4, 5]).pipe(\n    Effect.map((arr) => arr.filter((n) => n % 2 === 0)),\n    Effect.map((arr) => arr.map((n) => n * 2)),\n    Effect.map((arr) => arr.reduce((sum, n) => sum + n, 0)),\n    Effect.tap((sum) => Effect.log(`Sum of even numbers doubled: ${sum}`))\n  );\n  yield* Effect.log(\"Multi-operation result: \" + multiOpResult);\n\n  yield* Effect.log(\"\\n‚úÖ Pipe composition demonstration completed!\");\n});\n\nEffect.runPromise(demo);\n\n```\n\n**Explanation:**  \nUsing `.pipe()` allows you to compose operations in a top-to-bottom style,\nimproving readability and maintainability.\n\n## Anti-Pattern\n\nNesting function calls manually. This is hard to read and reorder.\n`Effect.tap(Effect.map(Effect.map(Effect.succeed(5), n => n * 2), n => ...))`"
  },
  {
    "id": "data-chunk",
    "title": "Use Chunk for High-Performance Collections",
    "description": "Use Chunk to model immutable, high-performance collections for efficient data processing and transformation.",
    "skillLevel": "intermediate",
    "useCases": [
      "observability"
    ],
    "example": "```typescript\nimport { Chunk } from \"effect\";\n\n// Create a Chunk from an array\nconst numbers = Chunk.fromIterable([1, 2, 3, 4]); // Chunk<number>\n\n// Map and filter over a Chunk\nconst doubled = numbers.pipe(Chunk.map((n) => n * 2)); // Chunk<number>\nconst evens = numbers.pipe(Chunk.filter((n) => n % 2 === 0)); // Chunk<number>\n\n// Concatenate Chunks\nconst moreNumbers = Chunk.fromIterable([5, 6]);\nconst allNumbers = Chunk.appendAll(numbers, moreNumbers); // Chunk<number>\n\n// Convert back to array\nconst arr = Chunk.toReadonlyArray(allNumbers); // readonly number[]\n```\n\n**Explanation:**  \n- `Chunk` is immutable and optimized for performance.\n- It supports efficient batch operations, concatenation, and transformation.\n- Use `Chunk` in data pipelines, streaming, and concurrent scenarios.",
    "antiPattern": "Using mutable JavaScript arrays for shared or concurrent data, or for large-scale data processing, which can lead to bugs, inefficiency, and unpredictable behavior.",
    "explanation": "`Chunk` provides efficient, immutable operations for large or frequently transformed collections.  \nIt avoids the pitfalls of mutable arrays and is designed for use in concurrent and streaming workflows.",
    "content": "# Use `Chunk` for High-Performance Collections\n\n## Guideline\n\nUse the `Chunk<A>` data type as an immutable, high-performance alternative to JavaScript's `Array`.  \n`Chunk` is optimized for functional programming, batch processing, and streaming scenarios.\n\n## Rationale\n\n`Chunk` provides efficient, immutable operations for large or frequently transformed collections.  \nIt avoids the pitfalls of mutable arrays and is designed for use in concurrent and streaming workflows.\n\n## Good Example\n\n```typescript\nimport { Chunk } from \"effect\";\n\n// Create a Chunk from an array\nconst numbers = Chunk.fromIterable([1, 2, 3, 4]); // Chunk<number>\n\n// Map and filter over a Chunk\nconst doubled = numbers.pipe(Chunk.map((n) => n * 2)); // Chunk<number>\nconst evens = numbers.pipe(Chunk.filter((n) => n % 2 === 0)); // Chunk<number>\n\n// Concatenate Chunks\nconst moreNumbers = Chunk.fromIterable([5, 6]);\nconst allNumbers = Chunk.appendAll(numbers, moreNumbers); // Chunk<number>\n\n// Convert back to array\nconst arr = Chunk.toReadonlyArray(allNumbers); // readonly number[]\n```\n\n**Explanation:**  \n- `Chunk` is immutable and optimized for performance.\n- It supports efficient batch operations, concatenation, and transformation.\n- Use `Chunk` in data pipelines, streaming, and concurrent scenarios.\n\n## Anti-Pattern\n\nUsing mutable JavaScript arrays for shared or concurrent data, or for large-scale data processing, which can lead to bugs, inefficiency, and unpredictable behavior."
  },
  {
    "id": "use-chunk-for-high-performance-collections",
    "title": "Use Chunk for High-Performance Collections",
    "description": "Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance.",
    "skillLevel": "intermediate",
    "useCases": [
      "core-concepts"
    ],
    "example": "This example shows how to create and manipulate a `Chunk`. The API is very similar to `Array`, but the underlying performance characteristics for these immutable operations are superior.\n\n```typescript\nimport { Chunk, Effect } from \"effect\";\n\n// Create a Chunk from an array\nlet numbers = Chunk.fromIterable([1, 2, 3, 4, 5]);\n\n// Append a new element. This is much faster than [...arr, 6] on large collections.\nnumbers = Chunk.append(numbers, 6);\n\n// Prepend an element.\nnumbers = Chunk.prepend(numbers, 0);\n\n// Take the first 3 elements\nconst firstThree = Chunk.take(numbers, 3);\n\n// Convert back to an array when you need to interface with other libraries\nconst finalArray = Chunk.toReadonlyArray(firstThree);\n\nEffect.runSync(Effect.log(finalArray)); // [0, 1, 2]\n```\n\n---",
    "antiPattern": "Eagerly converting a large or potentially infinite iterable to a `Chunk` before streaming. This completely negates the memory-safety benefits of using a `Stream`.\n\n```typescript\nimport { Effect, Stream, Chunk } from \"effect\";\n\n// A generator that could produce a very large (or infinite) number of items.\nfunction* largeDataSource() {\n  let i = 0;\n  while (i < 1_000_000) {\n    yield i++;\n  }\n}\n\n// ‚ùå DANGEROUS: `Chunk.fromIterable` will try to pull all 1,000,000 items\n// from the generator and load them into memory at once before the stream\n// even starts. This can lead to high memory usage or a crash.\nconst programWithChunk = Stream.fromChunk(Chunk.fromIterable(largeDataSource())).pipe(\n  Stream.map((n) => n * 2),\n  Stream.runDrain,\n);\n\n// ‚úÖ CORRECT: `Stream.fromIterable` pulls items from the data source lazily,\n// one at a time (or in small batches), maintaining constant memory usage.\nconst programWithIterable = Stream.fromIterable(largeDataSource()).pipe(\n  Stream.map((n) => n * 2),\n  Stream.runDrain,\n);\n```",
    "explanation": "JavaScript's `Array` is a mutable data structure. Every time you perform an \"immutable\" operation like `[...arr, newItem]` or `arr.map(...)`, you are creating a brand new array and copying all the elements from the old one. For small arrays, this is fine. For large arrays or in hot code paths, this constant allocation and copying can become a performance bottleneck.\n\n`Chunk` is designed to solve this. It's an immutable data structure that uses structural sharing internally. When you append an item to a `Chunk`, it doesn't re-copy the entire collection. Instead, it creates a new `Chunk` that reuses most of the internal structure of the original, only allocating memory for the new data. This makes immutable appends and updates significantly faster.\n\n---",
    "content": "## Guideline\n\nFor collections that will be heavily transformed with immutable operations (e.g., `map`, `filter`, `append`), use `Chunk<A>`. `Chunk` is Effect's implementation of a persistent and chunked vector that provides better performance than native arrays for these use cases.\n\n---\n\n## Rationale\n\nJavaScript's `Array` is a mutable data structure. Every time you perform an \"immutable\" operation like `[...arr, newItem]` or `arr.map(...)`, you are creating a brand new array and copying all the elements from the old one. For small arrays, this is fine. For large arrays or in hot code paths, this constant allocation and copying can become a performance bottleneck.\n\n`Chunk` is designed to solve this. It's an immutable data structure that uses structural sharing internally. When you append an item to a `Chunk`, it doesn't re-copy the entire collection. Instead, it creates a new `Chunk` that reuses most of the internal structure of the original, only allocating memory for the new data. This makes immutable appends and updates significantly faster.\n\n---\n\n## Good Example\n\nThis example shows how to create and manipulate a `Chunk`. The API is very similar to `Array`, but the underlying performance characteristics for these immutable operations are superior.\n\n```typescript\nimport { Chunk, Effect } from \"effect\";\n\n// Create a Chunk from an array\nlet numbers = Chunk.fromIterable([1, 2, 3, 4, 5]);\n\n// Append a new element. This is much faster than [...arr, 6] on large collections.\nnumbers = Chunk.append(numbers, 6);\n\n// Prepend an element.\nnumbers = Chunk.prepend(numbers, 0);\n\n// Take the first 3 elements\nconst firstThree = Chunk.take(numbers, 3);\n\n// Convert back to an array when you need to interface with other libraries\nconst finalArray = Chunk.toReadonlyArray(firstThree);\n\nEffect.runSync(Effect.log(finalArray)); // [0, 1, 2]\n```\n\n---\n\n## Anti-Pattern\n\nEagerly converting a large or potentially infinite iterable to a `Chunk` before streaming. This completely negates the memory-safety benefits of using a `Stream`.\n\n```typescript\nimport { Effect, Stream, Chunk } from \"effect\";\n\n// A generator that could produce a very large (or infinite) number of items.\nfunction* largeDataSource() {\n  let i = 0;\n  while (i < 1_000_000) {\n    yield i++;\n  }\n}\n\n// ‚ùå DANGEROUS: `Chunk.fromIterable` will try to pull all 1,000,000 items\n// from the generator and load them into memory at once before the stream\n// even starts. This can lead to high memory usage or a crash.\nconst programWithChunk = Stream.fromChunk(Chunk.fromIterable(largeDataSource())).pipe(\n  Stream.map((n) => n * 2),\n  Stream.runDrain,\n);\n\n// ‚úÖ CORRECT: `Stream.fromIterable` pulls items from the data source lazily,\n// one at a time (or in small batches), maintaining constant memory usage.\nconst programWithIterable = Stream.fromIterable(largeDataSource()).pipe(\n  Stream.map((n) => n * 2),\n  Stream.runDrain,\n);\n```"
  },
  {
    "id": "use-gen-for-business-logic",
    "title": "Use Effect.gen for Business Logic",
    "description": "Use Effect.gen for business logic.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Concrete implementations for demonstration\nconst validateUser = (\n  data: any\n): Effect.Effect<{ email: string; password: string }, Error, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Validating user data: ${JSON.stringify(data)}`);\n\n    if (!data.email || !data.password) {\n      return yield* Effect.fail(new Error(\"Email and password are required\"));\n    }\n\n    if (data.password.length < 6) {\n      return yield* Effect.fail(\n        new Error(\"Password must be at least 6 characters\")\n      );\n    }\n\n    yield* Effect.logInfo(\"‚úÖ User data validated successfully\");\n    return { email: data.email, password: data.password };\n  });\n\nconst hashPassword = (pw: string): Effect.Effect<string, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Hashing password...\");\n    // Simulate password hashing\n    const timestamp = yield* Effect.sync(() => Date.now());\n    const hashed = `hashed_${pw}_${timestamp}`;\n    yield* Effect.logInfo(\"‚úÖ Password hashed successfully\");\n    return hashed;\n  });\n\nconst dbCreateUser = (data: {\n  email: string;\n  password: string;\n}): Effect.Effect<{ id: number; email: string }, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Creating user in database: ${data.email}`);\n    // Simulate database operation\n    const user = { id: Math.floor(Math.random() * 1000), email: data.email };\n    yield* Effect.logInfo(`‚úÖ User created with ID: ${user.id}`);\n    return user;\n  });\n\nconst createUser = (\n  userData: any\n): Effect.Effect<{ id: number; email: string }, Error, never> =>\n  Effect.gen(function* () {\n    const validated = yield* validateUser(userData);\n    const hashed = yield* hashPassword(validated.password);\n    return yield* dbCreateUser({ ...validated, password: hashed });\n  });\n\n// Demonstrate using Effect.gen for business logic\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Using Effect.gen for Business Logic Demo ===\");\n\n  // Example 1: Successful user creation\n  yield* Effect.logInfo(\"\\n1. Creating a valid user:\");\n  const validUser = yield* createUser({\n    email: \"paul@example.com\",\n    password: \"securepassword123\",\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Created user: ${JSON.stringify(validUser)}`);\n\n  // Example 2: Invalid user data\n  yield* Effect.logInfo(\"\\n2. Attempting to create user with invalid data:\");\n  const invalidUser = yield* createUser({\n    email: \"invalid@example.com\",\n    password: \"123\", // Too short\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Result: ${JSON.stringify(invalidUser)}`);\n\n  yield* Effect.logInfo(\"\\n‚úÖ Business logic demonstration completed!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Effect.gen` allows you to express business logic in a clear, sequential style,\nimproving maintainability.",
    "antiPattern": "Using long chains of `.andThen` or `.flatMap` for multi-step business logic.\nThis is harder to read and pass state between steps.",
    "explanation": "Generators provide a syntax that closely resembles standard synchronous code\n(`async/await`), making complex workflows significantly easier to read, write,\nand debug.",
    "content": "# Use Effect.gen for Business Logic\n\n## Guideline\n\nUse `Effect.gen` to write your core business logic, especially when it involves\nmultiple sequential steps or conditional branching.\n\n## Rationale\n\nGenerators provide a syntax that closely resembles standard synchronous code\n(`async/await`), making complex workflows significantly easier to read, write,\nand debug.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Concrete implementations for demonstration\nconst validateUser = (\n  data: any\n): Effect.Effect<{ email: string; password: string }, Error, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Validating user data: ${JSON.stringify(data)}`);\n\n    if (!data.email || !data.password) {\n      return yield* Effect.fail(new Error(\"Email and password are required\"));\n    }\n\n    if (data.password.length < 6) {\n      return yield* Effect.fail(\n        new Error(\"Password must be at least 6 characters\")\n      );\n    }\n\n    yield* Effect.logInfo(\"‚úÖ User data validated successfully\");\n    return { email: data.email, password: data.password };\n  });\n\nconst hashPassword = (pw: string): Effect.Effect<string, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Hashing password...\");\n    // Simulate password hashing\n    const timestamp = yield* Effect.sync(() => Date.now());\n    const hashed = `hashed_${pw}_${timestamp}`;\n    yield* Effect.logInfo(\"‚úÖ Password hashed successfully\");\n    return hashed;\n  });\n\nconst dbCreateUser = (data: {\n  email: string;\n  password: string;\n}): Effect.Effect<{ id: number; email: string }, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Creating user in database: ${data.email}`);\n    // Simulate database operation\n    const user = { id: Math.floor(Math.random() * 1000), email: data.email };\n    yield* Effect.logInfo(`‚úÖ User created with ID: ${user.id}`);\n    return user;\n  });\n\nconst createUser = (\n  userData: any\n): Effect.Effect<{ id: number; email: string }, Error, never> =>\n  Effect.gen(function* () {\n    const validated = yield* validateUser(userData);\n    const hashed = yield* hashPassword(validated.password);\n    return yield* dbCreateUser({ ...validated, password: hashed });\n  });\n\n// Demonstrate using Effect.gen for business logic\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Using Effect.gen for Business Logic Demo ===\");\n\n  // Example 1: Successful user creation\n  yield* Effect.logInfo(\"\\n1. Creating a valid user:\");\n  const validUser = yield* createUser({\n    email: \"paul@example.com\",\n    password: \"securepassword123\",\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Created user: ${JSON.stringify(validUser)}`);\n\n  // Example 2: Invalid user data\n  yield* Effect.logInfo(\"\\n2. Attempting to create user with invalid data:\");\n  const invalidUser = yield* createUser({\n    email: \"invalid@example.com\",\n    password: \"123\", // Too short\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Result: ${JSON.stringify(invalidUser)}`);\n\n  yield* Effect.logInfo(\"\\n‚úÖ Business logic demonstration completed!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Effect.gen` allows you to express business logic in a clear, sequential style,\nimproving maintainability.\n\n## Anti-Pattern\n\nUsing long chains of `.andThen` or `.flatMap` for multi-step business logic.\nThis is harder to read and pass state between steps."
  },
  {
    "id": "use-default-layer-for-tests",
    "title": "Use the Auto-Generated .Default Layer in Tests",
    "description": "Use the auto-generated .Default layer in tests.",
    "skillLevel": "intermediate",
    "useCases": [
      "testing"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Define MyService using Effect.Service pattern\nclass MyService extends Effect.Service<MyService>()(\n  \"MyService\",\n  {\n    sync: () => ({\n      doSomething: () => \n        Effect.succeed(\"done\").pipe(\n          Effect.tap(() => Effect.log(\"MyService did something!\"))\n        )\n    })\n  }\n) {}\n\n// Create a program that uses MyService\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Getting MyService...\");\n  const service = yield* MyService;\n  \n  yield* Effect.log(\"Calling doSomething()...\");\n  const result = yield* service.doSomething();\n  \n  yield* Effect.log(`Result: ${result}`);\n});\n\n// Run the program with default service implementation\nEffect.runPromise(\n  Effect.provide(program, MyService.Default)\n);\n```\n\n**Explanation:**  \nThis approach ensures your tests are idiomatic, maintainable, and take full advantage of Effect's dependency injection system.",
    "antiPattern": "Do not create manual layers for your service in tests (`Layer.succeed(...)`) or try to provide the service class directly. This bypasses the intended dependency injection mechanism.",
    "explanation": "The `.Default` layer is the canonical way to provide a service in a test environment. It's automatically created, correctly scoped, and handles resolving any transitive dependencies, making tests cleaner and more robust.",
    "content": "# Use the Auto-Generated .Default Layer in Tests\n\n## Guideline\n\nIn your tests, provide service dependencies using the static `.Default` property that `Effect.Service` automatically attaches to your service class.\n\n## Rationale\n\nThe `.Default` layer is the canonical way to provide a service in a test environment. It's automatically created, correctly scoped, and handles resolving any transitive dependencies, making tests cleaner and more robust.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define MyService using Effect.Service pattern\nclass MyService extends Effect.Service<MyService>()(\n  \"MyService\",\n  {\n    sync: () => ({\n      doSomething: () => \n        Effect.succeed(\"done\").pipe(\n          Effect.tap(() => Effect.log(\"MyService did something!\"))\n        )\n    })\n  }\n) {}\n\n// Create a program that uses MyService\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Getting MyService...\");\n  const service = yield* MyService;\n  \n  yield* Effect.log(\"Calling doSomething()...\");\n  const result = yield* service.doSomething();\n  \n  yield* Effect.log(`Result: ${result}`);\n});\n\n// Run the program with default service implementation\nEffect.runPromise(\n  Effect.provide(program, MyService.Default)\n);\n```\n\n**Explanation:**  \nThis approach ensures your tests are idiomatic, maintainable, and take full advantage of Effect's dependency injection system.\n\n## Anti-Pattern\n\nDo not create manual layers for your service in tests (`Layer.succeed(...)`) or try to provide the service class directly. This bypasses the intended dependency injection mechanism."
  },
  {
    "id": "validate-request-body",
    "title": "Validate Request Body",
    "description": "Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies.",
    "skillLevel": "intermediate",
    "useCases": [
      "building-apis"
    ],
    "example": "This example defines a `POST` route to create a user. It uses a `CreateUser` schema to validate the request body. If validation passes, it returns a success message with the typed data. If it fails, the platform automatically sends a descriptive 400 error.\n\n```typescript\nimport { Duration, Effect } from \"effect\";\nimport * as S from \"effect/Schema\";\nimport { createServer, IncomingMessage, ServerResponse } from \"http\";\n\n// Define user schema\nconst UserSchema = S.Struct({\n  name: S.String,\n  email: S.String.pipe(S.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)),\n});\ntype User = S.Schema.Type<typeof UserSchema>;\n\n// Define user service interface\ninterface UserServiceInterface {\n  readonly validateUser: (data: unknown) => Effect.Effect<User, Error, never>;\n}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    validateUser: (data: unknown) => S.decodeUnknown(UserSchema)(data),\n  }),\n}) { }\n\n// Define HTTP server service interface\ninterface HttpServerInterface {\n  readonly handleRequest: (\n    request: IncomingMessage,\n    response: ServerResponse\n  ) => Effect.Effect<void, Error, never>;\n  readonly start: () => Effect.Effect<void, Error, never>;\n}\n\n// Define HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  // Define effect-based implementation that uses dependencies\n  effect: Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    return {\n      handleRequest: (request: IncomingMessage, response: ServerResponse) =>\n        Effect.gen(function* () {\n          // Only handle POST /users\n          if (request.method !== \"POST\" || request.url !== \"/users\") {\n            response.writeHead(404, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: \"Not Found\" }));\n            return;\n          }\n\n          try {\n            // Read request body\n            const body = yield* Effect.async<unknown, Error>((resume) => {\n              let data = \"\";\n              request.on(\"data\", (chunk) => {\n                data += chunk;\n              });\n              request.on(\"end\", () => {\n                try {\n                  resume(Effect.succeed(JSON.parse(data)));\n                } catch (e) {\n                  resume(\n                    Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                  );\n                }\n              });\n              request.on(\"error\", (e) =>\n                resume(\n                  Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                )\n              );\n            });\n\n            // Validate body against schema\n            const user = yield* userService.validateUser(body);\n\n            response.writeHead(200, { \"Content-Type\": \"application/json\" });\n            response.end(\n              JSON.stringify({\n                message: `Successfully created user: ${user.name}`,\n              })\n            );\n          } catch (error) {\n            response.writeHead(400, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: String(error) }));\n          }\n        }),\n\n      start: function (this: HttpServer) {\n        const self = this;\n        return Effect.gen(function* () {\n          // Create HTTP server\n          const server = createServer((req, res) =>\n            Effect.runFork(self.handleRequest(req, res))\n          );\n\n          // Add cleanup finalizer\n          yield* Effect.addFinalizer(() =>\n            Effect.gen(function* () {\n              yield* Effect.sync(() => server.close());\n              yield* Effect.logInfo(\"Server shut down\");\n            })\n          );\n\n          // Start server\n          yield* Effect.async<void, Error>((resume) => {\n            server.on(\"error\", (error) => resume(Effect.fail(error)));\n            server.listen(3456, () => {\n              Effect.runFork(\n                Effect.logInfo(\"Server running at http://localhost:3456/\")\n              );\n              resume(Effect.succeed(void 0));\n            });\n          });\n\n          // Run for demonstration period\n          yield* Effect.sleep(Duration.seconds(3));\n          yield* Effect.logInfo(\"Demo completed - shutting down server\");\n        });\n      },\n    };\n  }),\n  // Specify dependencies\n  dependencies: [UserService.Default],\n}) { }\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start().pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Server error: ${error}`);\n        return yield* Effect.fail(error);\n      })\n    )\n  );\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up\n);\n\n// Run the server\nEffect.runFork(Effect.provide(program, HttpServer.Default));\n\n/*\nTo test:\n- POST http://localhost:3456/users with body {\"name\": \"Paul\", \"email\": \"paul@effect.com\"}\n  -> Returns 200 OK with message \"Successfully created user: Paul\"\n\n- POST http://localhost:3456/users with body {\"name\": \"Paul\"}\n  -> Returns 400 Bad Request with error message about missing email field\n*/\n\n```",
    "antiPattern": "The anti-pattern is to manually parse the JSON and then write imperative validation checks. This approach is verbose, error-prone, and not type-safe.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst createUserRoute = Http.router.post(\n  '/users',\n  Http.request.json.pipe(\n    // Http.request.json returns Effect<unknown, ...>\n    Effect.flatMap((body) => {\n      // Manually check the type and properties of the body.\n      if (\n        typeof body === 'object' &&\n        body !== null &&\n        'name' in body &&\n        typeof body.name === 'string' &&\n        'email' in body &&\n        typeof body.email === 'string'\n      ) {\n        // The type is still not safely inferred here without casting.\n        return Http.response.text(`Successfully created user: ${body.name}`);\n      } else {\n        // Manually create and return a generic error response.\n        return Http.response.text('Invalid request body', { status: 400 });\n      }\n    })\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(createUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual code is significantly worse. It's hard to read, easy to get wrong, and loses all static type information from the parsed body. Crucially, it forces you to reinvent the wheel for error reporting, which will likely be less detailed and consistent than the automatic responses provided by the platform.",
    "explanation": "Accepting user-provided data is one of the most critical and sensitive parts of an API. You must never trust incoming data. The `Http` module's integration with `Schema` provides a robust, declarative solution for this.\n\nUsing `Http.request.schemaBodyJson` offers several major advantages:\n\n1.  **Automatic Validation and Error Handling**: If the incoming body does not match the schema, the server automatically rejects the request with a `400 Bad Request` status and a detailed JSON response explaining the validation errors. You don't have to write any of this boilerplate logic.\n2.  **Type Safety**: If the validation succeeds, the value produced by the `Effect` is fully typed according to your `Schema`. This eliminates `any` types and brings static analysis benefits to your request handlers.\n3.  **Declarative and Clean**: The validation rules are defined once in the `Schema` and then simply applied. This separates the validation logic from your business logic, keeping handlers clean and focused on their core task.\n4.  **Security**: It acts as a security gateway, ensuring that malformed or unexpected data structures never reach your application's core logic.\n\n---",
    "content": "## Guideline\n\nTo process an incoming request body, use `Http.request.schemaBodyJson(YourSchema)` to parse the JSON and validate its structure in a single, type-safe step.\n\n---\n\n## Rationale\n\nAccepting user-provided data is one of the most critical and sensitive parts of an API. You must never trust incoming data. The `Http` module's integration with `Schema` provides a robust, declarative solution for this.\n\nUsing `Http.request.schemaBodyJson` offers several major advantages:\n\n1.  **Automatic Validation and Error Handling**: If the incoming body does not match the schema, the server automatically rejects the request with a `400 Bad Request` status and a detailed JSON response explaining the validation errors. You don't have to write any of this boilerplate logic.\n2.  **Type Safety**: If the validation succeeds, the value produced by the `Effect` is fully typed according to your `Schema`. This eliminates `any` types and brings static analysis benefits to your request handlers.\n3.  **Declarative and Clean**: The validation rules are defined once in the `Schema` and then simply applied. This separates the validation logic from your business logic, keeping handlers clean and focused on their core task.\n4.  **Security**: It acts as a security gateway, ensuring that malformed or unexpected data structures never reach your application's core logic.\n\n---\n\n## Good Example\n\nThis example defines a `POST` route to create a user. It uses a `CreateUser` schema to validate the request body. If validation passes, it returns a success message with the typed data. If it fails, the platform automatically sends a descriptive 400 error.\n\n```typescript\nimport { Duration, Effect } from \"effect\";\nimport * as S from \"effect/Schema\";\nimport { createServer, IncomingMessage, ServerResponse } from \"http\";\n\n// Define user schema\nconst UserSchema = S.Struct({\n  name: S.String,\n  email: S.String.pipe(S.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)),\n});\ntype User = S.Schema.Type<typeof UserSchema>;\n\n// Define user service interface\ninterface UserServiceInterface {\n  readonly validateUser: (data: unknown) => Effect.Effect<User, Error, never>;\n}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    validateUser: (data: unknown) => S.decodeUnknown(UserSchema)(data),\n  }),\n}) { }\n\n// Define HTTP server service interface\ninterface HttpServerInterface {\n  readonly handleRequest: (\n    request: IncomingMessage,\n    response: ServerResponse\n  ) => Effect.Effect<void, Error, never>;\n  readonly start: () => Effect.Effect<void, Error, never>;\n}\n\n// Define HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  // Define effect-based implementation that uses dependencies\n  effect: Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    return {\n      handleRequest: (request: IncomingMessage, response: ServerResponse) =>\n        Effect.gen(function* () {\n          // Only handle POST /users\n          if (request.method !== \"POST\" || request.url !== \"/users\") {\n            response.writeHead(404, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: \"Not Found\" }));\n            return;\n          }\n\n          try {\n            // Read request body\n            const body = yield* Effect.async<unknown, Error>((resume) => {\n              let data = \"\";\n              request.on(\"data\", (chunk) => {\n                data += chunk;\n              });\n              request.on(\"end\", () => {\n                try {\n                  resume(Effect.succeed(JSON.parse(data)));\n                } catch (e) {\n                  resume(\n                    Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                  );\n                }\n              });\n              request.on(\"error\", (e) =>\n                resume(\n                  Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                )\n              );\n            });\n\n            // Validate body against schema\n            const user = yield* userService.validateUser(body);\n\n            response.writeHead(200, { \"Content-Type\": \"application/json\" });\n            response.end(\n              JSON.stringify({\n                message: `Successfully created user: ${user.name}`,\n              })\n            );\n          } catch (error) {\n            response.writeHead(400, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: String(error) }));\n          }\n        }),\n\n      start: function (this: HttpServer) {\n        const self = this;\n        return Effect.gen(function* () {\n          // Create HTTP server\n          const server = createServer((req, res) =>\n            Effect.runFork(self.handleRequest(req, res))\n          );\n\n          // Add cleanup finalizer\n          yield* Effect.addFinalizer(() =>\n            Effect.gen(function* () {\n              yield* Effect.sync(() => server.close());\n              yield* Effect.logInfo(\"Server shut down\");\n            })\n          );\n\n          // Start server\n          yield* Effect.async<void, Error>((resume) => {\n            server.on(\"error\", (error) => resume(Effect.fail(error)));\n            server.listen(3456, () => {\n              Effect.runFork(\n                Effect.logInfo(\"Server running at http://localhost:3456/\")\n              );\n              resume(Effect.succeed(void 0));\n            });\n          });\n\n          // Run for demonstration period\n          yield* Effect.sleep(Duration.seconds(3));\n          yield* Effect.logInfo(\"Demo completed - shutting down server\");\n        });\n      },\n    };\n  }),\n  // Specify dependencies\n  dependencies: [UserService.Default],\n}) { }\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start().pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Server error: ${error}`);\n        return yield* Effect.fail(error);\n      })\n    )\n  );\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up\n);\n\n// Run the server\nEffect.runFork(Effect.provide(program, HttpServer.Default));\n\n/*\nTo test:\n- POST http://localhost:3456/users with body {\"name\": \"Paul\", \"email\": \"paul@effect.com\"}\n  -> Returns 200 OK with message \"Successfully created user: Paul\"\n\n- POST http://localhost:3456/users with body {\"name\": \"Paul\"}\n  -> Returns 400 Bad Request with error message about missing email field\n*/\n\n```\n\n## Anti-Pattern\n\nThe anti-pattern is to manually parse the JSON and then write imperative validation checks. This approach is verbose, error-prone, and not type-safe.\n\n```typescript\nimport { Effect } from 'effect';\nimport { Http, NodeHttpServer, NodeRuntime } from '@effect/platform-node';\n\nconst createUserRoute = Http.router.post(\n  '/users',\n  Http.request.json.pipe(\n    // Http.request.json returns Effect<unknown, ...>\n    Effect.flatMap((body) => {\n      // Manually check the type and properties of the body.\n      if (\n        typeof body === 'object' &&\n        body !== null &&\n        'name' in body &&\n        typeof body.name === 'string' &&\n        'email' in body &&\n        typeof body.email === 'string'\n      ) {\n        // The type is still not safely inferred here without casting.\n        return Http.response.text(`Successfully created user: ${body.name}`);\n      } else {\n        // Manually create and return a generic error response.\n        return Http.response.text('Invalid request body', { status: 400 });\n      }\n    })\n  )\n);\n\nconst app = Http.router.empty.pipe(Http.router.addRoute(createUserRoute));\n\nconst program = Http.server.serve(app).pipe(\n  Effect.provide(NodeHttpServer.layer({ port: 3000 }))\n);\n\nNodeRuntime.runMain(program);\n```\n\nThis manual code is significantly worse. It's hard to read, easy to get wrong, and loses all static type information from the parsed body. Crucially, it forces you to reinvent the wheel for error reporting, which will likely be less detailed and consistent than the automatic responses provided by the platform."
  },
  {
    "id": "brand-validate-parse",
    "title": "Validating and Parsing Branded Types",
    "description": "Combine Schema and Brand to validate and parse branded types, guaranteeing only valid domain values are created at runtime.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Brand, Effect, Schema } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Create a Schema for Email validation\nconst EmailSchema = Schema.String.pipe(\n  Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/), // Simple email regex\n  Schema.brand(\"Email\" as const) // Attach the brand\n);\n\n// Parse and validate an email at runtime\nconst parseEmail = (input: string) =>\n  Effect.try({\n    try: () => Schema.decodeSync(EmailSchema)(input),\n    catch: (err) => `Invalid email: ${String(err)}`,\n  });\n\n// Usage\nparseEmail(\"user@example.com\").pipe(\n  Effect.match({\n    onSuccess: (email) => console.log(\"Valid email:\", email),\n    onFailure: (err) => console.error(err),\n  })\n);\n\n```\n\n**Explanation:**  \n- `Schema` is used to define validation logic for the branded type.\n- `Brand.schema<Email>()` attaches the brand to the schema, so only validated values can be constructed as `Email`.\n- This pattern ensures both compile-time and runtime safety.",
    "antiPattern": "Branding values without runtime validation, or accepting unvalidated user input as branded types, which can lead to invalid domain values and runtime bugs.",
    "explanation": "While branding types at the type level prevents accidental misuse, runtime validation is needed to ensure only valid values are constructed from user input, APIs, or external sources.",
    "content": "# Validating and Parsing Branded Types\n\n## Guideline\n\nUse `Schema` in combination with `Brand` to validate and parse branded types at runtime.  \nThis ensures that only values passing your validation logic can be constructed as branded types, making your domain models robust and type-safe.\n\n## Rationale\n\nWhile branding types at the type level prevents accidental misuse, runtime validation is needed to ensure only valid values are constructed from user input, APIs, or external sources.\n\n## Good Example\n\n```typescript\nimport { Brand, Effect, Schema } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Create a Schema for Email validation\nconst EmailSchema = Schema.String.pipe(\n  Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/), // Simple email regex\n  Schema.brand(\"Email\" as const) // Attach the brand\n);\n\n// Parse and validate an email at runtime\nconst parseEmail = (input: string) =>\n  Effect.try({\n    try: () => Schema.decodeSync(EmailSchema)(input),\n    catch: (err) => `Invalid email: ${String(err)}`,\n  });\n\n// Usage\nparseEmail(\"user@example.com\").pipe(\n  Effect.match({\n    onSuccess: (email) => console.log(\"Valid email:\", email),\n    onFailure: (err) => console.error(err),\n  })\n);\n\n```\n\n**Explanation:**  \n- `Schema` is used to define validation logic for the branded type.\n- `Brand.schema<Email>()` attaches the brand to the schema, so only validated values can be constructed as `Email`.\n- This pattern ensures both compile-time and runtime safety.\n\n## Anti-Pattern\n\nBranding values without runtime validation, or accepting unvalidated user input as branded types, which can lead to invalid domain values and runtime bugs."
  },
  {
    "id": "data-bigdecimal",
    "title": "Work with Arbitrary-Precision Numbers using BigDecimal",
    "description": "Use BigDecimal to represent and compute with decimal numbers that require arbitrary precision, such as in finance or scientific domains.",
    "skillLevel": "intermediate",
    "useCases": [
      "modeling-data"
    ],
    "example": "```typescript\nimport { BigDecimal } from \"effect\";\n\n// Create BigDecimal values\nconst a = BigDecimal.fromNumber(0.1);\nconst b = BigDecimal.fromNumber(0.2);\n\n// Add, subtract, multiply, divide\nconst sum = BigDecimal.sum(a, b); // BigDecimal(0.3)\nconst product = BigDecimal.multiply(a, b); // BigDecimal(0.02)\n\n// Compare values\nconst isEqual = BigDecimal.equals(sum, BigDecimal.fromNumber(0.3)); // true\n\n// Convert to string or number\nconst asString = BigDecimal.format(BigDecimal.normalize(sum)); // \"0.3\"\nconst asNumber = BigDecimal.unsafeToNumber(sum); // 0.3\n```\n\n**Explanation:**  \n- `BigDecimal` is immutable and supports precise decimal arithmetic.\n- Use it for domains where rounding errors are unacceptable (e.g., finance, billing, scientific data).\n- Avoids the pitfalls of floating-point math in JavaScript.",
    "antiPattern": "Using JavaScript's native `number` type for financial or scientific calculations, which can lead to rounding errors and loss of precision.",
    "explanation": "JavaScript's `number` type is a floating-point double, which can introduce subtle bugs in calculations that require exact decimal representation.  \n`BigDecimal` provides precise, immutable arithmetic for critical domains.",
    "content": "# Work with Arbitrary-Precision Numbers using `BigDecimal`\n\n## Guideline\n\nUse the `BigDecimal` data type for decimal numbers that require arbitrary precision, such as financial or scientific calculations.  \nThis avoids rounding errors and loss of precision that can occur with JavaScript's native `number` type.\n\n## Rationale\n\nJavaScript's `number` type is a floating-point double, which can introduce subtle bugs in calculations that require exact decimal representation.  \n`BigDecimal` provides precise, immutable arithmetic for critical domains.\n\n## Good Example\n\n```typescript\nimport { BigDecimal } from \"effect\";\n\n// Create BigDecimal values\nconst a = BigDecimal.fromNumber(0.1);\nconst b = BigDecimal.fromNumber(0.2);\n\n// Add, subtract, multiply, divide\nconst sum = BigDecimal.sum(a, b); // BigDecimal(0.3)\nconst product = BigDecimal.multiply(a, b); // BigDecimal(0.02)\n\n// Compare values\nconst isEqual = BigDecimal.equals(sum, BigDecimal.fromNumber(0.3)); // true\n\n// Convert to string or number\nconst asString = BigDecimal.format(BigDecimal.normalize(sum)); // \"0.3\"\nconst asNumber = BigDecimal.unsafeToNumber(sum); // 0.3\n```\n\n**Explanation:**  \n- `BigDecimal` is immutable and supports precise decimal arithmetic.\n- Use it for domains where rounding errors are unacceptable (e.g., finance, billing, scientific data).\n- Avoids the pitfalls of floating-point math in JavaScript.\n\n## Anti-Pattern\n\nUsing JavaScript's native `number` type for financial or scientific calculations, which can lead to rounding errors and loss of precision."
  },
  {
    "id": "data-datetime",
    "title": "Work with Dates and Times using DateTime",
    "description": "Use DateTime to represent and manipulate dates and times in a type-safe, immutable, and time-zone-aware way.",
    "skillLevel": "intermediate",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { DateTime } from \"effect\";\n\n// Create a DateTime for the current instant (returns an Effect)\nimport { Effect } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  const now = yield* DateTime.now; // DateTime.Utc\n\n  // Parse from ISO string\n  const parsed = DateTime.unsafeMakeZoned(\"2024-07-19T12:34:56Z\"); // DateTime.Zoned\n\n  // Add or subtract durations\n  const inOneHour = DateTime.add(now, { hours: 1 });\n  const oneHourAgo = DateTime.subtract(now, { hours: 1 });\n\n  // Format as ISO string\n  const iso = DateTime.formatIso(now); // e.g., \"2024-07-19T23:33:19.000Z\"\n\n  // Compare DateTimes\n  const isBefore = DateTime.lessThan(oneHourAgo, now); // true\n\n  return { now, inOneHour, oneHourAgo, iso, isBefore };\n});\n\n```\n\n**Explanation:**  \n- `DateTime` is immutable and time-zone-aware.\n- Supports parsing, formatting, arithmetic, and comparison.\n- Use for all date/time logic to avoid bugs with native `Date`.",
    "antiPattern": "Using JavaScript's mutable `Date` for time calculations, or ignoring time zones, which can lead to subtle and hard-to-debug errors.",
    "explanation": "JavaScript's native `Date` is mutable, not time-zone-aware, and can be error-prone.  \n`DateTime` provides an immutable, functional alternative with explicit time zone handling and robust APIs for time arithmetic.",
    "content": "# Work with Dates and Times using `DateTime`\n\n## Guideline\n\nUse the `DateTime` data type to represent and manipulate dates and times in a type-safe, immutable, and time-zone-aware way.  \nThis enables safe, precise, and reliable time calculations in your applications.\n\n## Rationale\n\nJavaScript's native `Date` is mutable, not time-zone-aware, and can be error-prone.  \n`DateTime` provides an immutable, functional alternative with explicit time zone handling and robust APIs for time arithmetic.\n\n## Good Example\n\n```typescript\nimport { DateTime } from \"effect\";\n\n// Create a DateTime for the current instant (returns an Effect)\nimport { Effect } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  const now = yield* DateTime.now; // DateTime.Utc\n\n  // Parse from ISO string\n  const parsed = DateTime.unsafeMakeZoned(\"2024-07-19T12:34:56Z\"); // DateTime.Zoned\n\n  // Add or subtract durations\n  const inOneHour = DateTime.add(now, { hours: 1 });\n  const oneHourAgo = DateTime.subtract(now, { hours: 1 });\n\n  // Format as ISO string\n  const iso = DateTime.formatIso(now); // e.g., \"2024-07-19T23:33:19.000Z\"\n\n  // Compare DateTimes\n  const isBefore = DateTime.lessThan(oneHourAgo, now); // true\n\n  return { now, inOneHour, oneHourAgo, iso, isBefore };\n});\n\n```\n\n**Explanation:**  \n- `DateTime` is immutable and time-zone-aware.\n- Supports parsing, formatting, arithmetic, and comparison.\n- Use for all date/time logic to avoid bugs with native `Date`.\n\n## Anti-Pattern\n\nUsing JavaScript's mutable `Date` for time calculations, or ignoring time zones, which can lead to subtle and hard-to-debug errors."
  },
  {
    "id": "data-hashset",
    "title": "Work with Immutable Sets using HashSet",
    "description": "Use HashSet to represent sets of unique values with efficient, immutable operations for membership, union, intersection, and difference.",
    "skillLevel": "intermediate",
    "useCases": [
      "modeling-data"
    ],
    "example": "```typescript\nimport { HashSet } from \"effect\";\n\n// Create a HashSet from an array\nconst setA = HashSet.fromIterable([1, 2, 3]);\nconst setB = HashSet.fromIterable([3, 4, 5]);\n\n// Membership check\nconst hasTwo = HashSet.has(setA, 2); // true\n\n// Union, intersection, difference\nconst union = HashSet.union(setA, setB);         // HashSet {1, 2, 3, 4, 5}\nconst intersection = HashSet.intersection(setA, setB); // HashSet {3}\nconst difference = HashSet.difference(setA, setB);     // HashSet {1, 2}\n\n// Add and remove elements\nconst withSix = HashSet.add(setA, 6);    // HashSet {1, 2, 3, 6}\nconst withoutOne = HashSet.remove(setA, 1); // HashSet {2, 3}\n```\n\n**Explanation:**  \n- `HashSet` is immutable and supports efficient set operations.\n- Use it for membership checks, set algebra, and modeling unique collections.\n- Safe for concurrent and functional workflows.",
    "antiPattern": "Using mutable JavaScript `Set` for shared or concurrent data, or for set operations in functional code, which can lead to bugs and unpredictable behavior.",
    "explanation": "`HashSet` provides high-performance, immutable set operations that are safe for concurrent and functional programming.  \nIt avoids the pitfalls of mutable JavaScript `Set` and is optimized for use in Effect workflows.",
    "content": "# Work with Immutable Sets using `HashSet`\n\n## Guideline\n\nUse the `HashSet<A>` data type to represent sets of unique values with efficient, immutable operations.  \n`HashSet` is ideal for membership checks, set algebra, and modeling collections where uniqueness matters.\n\n## Rationale\n\n`HashSet` provides high-performance, immutable set operations that are safe for concurrent and functional programming.  \nIt avoids the pitfalls of mutable JavaScript `Set` and is optimized for use in Effect workflows.\n\n## Good Example\n\n```typescript\nimport { HashSet } from \"effect\";\n\n// Create a HashSet from an array\nconst setA = HashSet.fromIterable([1, 2, 3]);\nconst setB = HashSet.fromIterable([3, 4, 5]);\n\n// Membership check\nconst hasTwo = HashSet.has(setA, 2); // true\n\n// Union, intersection, difference\nconst union = HashSet.union(setA, setB);         // HashSet {1, 2, 3, 4, 5}\nconst intersection = HashSet.intersection(setA, setB); // HashSet {3}\nconst difference = HashSet.difference(setA, setB);     // HashSet {1, 2}\n\n// Add and remove elements\nconst withSix = HashSet.add(setA, 6);    // HashSet {1, 2, 3, 6}\nconst withoutOne = HashSet.remove(setA, 1); // HashSet {2, 3}\n```\n\n**Explanation:**  \n- `HashSet` is immutable and supports efficient set operations.\n- Use it for membership checks, set algebra, and modeling unique collections.\n- Safe for concurrent and functional workflows.\n\n## Anti-Pattern\n\nUsing mutable JavaScript `Set` for shared or concurrent data, or for set operations in functional code, which can lead to bugs and unpredictable behavior."
  },
  {
    "id": "data-array",
    "title": "Working with Immutable Arrays using Data.array",
    "description": "Use Data.array to define arrays whose equality is based on their contents, enabling safe, predictable comparisons and functional operations.",
    "skillLevel": "beginner",
    "useCases": [
      "modeling-data"
    ],
    "example": "```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal arrays\nconst arr1 = Data.array([1, 2, 3]);\nconst arr2 = Data.array([1, 2, 3]);\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(arr1, arr2); // true\n\n// Use arrays as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(arr1);\nconsole.log(HashSet.has(set, arr2)); // true\n\n// Functional operations (map, filter, etc.)\nconst doubled = arr1.map((n) => n * 2); // Data.array([2, 4, 6])\n```\n\n**Explanation:**  \n- `Data.array` creates immutable arrays with value-based equality.\n- Useful for modeling ordered collections in a safe, functional way.\n- Supports all standard array operations, but with immutability and structural equality.",
    "antiPattern": "Using plain JavaScript arrays for value-based logic, as keys in sets/maps, or in concurrent code, which can lead to bugs due to mutability and reference-based comparison.",
    "explanation": "JavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic and concurrent code.  \n`Data.array` provides immutable arrays with structural equality, making them ideal for functional programming and safe domain modeling.",
    "content": "# Working with Immutable Arrays using `Data.array`\n\n## Guideline\n\nUse `Data.array` to create immutable, type-safe arrays that support value-based equality and safe functional operations.  \nThis is useful for modeling ordered collections where immutability and structural equality are important.\n\n## Rationale\n\nJavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic and concurrent code.  \n`Data.array` provides immutable arrays with structural equality, making them ideal for functional programming and safe domain modeling.\n\n## Good Example\n\n```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal arrays\nconst arr1 = Data.array([1, 2, 3]);\nconst arr2 = Data.array([1, 2, 3]);\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(arr1, arr2); // true\n\n// Use arrays as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(arr1);\nconsole.log(HashSet.has(set, arr2)); // true\n\n// Functional operations (map, filter, etc.)\nconst doubled = arr1.map((n) => n * 2); // Data.array([2, 4, 6])\n```\n\n**Explanation:**  \n- `Data.array` creates immutable arrays with value-based equality.\n- Useful for modeling ordered collections in a safe, functional way.\n- Supports all standard array operations, but with immutability and structural equality.\n\n## Anti-Pattern\n\nUsing plain JavaScript arrays for value-based logic, as keys in sets/maps, or in concurrent code, which can lead to bugs due to mutability and reference-based comparison."
  },
  {
    "id": "data-tuple",
    "title": "Working with Tuples using Data.tuple",
    "description": "Use Data.tuple to define tuples whose equality is based on their contents, enabling safe and predictable comparisons and pattern matching.",
    "skillLevel": "beginner",
    "useCases": [
      "domain-modeling"
    ],
    "example": "```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal tuples\nconst t1 = Data.tuple(1, \"Alice\");\nconst t2 = Data.tuple(1, \"Alice\");\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(t1, t2); // true\n\n// Use tuples as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(t1);\nconsole.log(HashSet.has(set, t2)); // true\n\n// Pattern matching on tuples\nconst [id, name] = t1; // id: number, name: string\n```\n\n**Explanation:**  \n- `Data.tuple` creates immutable tuples with value-based equality.\n- Useful for modeling pairs, coordinates, or any fixed-size, heterogeneous data.\n- Supports safe pattern matching and collection operations.",
    "antiPattern": "Using plain arrays for value-based logic or as keys in sets/maps, which compares by reference and can lead to incorrect behavior.",
    "explanation": "JavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic.  \n`Data.tuple` provides immutable tuples with structural equality, making them ideal for domain modeling and functional programming patterns.",
    "content": "# Working with Tuples using `Data.tuple`\n\n## Guideline\n\nUse `Data.tuple` to create immutable, type-safe tuples that support value-based equality and pattern matching.  \nThis is useful for modeling fixed-size, heterogeneous collections of values in a safe and expressive way.\n\n## Rationale\n\nJavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic.  \n`Data.tuple` provides immutable tuples with structural equality, making them ideal for domain modeling and functional programming patterns.\n\n## Good Example\n\n```typescript\nimport { Data, Equal } from \"effect\";\n\n// Create two structurally equal tuples\nconst t1 = Data.tuple(1, \"Alice\");\nconst t2 = Data.tuple(1, \"Alice\");\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(t1, t2); // true\n\n// Use tuples as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(t1);\nconsole.log(HashSet.has(set, t2)); // true\n\n// Pattern matching on tuples\nconst [id, name] = t1; // id: number, name: string\n```\n\n**Explanation:**  \n- `Data.tuple` creates immutable tuples with value-based equality.\n- Useful for modeling pairs, coordinates, or any fixed-size, heterogeneous data.\n- Supports safe pattern matching and collection operations.\n\n## Anti-Pattern\n\nUsing plain arrays for value-based logic or as keys in sets/maps, which compares by reference and can lead to incorrect behavior."
  },
  {
    "id": "wrap-asynchronous-computations",
    "title": "Wrap Asynchronous Computations with tryPromise",
    "description": "Wrap asynchronous computations with tryPromise.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define error type using Data.TaggedError\nclass HttpError extends Data.TaggedError(\"HttpError\")<{\n  readonly message: string;\n}> {}\n\n// Define HTTP client service\nexport class HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  // Provide default implementation\n  sync: () => ({\n    getUrl: (url: string) =>\n      Effect.tryPromise({\n        try: () => fetch(url),\n        catch: (error) =>\n          new HttpError({ message: `Failed to fetch ${url}: ${error}` }),\n      }),\n  }),\n}) {}\n\n// Mock HTTP client for demonstration\nexport class MockHttpClient extends Effect.Service<MockHttpClient>()(\n  \"MockHttpClient\",\n  {\n    sync: () => ({\n      getUrl: (url: string) =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Fetching URL: ${url}`);\n\n          // Simulate different responses based on URL\n          if (url.includes(\"success\")) {\n            yield* Effect.logInfo(\"‚úÖ Request successful\");\n            return new Response(JSON.stringify({ data: \"success\" }), {\n              status: 200,\n            });\n          } else if (url.includes(\"error\")) {\n            yield* Effect.logInfo(\"‚ùå Request failed\");\n            return yield* Effect.fail(\n              new HttpError({ message: \"Server returned 500\" })\n            );\n          } else {\n            yield* Effect.logInfo(\"‚úÖ Request completed\");\n            return new Response(JSON.stringify({ data: \"mock response\" }), {\n              status: 200,\n            });\n          }\n        }),\n    }),\n  }\n) {}\n\n// Demonstrate wrapping asynchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Wrapping Asynchronous Computations Demo ===\");\n\n  const client = yield* MockHttpClient;\n\n  // Example 1: Successful request\n  yield* Effect.logInfo(\"\\n1. Successful request:\");\n  const response1 = yield* client\n    .getUrl(\"https://api.example.com/success\")\n    .pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`Request failed: ${error.message}`);\n          return new Response(\"Error response\", { status: 500 });\n        })\n      )\n    );\n  yield* Effect.logInfo(`Response status: ${response1.status}`);\n\n  // Example 2: Failed request with error handling\n  yield* Effect.logInfo(\"\\n2. Failed request with error handling:\");\n  const response2 = yield* client.getUrl(\"https://api.example.com/error\").pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Request failed: ${error.message}`);\n        return new Response(\"Fallback response\", { status: 200 });\n      })\n    )\n  );\n  yield* Effect.logInfo(`Fallback response status: ${response2.status}`);\n\n  // Example 3: Multiple async operations\n  yield* Effect.logInfo(\"\\n3. Multiple async operations:\");\n  const results = yield* Effect.all(\n    [\n      client.getUrl(\"https://api.example.com/endpoint1\"),\n      client.getUrl(\"https://api.example.com/endpoint2\"),\n      client.getUrl(\"https://api.example.com/endpoint3\"),\n    ],\n    { concurrency: 2 }\n  ).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`One or more requests failed: ${error.message}`);\n        return [];\n      })\n    )\n  );\n  yield* Effect.logInfo(`Completed ${results.length} requests`);\n\n  yield* Effect.logInfo(\n    \"\\n‚úÖ Asynchronous computations demonstration completed!\"\n  );\n});\n\n// Run with mock implementation\nEffect.runPromise(Effect.provide(program, MockHttpClient.Default));\n\n```\n\n**Explanation:**  \n`Effect.tryPromise` wraps a `Promise`-returning function and safely handles\nrejections, moving errors into the Effect's error channel.",
    "antiPattern": "Manually handling `.then()` and `.catch()` inside an `Effect.sync`. This is\nverbose, error-prone, and defeats the purpose of using Effect's built-in\nPromise integration.",
    "explanation": "This is the standard bridge from the Promise-based world to Effect, allowing\nyou to leverage the massive `async/await` ecosystem safely.",
    "content": "# Wrap Asynchronous Computations with tryPromise\n\n## Guideline\n\nTo integrate a `Promise`-based function (like `fetch`), use `Effect.tryPromise`.\n\n## Rationale\n\nThis is the standard bridge from the Promise-based world to Effect, allowing\nyou to leverage the massive `async/await` ecosystem safely.\n\n## Good Example\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Define error type using Data.TaggedError\nclass HttpError extends Data.TaggedError(\"HttpError\")<{\n  readonly message: string;\n}> {}\n\n// Define HTTP client service\nexport class HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  // Provide default implementation\n  sync: () => ({\n    getUrl: (url: string) =>\n      Effect.tryPromise({\n        try: () => fetch(url),\n        catch: (error) =>\n          new HttpError({ message: `Failed to fetch ${url}: ${error}` }),\n      }),\n  }),\n}) {}\n\n// Mock HTTP client for demonstration\nexport class MockHttpClient extends Effect.Service<MockHttpClient>()(\n  \"MockHttpClient\",\n  {\n    sync: () => ({\n      getUrl: (url: string) =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Fetching URL: ${url}`);\n\n          // Simulate different responses based on URL\n          if (url.includes(\"success\")) {\n            yield* Effect.logInfo(\"‚úÖ Request successful\");\n            return new Response(JSON.stringify({ data: \"success\" }), {\n              status: 200,\n            });\n          } else if (url.includes(\"error\")) {\n            yield* Effect.logInfo(\"‚ùå Request failed\");\n            return yield* Effect.fail(\n              new HttpError({ message: \"Server returned 500\" })\n            );\n          } else {\n            yield* Effect.logInfo(\"‚úÖ Request completed\");\n            return new Response(JSON.stringify({ data: \"mock response\" }), {\n              status: 200,\n            });\n          }\n        }),\n    }),\n  }\n) {}\n\n// Demonstrate wrapping asynchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Wrapping Asynchronous Computations Demo ===\");\n\n  const client = yield* MockHttpClient;\n\n  // Example 1: Successful request\n  yield* Effect.logInfo(\"\\n1. Successful request:\");\n  const response1 = yield* client\n    .getUrl(\"https://api.example.com/success\")\n    .pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`Request failed: ${error.message}`);\n          return new Response(\"Error response\", { status: 500 });\n        })\n      )\n    );\n  yield* Effect.logInfo(`Response status: ${response1.status}`);\n\n  // Example 2: Failed request with error handling\n  yield* Effect.logInfo(\"\\n2. Failed request with error handling:\");\n  const response2 = yield* client.getUrl(\"https://api.example.com/error\").pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Request failed: ${error.message}`);\n        return new Response(\"Fallback response\", { status: 200 });\n      })\n    )\n  );\n  yield* Effect.logInfo(`Fallback response status: ${response2.status}`);\n\n  // Example 3: Multiple async operations\n  yield* Effect.logInfo(\"\\n3. Multiple async operations:\");\n  const results = yield* Effect.all(\n    [\n      client.getUrl(\"https://api.example.com/endpoint1\"),\n      client.getUrl(\"https://api.example.com/endpoint2\"),\n      client.getUrl(\"https://api.example.com/endpoint3\"),\n    ],\n    { concurrency: 2 }\n  ).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`One or more requests failed: ${error.message}`);\n        return [];\n      })\n    )\n  );\n  yield* Effect.logInfo(`Completed ${results.length} requests`);\n\n  yield* Effect.logInfo(\n    \"\\n‚úÖ Asynchronous computations demonstration completed!\"\n  );\n});\n\n// Run with mock implementation\nEffect.runPromise(Effect.provide(program, MockHttpClient.Default));\n\n```\n\n**Explanation:**  \n`Effect.tryPromise` wraps a `Promise`-returning function and safely handles\nrejections, moving errors into the Effect's error channel.\n\n## Anti-Pattern\n\nManually handling `.then()` and `.catch()` inside an `Effect.sync`. This is\nverbose, error-prone, and defeats the purpose of using Effect's built-in\nPromise integration."
  },
  {
    "id": "wrap-synchronous-computations",
    "title": "Wrap Synchronous Computations with sync and try",
    "description": "Wrap synchronous computations with sync and try.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\nconst randomNumber = Effect.sync(() => Math.random());\n\nconst parseJson = (input: string) =>\n  Effect.try({\n    try: () => JSON.parse(input),\n    catch: (error) => new Error(`JSON parsing failed: ${error}`),\n  });\n\n// More examples of wrapping synchronous computations\nconst divide = (a: number, b: number) =>\n  Effect.try({\n    try: () => {\n      if (b === 0) throw new Error(\"Division by zero\");\n      return a / b;\n    },\n    catch: (error) => new Error(`Division failed: ${error}`),\n  });\n\nconst processString = (str: string) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Processing string: \"${str}\"`);\n    return str.toUpperCase().split(\"\").reverse().join(\"\");\n  });\n\n// Demonstrate wrapping synchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Wrapping Synchronous Computations Demo ===\");\n\n  // Example 1: Basic sync computation\n  yield* Effect.log(\"\\n1. Basic sync computation (random number):\");\n  const random1 = yield* randomNumber;\n  const random2 = yield* randomNumber;\n  yield* Effect.log(`Random numbers: ${random1.toFixed(4)}, ${random2.toFixed(4)}`);\n\n  // Example 2: Successful JSON parsing\n  yield* Effect.log(\"\\n2. Successful JSON parsing:\");\n  const validJson = '{\"name\": \"Paul\", \"age\": 30}';\n  const parsed = yield* parseJson(validJson);\n  yield* Effect.log(\"Parsed JSON:\" + JSON.stringify(parsed));\n\n  // Example 3: Failed JSON parsing with error logging\n  yield* Effect.log(\"\\n3. Failed JSON parsing with error logging:\");\n  const invalidJson = '{\"name\": \"Paul\", \"age\":}';\n  yield* parseJson(invalidJson).pipe(\n    Effect.tapError((error) => Effect.log(`Parsing failed: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed({ name: \"default\", age: 0 }))\n  );\n  yield* Effect.log(\"Continued after error (with recovery)\");\n\n  // Example 4: Division with error logging and recovery\n  yield* Effect.log(\"\\n4. Division with error logging and recovery:\");\n  const division1 = yield* divide(10, 2);\n  yield* Effect.log(`10 / 2 = ${division1}`);\n\n  // Use tapError to log, then catchAll to recover\n  const division2 = yield* divide(10, 0).pipe(\n    Effect.tapError((error) => Effect.log(`Division error: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed(-1))\n  );\n  yield* Effect.log(`10 / 0 = ${division2} (error handled)`);\n\n  // Example 5: String processing\n  yield* Effect.log(\"\\n5. String processing:\");\n  const processed = yield* processString(\"Hello Effect\");\n  yield* Effect.log(`Processed result: \"${processed}\"`);\n\n  // Example 6: Combining multiple sync operations\n  yield* Effect.log(\"\\n6. Combining multiple sync operations:\");\n  const combined = yield* Effect.gen(function* () {\n    const num = yield* randomNumber;\n    const multiplied = yield* Effect.sync(() => num * 100);\n    const rounded = yield* Effect.sync(() => Math.round(multiplied));\n    return rounded;\n  });\n  yield* Effect.log(`Combined operations result: ${combined}`);\n\n  yield* Effect.log(\"\\n‚úÖ Synchronous computations demonstration completed!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \nUse `Effect.sync` for safe synchronous code, and `Effect.try` to safely\nhandle exceptions from potentially unsafe code.",
    "antiPattern": "Never use `Effect.sync` for an operation that could throw, like `JSON.parse`.\nThis can lead to unhandled exceptions that crash your application.",
    "explanation": "This is the primary way to safely integrate with synchronous libraries like\n`JSON.parse`. `Effect.try` captures any thrown exception and moves it into\nthe Effect's error channel.",
    "content": "# Wrap Synchronous Computations with sync and try\n\n## Guideline\n\nTo bring a synchronous side-effect into Effect, wrap it in a thunk (`() => ...`).\nUse `Effect.sync` for functions guaranteed not to throw, and `Effect.try` for\nfunctions that might throw.\n\n## Rationale\n\nThis is the primary way to safely integrate with synchronous libraries like\n`JSON.parse`. `Effect.try` captures any thrown exception and moves it into\nthe Effect's error channel.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\nconst randomNumber = Effect.sync(() => Math.random());\n\nconst parseJson = (input: string) =>\n  Effect.try({\n    try: () => JSON.parse(input),\n    catch: (error) => new Error(`JSON parsing failed: ${error}`),\n  });\n\n// More examples of wrapping synchronous computations\nconst divide = (a: number, b: number) =>\n  Effect.try({\n    try: () => {\n      if (b === 0) throw new Error(\"Division by zero\");\n      return a / b;\n    },\n    catch: (error) => new Error(`Division failed: ${error}`),\n  });\n\nconst processString = (str: string) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Processing string: \"${str}\"`);\n    return str.toUpperCase().split(\"\").reverse().join(\"\");\n  });\n\n// Demonstrate wrapping synchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Wrapping Synchronous Computations Demo ===\");\n\n  // Example 1: Basic sync computation\n  yield* Effect.log(\"\\n1. Basic sync computation (random number):\");\n  const random1 = yield* randomNumber;\n  const random2 = yield* randomNumber;\n  yield* Effect.log(`Random numbers: ${random1.toFixed(4)}, ${random2.toFixed(4)}`);\n\n  // Example 2: Successful JSON parsing\n  yield* Effect.log(\"\\n2. Successful JSON parsing:\");\n  const validJson = '{\"name\": \"Paul\", \"age\": 30}';\n  const parsed = yield* parseJson(validJson);\n  yield* Effect.log(\"Parsed JSON:\" + JSON.stringify(parsed));\n\n  // Example 3: Failed JSON parsing with error logging\n  yield* Effect.log(\"\\n3. Failed JSON parsing with error logging:\");\n  const invalidJson = '{\"name\": \"Paul\", \"age\":}';\n  yield* parseJson(invalidJson).pipe(\n    Effect.tapError((error) => Effect.log(`Parsing failed: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed({ name: \"default\", age: 0 }))\n  );\n  yield* Effect.log(\"Continued after error (with recovery)\");\n\n  // Example 4: Division with error logging and recovery\n  yield* Effect.log(\"\\n4. Division with error logging and recovery:\");\n  const division1 = yield* divide(10, 2);\n  yield* Effect.log(`10 / 2 = ${division1}`);\n\n  // Use tapError to log, then catchAll to recover\n  const division2 = yield* divide(10, 0).pipe(\n    Effect.tapError((error) => Effect.log(`Division error: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed(-1))\n  );\n  yield* Effect.log(`10 / 0 = ${division2} (error handled)`);\n\n  // Example 5: String processing\n  yield* Effect.log(\"\\n5. String processing:\");\n  const processed = yield* processString(\"Hello Effect\");\n  yield* Effect.log(`Processed result: \"${processed}\"`);\n\n  // Example 6: Combining multiple sync operations\n  yield* Effect.log(\"\\n6. Combining multiple sync operations:\");\n  const combined = yield* Effect.gen(function* () {\n    const num = yield* randomNumber;\n    const multiplied = yield* Effect.sync(() => num * 100);\n    const rounded = yield* Effect.sync(() => Math.round(multiplied));\n    return rounded;\n  });\n  yield* Effect.log(`Combined operations result: ${combined}`);\n\n  yield* Effect.log(\"\\n‚úÖ Synchronous computations demonstration completed!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \nUse `Effect.sync` for safe synchronous code, and `Effect.try` to safely\nhandle exceptions from potentially unsafe code.\n\n## Anti-Pattern\n\nNever use `Effect.sync` for an operation that could throw, like `JSON.parse`.\nThis can lead to unhandled exceptions that crash your application."
  },
  {
    "id": "constructor-try-trypromise",
    "title": "Wrapping Synchronous and Asynchronous Computations",
    "description": "Use try and tryPromise to lift code that may throw or reject into Effect, capturing errors in the failure channel.",
    "skillLevel": "beginner",
    "useCases": [
      "error-management"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Synchronous: Wrap code that may throw\nconst effectSync = Effect.try({\n  try: () => JSON.parse(\"{ invalid json }\"),\n  catch: (error) => `Parse error: ${String(error)}`\n}); // Effect<string, never, never>\n\n// Asynchronous: Wrap a promise that may reject\nconst effectAsync = Effect.tryPromise({\n  try: () => fetch(\"https://api.example.com/data\").then(res => res.json()),\n  catch: (error) => `Network error: ${String(error)}`\n}); // Effect<string, any, never>\n```\n\n**Explanation:**  \n- `Effect.try` wraps a synchronous computation that may throw, capturing the error in the failure channel.\n- `Effect.tryPromise` wraps an async computation (Promise) that may reject, capturing the rejection as a failure.",
    "antiPattern": "Using try/catch for error handling, or relying on untyped Promise rejections, which leads to less composable and less type-safe code.",
    "explanation": "Wrapping potentially unsafe code in `try` or `tryPromise` ensures that all errors are handled in a uniform, declarative way.  \nThis eliminates the need for try/catch blocks and makes error handling explicit and type-safe.",
    "content": "# Wrapping Synchronous and Asynchronous Computations\n\n## Guideline\n\nUse the `try` and `tryPromise` constructors to safely wrap synchronous or asynchronous computations that may throw exceptions or reject promises.  \nThis captures errors in the Effect failure channel, making them type-safe and composable.\n\n## Rationale\n\nWrapping potentially unsafe code in `try` or `tryPromise` ensures that all errors are handled in a uniform, declarative way.  \nThis eliminates the need for try/catch blocks and makes error handling explicit and type-safe.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Synchronous: Wrap code that may throw\nconst effectSync = Effect.try({\n  try: () => JSON.parse(\"{ invalid json }\"),\n  catch: (error) => `Parse error: ${String(error)}`\n}); // Effect<string, never, never>\n\n// Asynchronous: Wrap a promise that may reject\nconst effectAsync = Effect.tryPromise({\n  try: () => fetch(\"https://api.example.com/data\").then(res => res.json()),\n  catch: (error) => `Network error: ${String(error)}`\n}); // Effect<string, any, never>\n```\n\n**Explanation:**  \n- `Effect.try` wraps a synchronous computation that may throw, capturing the error in the failure channel.\n- `Effect.tryPromise` wraps an async computation (Promise) that may reject, capturing the rejection as a failure.\n\n## Anti-Pattern\n\nUsing try/catch for error handling, or relying on untyped Promise rejections, which leads to less composable and less type-safe code."
  },
  {
    "id": "write-sequential-code-with-gen",
    "title": "Write Sequential Code with Effect.gen",
    "description": "Write sequential code with Effect.gen.",
    "skillLevel": "beginner",
    "useCases": [
      "core-concepts"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Mock API functions for demonstration\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"100 millis\");\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst fetchUserPosts = (userId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching posts for user ${userId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"150 millis\");\n    return [\n      { id: 1, title: \"First Post\", userId },\n      { id: 2, title: \"Second Post\", userId },\n    ];\n  });\n\nconst fetchPostComments = (postId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching comments for post ${postId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"75 millis\");\n    return [\n      { id: 1, text: \"Great post!\", postId },\n      { id: 2, text: \"Thanks for sharing\", postId },\n    ];\n  });\n\n// Example of sequential code with Effect.gen\nconst getUserDataWithGen = (userId: number) =>\n  Effect.gen(function* () {\n    // Step 1: Fetch user\n    const user = yield* fetchUser(userId);\n    yield* Effect.logInfo(`‚úÖ Got user: ${user.name}`);\n\n    // Step 2: Fetch user's posts (depends on user data)\n    const posts = yield* fetchUserPosts(user.id);\n    yield* Effect.logInfo(`‚úÖ Got ${posts.length} posts`);\n\n    // Step 3: Fetch comments for first post (depends on posts data)\n    const firstPost = posts[0];\n    const comments = yield* fetchPostComments(firstPost.id);\n    yield* Effect.logInfo(\n      `‚úÖ Got ${comments.length} comments for \"${firstPost.title}\"`\n    );\n\n    // Step 4: Combine all data\n    const result = {\n      user,\n      posts,\n      featuredPost: {\n        ...firstPost,\n        comments,\n      },\n    };\n\n    yield* Effect.logInfo(\"‚úÖ Successfully combined all user data\");\n    return result;\n  });\n\n// Example without Effect.gen (more complex)\nconst getUserDataWithoutGen = (userId: number) =>\n  fetchUser(userId).pipe(\n    Effect.flatMap((user) =>\n      fetchUserPosts(user.id).pipe(\n        Effect.flatMap((posts) =>\n          fetchPostComments(posts[0].id).pipe(\n            Effect.map((comments) => ({\n              user,\n              posts,\n              featuredPost: {\n                ...posts[0],\n                comments,\n              },\n            }))\n          )\n        )\n      )\n    )\n  );\n\n// Demonstrate writing sequential code with gen\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Writing Sequential Code with Effect.gen Demo ===\");\n\n  // Example 1: Sequential operations with Effect.gen\n  yield* Effect.logInfo(\"\\n1. Sequential operations with Effect.gen:\");\n  const userData = yield* getUserDataWithGen(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData) {\n    yield* Effect.logInfo(\n      `Final result: User \"${userData.user.name}\" has ${userData.posts.length} posts`\n    );\n    yield* Effect.logInfo(\n      `Featured post: \"${userData.featuredPost.title}\" with ${userData.featuredPost.comments.length} comments`\n    );\n  }\n\n  // Example 2: Compare with traditional promise-like chaining\n  yield* Effect.logInfo(\"\\n2. Same logic without Effect.gen (for comparison):\");\n  const userData2 = yield* getUserDataWithoutGen(456).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData2) {\n    yield* Effect.logInfo(\n      `Result from traditional approach: User \"${userData2.user.name}\"`\n    );\n  }\n\n  // Example 3: Error handling in sequential code\n  yield* Effect.logInfo(\"\\n3. Error handling in sequential operations:\");\n  const errorHandling = yield* Effect.gen(function* () {\n    try {\n      const user = yield* fetchUser(999);\n      const posts = yield* fetchUserPosts(user.id);\n      return { user, posts };\n    } catch (error) {\n      yield* Effect.logError(`Error in sequential operations: ${error}`);\n      return null;\n    }\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Caught error: ${error}`);\n        return { user: null, posts: [] };\n      })\n    )\n  );\n\n  yield* Effect.logInfo(\n    `Error handling result: ${errorHandling ? \"Success\" : \"Handled error\"}`\n  );\n\n  yield* Effect.logInfo(\"\\n‚úÖ Sequential code demonstration completed!\");\n  yield* Effect.logInfo(\n    \"Effect.gen makes sequential async code look like synchronous code!\"\n  );\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Effect.gen` allows you to write top-to-bottom code that is easy to read and\nmaintain, even when chaining many asynchronous steps.",
    "antiPattern": "Deeply nesting `flatMap` calls. This is much harder to read and maintain than\nthe equivalent `Effect.gen` block.",
    "explanation": "`Effect.gen` uses generator functions to create a flat, linear, and highly\nreadable sequence of operations, avoiding the nested \"callback hell\" of\n`flatMap`.",
    "content": "# Write Sequential Code with Effect.gen\n\n## Guideline\n\nFor sequential operations that depend on each other, use `Effect.gen` to write\nyour logic in a familiar, imperative style. It's the Effect-native equivalent\nof `async/await`.\n\n## Rationale\n\n`Effect.gen` uses generator functions to create a flat, linear, and highly\nreadable sequence of operations, avoiding the nested \"callback hell\" of\n`flatMap`.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Mock API functions for demonstration\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"100 millis\");\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst fetchUserPosts = (userId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching posts for user ${userId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"150 millis\");\n    return [\n      { id: 1, title: \"First Post\", userId },\n      { id: 2, title: \"Second Post\", userId },\n    ];\n  });\n\nconst fetchPostComments = (postId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching comments for post ${postId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"75 millis\");\n    return [\n      { id: 1, text: \"Great post!\", postId },\n      { id: 2, text: \"Thanks for sharing\", postId },\n    ];\n  });\n\n// Example of sequential code with Effect.gen\nconst getUserDataWithGen = (userId: number) =>\n  Effect.gen(function* () {\n    // Step 1: Fetch user\n    const user = yield* fetchUser(userId);\n    yield* Effect.logInfo(`‚úÖ Got user: ${user.name}`);\n\n    // Step 2: Fetch user's posts (depends on user data)\n    const posts = yield* fetchUserPosts(user.id);\n    yield* Effect.logInfo(`‚úÖ Got ${posts.length} posts`);\n\n    // Step 3: Fetch comments for first post (depends on posts data)\n    const firstPost = posts[0];\n    const comments = yield* fetchPostComments(firstPost.id);\n    yield* Effect.logInfo(\n      `‚úÖ Got ${comments.length} comments for \"${firstPost.title}\"`\n    );\n\n    // Step 4: Combine all data\n    const result = {\n      user,\n      posts,\n      featuredPost: {\n        ...firstPost,\n        comments,\n      },\n    };\n\n    yield* Effect.logInfo(\"‚úÖ Successfully combined all user data\");\n    return result;\n  });\n\n// Example without Effect.gen (more complex)\nconst getUserDataWithoutGen = (userId: number) =>\n  fetchUser(userId).pipe(\n    Effect.flatMap((user) =>\n      fetchUserPosts(user.id).pipe(\n        Effect.flatMap((posts) =>\n          fetchPostComments(posts[0].id).pipe(\n            Effect.map((comments) => ({\n              user,\n              posts,\n              featuredPost: {\n                ...posts[0],\n                comments,\n              },\n            }))\n          )\n        )\n      )\n    )\n  );\n\n// Demonstrate writing sequential code with gen\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Writing Sequential Code with Effect.gen Demo ===\");\n\n  // Example 1: Sequential operations with Effect.gen\n  yield* Effect.logInfo(\"\\n1. Sequential operations with Effect.gen:\");\n  const userData = yield* getUserDataWithGen(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData) {\n    yield* Effect.logInfo(\n      `Final result: User \"${userData.user.name}\" has ${userData.posts.length} posts`\n    );\n    yield* Effect.logInfo(\n      `Featured post: \"${userData.featuredPost.title}\" with ${userData.featuredPost.comments.length} comments`\n    );\n  }\n\n  // Example 2: Compare with traditional promise-like chaining\n  yield* Effect.logInfo(\"\\n2. Same logic without Effect.gen (for comparison):\");\n  const userData2 = yield* getUserDataWithoutGen(456).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData2) {\n    yield* Effect.logInfo(\n      `Result from traditional approach: User \"${userData2.user.name}\"`\n    );\n  }\n\n  // Example 3: Error handling in sequential code\n  yield* Effect.logInfo(\"\\n3. Error handling in sequential operations:\");\n  const errorHandling = yield* Effect.gen(function* () {\n    try {\n      const user = yield* fetchUser(999);\n      const posts = yield* fetchUserPosts(user.id);\n      return { user, posts };\n    } catch (error) {\n      yield* Effect.logError(`Error in sequential operations: ${error}`);\n      return null;\n    }\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Caught error: ${error}`);\n        return { user: null, posts: [] };\n      })\n    )\n  );\n\n  yield* Effect.logInfo(\n    `Error handling result: ${errorHandling ? \"Success\" : \"Handled error\"}`\n  );\n\n  yield* Effect.logInfo(\"\\n‚úÖ Sequential code demonstration completed!\");\n  yield* Effect.logInfo(\n    \"Effect.gen makes sequential async code look like synchronous code!\"\n  );\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Effect.gen` allows you to write top-to-bottom code that is easy to read and\nmaintain, even when chaining many asynchronous steps.\n\n## Anti-Pattern\n\nDeeply nesting `flatMap` calls. This is much harder to read and maintain than\nthe equivalent `Effect.gen` block."
  },
  {
    "id": "write-tests-that-adapt-to-application-code",
    "title": "Write Tests That Adapt to Application Code",
    "description": "Write tests that adapt to application code.",
    "skillLevel": "intermediate",
    "useCases": [
      "testing"
    ],
    "example": "```typescript\nimport { Effect } from \"effect\";\n\n// Define our types\ninterface User {\n  id: number;\n  name: string;\n}\n\nclass NotFoundError extends Error {\n  readonly _tag = \"NotFoundError\";\n  constructor(readonly id: number) {\n    super(`User ${id} not found`);\n  }\n}\n\n// Define database service interface\ninterface DatabaseServiceApi {\n  getUserById: (id: number) => Effect.Effect<User, NotFoundError>;\n}\n\n// Implement the service with mock data\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Simulate database lookup\n        if (id === 404) {\n          return Effect.fail(new NotFoundError(id));\n        }\n        return Effect.succeed({ id, name: `User ${id}` });\n      },\n    }),\n  }\n) {}\n\n// Test service implementation for testing\nclass TestDatabaseService extends Effect.Service<TestDatabaseService>()(\n  \"TestDatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Test data with predictable responses\n        const testUsers = [\n          { id: 1, name: \"Test User 1\" },\n          { id: 2, name: \"Test User 2\" },\n          { id: 123, name: \"User 123\" },\n        ];\n\n        const user = testUsers.find((u) => u.id === id);\n        if (user) {\n          return Effect.succeed(user);\n        }\n        return Effect.fail(new NotFoundError(id));\n      },\n    }),\n  }\n) {}\n\n// Business logic that uses the database service\nconst getUserWithFallback = (id: number) =>\n  Effect.gen(function* () {\n    const db = yield* DatabaseService;\n    return yield* Effect.gen(function* () {\n      const user = yield* db.getUserById(id);\n      return user;\n    }).pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          if (error instanceof NotFoundError) {\n            yield* Effect.logInfo(`User ${id} not found, using fallback`);\n            return { id, name: `Fallback User ${id}` };\n          }\n          return yield* Effect.fail(error);\n        })\n      )\n    );\n  });\n\n// Create a program that demonstrates the service\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\n    \"=== Writing Tests that Adapt to Application Code Demo ===\"\n  );\n\n  const db = yield* DatabaseService;\n\n  // Example 1: Successful user lookup\n  yield* Effect.logInfo(\"\\n1. Looking up existing user 123...\");\n  const user = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(123);\n    } catch (error) {\n      yield* Effect.logError(`Failed to get user: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n\n  // Example 2: Handle non-existent user with proper error handling\n  yield* Effect.logInfo(\"\\n2. Looking up non-existent user 404...\");\n  const notFoundUser = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(404);\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\n          `‚úÖ Properly handled NotFoundError: ${error.message}`\n        );\n        return { id: 404, name: \"Not Found\" };\n      }\n      yield* Effect.logError(`Unexpected error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Result: ${JSON.stringify(notFoundUser)}`);\n\n  // Example 3: Business logic with fallback\n  yield* Effect.logInfo(\"\\n3. Business logic with fallback for missing user:\");\n  const userWithFallback = yield* getUserWithFallback(999);\n  yield* Effect.logInfo(\n    `User with fallback: ${JSON.stringify(userWithFallback)}`\n  );\n\n  // Example 4: Testing with different service implementation\n  yield* Effect.logInfo(\"\\n4. Testing with test service implementation:\");\n  yield* Effect.provide(\n    Effect.gen(function* () {\n      const testDb = yield* TestDatabaseService;\n\n      // Test existing user\n      const testUser1 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(1);\n        } catch (error) {\n          yield* Effect.logError(`Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          return { id: -1, name: \"Test Error\" };\n        }\n      });\n      yield* Effect.logInfo(`Test user 1: ${JSON.stringify(testUser1)}`);\n\n      // Test non-existing user\n      const testUser404 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(404);\n        } catch (error) {\n          yield* Effect.logInfo(\n            `‚úÖ Test service properly threw NotFoundError: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return { id: 404, name: \"Test Not Found\" };\n        }\n      });\n      yield* Effect.logInfo(`Test result: ${JSON.stringify(testUser404)}`);\n    }),\n    TestDatabaseService.Default\n  );\n\n  yield* Effect.logInfo(\n    \"\\n‚úÖ Tests that adapt to application code demonstration completed!\"\n  );\n  yield* Effect.logInfo(\n    \"The same business logic works with different service implementations!\"\n  );\n});\n\n// Run the program with the default database service\nEffect.runPromise(\n  Effect.provide(program, DatabaseService.Default) as Effect.Effect<void, never, never>\n);\n\n```\n\n**Explanation:**  \nTests should reflect the real interface and behavior of your code, not force changes to it.",
    "antiPattern": "Any action where the test dictates a change to the application code. Do not modify a service file to add a method just because a test needs it. If a test fails, fix the test.",
    "explanation": "Treating application code as immutable during testing prevents the introduction of bugs and false test confidence. The goal of a test is to verify real-world behavior; changing that behavior to suit the test invalidates its purpose.",
    "content": "# Write Tests That Adapt to Application Code\n\n## Guideline\n\nTests are secondary artifacts that serve to validate the application. The application's code and interfaces are the source of truth. When a test fails, fix the test's logic or setup, not the production code.\n\n## Rationale\n\nTreating application code as immutable during testing prevents the introduction of bugs and false test confidence. The goal of a test is to verify real-world behavior; changing that behavior to suit the test invalidates its purpose.\n\n## Good Example\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define our types\ninterface User {\n  id: number;\n  name: string;\n}\n\nclass NotFoundError extends Error {\n  readonly _tag = \"NotFoundError\";\n  constructor(readonly id: number) {\n    super(`User ${id} not found`);\n  }\n}\n\n// Define database service interface\ninterface DatabaseServiceApi {\n  getUserById: (id: number) => Effect.Effect<User, NotFoundError>;\n}\n\n// Implement the service with mock data\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Simulate database lookup\n        if (id === 404) {\n          return Effect.fail(new NotFoundError(id));\n        }\n        return Effect.succeed({ id, name: `User ${id}` });\n      },\n    }),\n  }\n) {}\n\n// Test service implementation for testing\nclass TestDatabaseService extends Effect.Service<TestDatabaseService>()(\n  \"TestDatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Test data with predictable responses\n        const testUsers = [\n          { id: 1, name: \"Test User 1\" },\n          { id: 2, name: \"Test User 2\" },\n          { id: 123, name: \"User 123\" },\n        ];\n\n        const user = testUsers.find((u) => u.id === id);\n        if (user) {\n          return Effect.succeed(user);\n        }\n        return Effect.fail(new NotFoundError(id));\n      },\n    }),\n  }\n) {}\n\n// Business logic that uses the database service\nconst getUserWithFallback = (id: number) =>\n  Effect.gen(function* () {\n    const db = yield* DatabaseService;\n    return yield* Effect.gen(function* () {\n      const user = yield* db.getUserById(id);\n      return user;\n    }).pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          if (error instanceof NotFoundError) {\n            yield* Effect.logInfo(`User ${id} not found, using fallback`);\n            return { id, name: `Fallback User ${id}` };\n          }\n          return yield* Effect.fail(error);\n        })\n      )\n    );\n  });\n\n// Create a program that demonstrates the service\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\n    \"=== Writing Tests that Adapt to Application Code Demo ===\"\n  );\n\n  const db = yield* DatabaseService;\n\n  // Example 1: Successful user lookup\n  yield* Effect.logInfo(\"\\n1. Looking up existing user 123...\");\n  const user = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(123);\n    } catch (error) {\n      yield* Effect.logError(`Failed to get user: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n\n  // Example 2: Handle non-existent user with proper error handling\n  yield* Effect.logInfo(\"\\n2. Looking up non-existent user 404...\");\n  const notFoundUser = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(404);\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\n          `‚úÖ Properly handled NotFoundError: ${error.message}`\n        );\n        return { id: 404, name: \"Not Found\" };\n      }\n      yield* Effect.logError(`Unexpected error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Result: ${JSON.stringify(notFoundUser)}`);\n\n  // Example 3: Business logic with fallback\n  yield* Effect.logInfo(\"\\n3. Business logic with fallback for missing user:\");\n  const userWithFallback = yield* getUserWithFallback(999);\n  yield* Effect.logInfo(\n    `User with fallback: ${JSON.stringify(userWithFallback)}`\n  );\n\n  // Example 4: Testing with different service implementation\n  yield* Effect.logInfo(\"\\n4. Testing with test service implementation:\");\n  yield* Effect.provide(\n    Effect.gen(function* () {\n      const testDb = yield* TestDatabaseService;\n\n      // Test existing user\n      const testUser1 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(1);\n        } catch (error) {\n          yield* Effect.logError(`Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          return { id: -1, name: \"Test Error\" };\n        }\n      });\n      yield* Effect.logInfo(`Test user 1: ${JSON.stringify(testUser1)}`);\n\n      // Test non-existing user\n      const testUser404 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(404);\n        } catch (error) {\n          yield* Effect.logInfo(\n            `‚úÖ Test service properly threw NotFoundError: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return { id: 404, name: \"Test Not Found\" };\n        }\n      });\n      yield* Effect.logInfo(`Test result: ${JSON.stringify(testUser404)}`);\n    }),\n    TestDatabaseService.Default\n  );\n\n  yield* Effect.logInfo(\n    \"\\n‚úÖ Tests that adapt to application code demonstration completed!\"\n  );\n  yield* Effect.logInfo(\n    \"The same business logic works with different service implementations!\"\n  );\n});\n\n// Run the program with the default database service\nEffect.runPromise(\n  Effect.provide(program, DatabaseService.Default) as Effect.Effect<void, never, never>\n);\n\n```\n\n**Explanation:**  \nTests should reflect the real interface and behavior of your code, not force changes to it.\n\n## Anti-Pattern\n\nAny action where the test dictates a change to the application code. Do not modify a service file to add a method just because a test needs it. If a test fails, fix the test."
  }
]